// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Account) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Account) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.SipRealm.Set {
			e.FieldStart("sip_realm")
			s.SipRealm.Encode(e)
		}
	}
	{
		if s.RegistrationHook.Set {
			e.FieldStart("registration_hook")
			s.RegistrationHook.Encode(e)
		}
	}
	{
		if s.DeviceCallingApplicationSid.Set {
			e.FieldStart("device_calling_application_sid")
			s.DeviceCallingApplicationSid.Encode(e)
		}
	}
	{
		e.FieldStart("service_provider_sid")
		json.EncodeUUID(e, s.ServiceProviderSid)
	}
}

var jsonFieldsNameOfAccount = [6]string{
	0: "account_sid",
	1: "name",
	2: "sip_realm",
	3: "registration_hook",
	4: "device_calling_application_sid",
	5: "service_provider_sid",
}

// Decode decodes Account from json.
func (s *Account) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Account to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sip_realm":
			if err := func() error {
				s.SipRealm.Reset()
				if err := s.SipRealm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_realm\"")
			}
		case "registration_hook":
			if err := func() error {
				s.RegistrationHook.Reset()
				if err := s.RegistrationHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registration_hook\"")
			}
		case "device_calling_application_sid":
			if err := func() error {
				s.DeviceCallingApplicationSid.Reset()
				if err := s.DeviceCallingApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"device_calling_application_sid\"")
			}
		case "service_provider_sid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ServiceProviderSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Account")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccount) {
					name = jsonFieldsNameOfAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Account) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Account) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountRegistrationHook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountRegistrationHook) encodeFields(e *jx.Encoder) {
	{
		if s.WebhookSid.Set {
			e.FieldStart("webhook_sid")
			s.WebhookSid.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("method")
		s.Method.Encode(e)
	}
	{
		e.FieldStart("username")
		s.Username.Encode(e)
	}
	{
		e.FieldStart("password")
		s.Password.Encode(e)
	}
}

var jsonFieldsNameOfAccountRegistrationHook = [5]string{
	0: "webhook_sid",
	1: "url",
	2: "method",
	3: "username",
	4: "password",
}

// Decode decodes AccountRegistrationHook from json.
func (s *AccountRegistrationHook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountRegistrationHook to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "webhook_sid":
			if err := func() error {
				s.WebhookSid.Reset()
				if err := s.WebhookSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_sid\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "method":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountRegistrationHook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountRegistrationHook) {
					name = jsonFieldsNameOfAccountRegistrationHook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountRegistrationHook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountRegistrationHook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountRegistrationHookMethod as json.
func (s AccountRegistrationHookMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccountRegistrationHookMethod from json.
func (s *AccountRegistrationHookMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountRegistrationHookMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccountRegistrationHookMethod(v) {
	case AccountRegistrationHookMethodGET:
		*s = AccountRegistrationHookMethodGET
	case AccountRegistrationHookMethodPOST:
		*s = AccountRegistrationHookMethodPOST
	default:
		*s = AccountRegistrationHookMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountRegistrationHookMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountRegistrationHookMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiKey) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("api_key_sid")
		json.EncodeUUID(e, s.APIKeySid)
	}
	{
		e.FieldStart("token")
		json.EncodeUUID(e, s.Token)
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUsed.Set {
			e.FieldStart("last_used")
			s.LastUsed.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfApiKey = [7]string{
	0: "api_key_sid",
	1: "token",
	2: "account_sid",
	3: "service_provider_sid",
	4: "expires_at",
	5: "created_at",
	6: "last_used",
}

// Decode decodes ApiKey from json.
func (s *ApiKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiKey to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "api_key_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.APIKeySid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key_sid\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.Token = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_used":
			if err := func() error {
				s.LastUsed.Reset()
				if err := s.LastUsed.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiKey) {
					name = jsonFieldsNameOfApiKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Application) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Application) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("application_sid")
		json.EncodeUUID(e, s.ApplicationSid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("call_hook")
		s.CallHook.Encode(e)
	}
	{
		e.FieldStart("call_status_hook")
		s.CallStatusHook.Encode(e)
	}
	{
		e.FieldStart("messaging_hook")
		s.MessagingHook.Encode(e)
	}
	{
		e.FieldStart("record_all_calls")
		s.RecordAllCalls.Encode(e)
	}
}

var jsonFieldsNameOfApplication = [7]string{
	0: "application_sid",
	1: "name",
	2: "account_sid",
	3: "call_hook",
	4: "call_status_hook",
	5: "messaging_hook",
	6: "record_all_calls",
}

// Decode decodes Application from json.
func (s *Application) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Application to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "application_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ApplicationSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account_sid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_hook":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CallHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_hook\"")
			}
		case "call_status_hook":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.CallStatusHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_status_hook\"")
			}
		case "messaging_hook":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.MessagingHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_hook\"")
			}
		case "record_all_calls":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.RecordAllCalls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_all_calls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Application")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplication) {
					name = jsonFieldsNameOfApplication[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Application) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Application) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplicationRecordAllCalls as json.
func (s ApplicationRecordAllCalls) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes ApplicationRecordAllCalls from json.
func (s *ApplicationRecordAllCalls) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplicationRecordAllCalls to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = ApplicationRecordAllCalls(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplicationRecordAllCalls) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplicationRecordAllCalls) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Call) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Call) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		e.FieldStart("call_id")
		e.Str(s.CallID)
	}
	{
		e.FieldStart("call_sid")
		json.EncodeUUID(e, s.CallSid)
	}
	{
		e.FieldStart("call_status")
		s.CallStatus.Encode(e)
	}
	{
		if s.CallerName.Set {
			e.FieldStart("caller_name")
			s.CallerName.Encode(e)
		}
	}
	{
		e.FieldStart("direction")
		s.Direction.Encode(e)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		if s.OriginatingSipTrunkName.Set {
			e.FieldStart("originating_sip_trunk_name")
			s.OriginatingSipTrunkName.Encode(e)
		}
	}
	{
		if s.ParentCallSid.Set {
			e.FieldStart("parent_call_sid")
			s.ParentCallSid.Encode(e)
		}
	}
	{
		e.FieldStart("service_url")
		e.Str(s.ServiceURL)
	}
	{
		e.FieldStart("sip_status")
		e.Int(s.SipStatus)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
}

var jsonFieldsNameOfCall = [14]string{
	0:  "account_sid",
	1:  "application_sid",
	2:  "call_id",
	3:  "call_sid",
	4:  "call_status",
	5:  "caller_name",
	6:  "direction",
	7:  "duration",
	8:  "from",
	9:  "originating_sip_trunk_name",
	10: "parent_call_sid",
	11: "service_url",
	12: "sip_status",
	13: "to",
}

// Decode decodes Call from json.
func (s *Call) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Call to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "call_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CallID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_id\"")
			}
		case "call_sid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CallSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "call_status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.CallStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_status\"")
			}
		case "caller_name":
			if err := func() error {
				s.CallerName.Reset()
				if err := s.CallerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caller_name\"")
			}
		case "direction":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "from":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "originating_sip_trunk_name":
			if err := func() error {
				s.OriginatingSipTrunkName.Reset()
				if err := s.OriginatingSipTrunkName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originating_sip_trunk_name\"")
			}
		case "parent_call_sid":
			if err := func() error {
				s.ParentCallSid.Reset()
				if err := s.ParentCallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_call_sid\"")
			}
		case "service_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ServiceURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_url\"")
			}
		case "sip_status":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.SipStatus = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_status\"")
			}
		case "to":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Call")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011101,
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCall) {
					name = jsonFieldsNameOfCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Call) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Call) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallCallStatus as json.
func (s CallCallStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallCallStatus from json.
func (s *CallCallStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallCallStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallCallStatus(v) {
	case CallCallStatusTrying:
		*s = CallCallStatusTrying
	case CallCallStatusRinging:
		*s = CallCallStatusRinging
	case CallCallStatusAlerting:
		*s = CallCallStatusAlerting
	case CallCallStatusInProgress:
		*s = CallCallStatusInProgress
	case CallCallStatusCompleted:
		*s = CallCallStatusCompleted
	case CallCallStatusBusy:
		*s = CallCallStatusBusy
	case CallCallStatusNoAnswer:
		*s = CallCallStatusNoAnswer
	case CallCallStatusFailed:
		*s = CallCallStatusFailed
	case CallCallStatusQueued:
		*s = CallCallStatusQueued
	default:
		*s = CallCallStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallCallStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallCallStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallDirection as json.
func (s CallDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallDirection from json.
func (s *CallDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallDirection(v) {
	case CallDirectionInbound:
		*s = CallDirectionInbound
	case CallDirectionOutbound:
		*s = CallDirectionOutbound
	default:
		*s = CallDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChangePasswordBadRequest as json.
func (s *ChangePasswordBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ChangePasswordBadRequest from json.
func (s *ChangePasswordBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePasswordBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChangePasswordBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePasswordBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePasswordBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChangePasswordInternalServerError as json.
func (s *ChangePasswordInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ChangePasswordInternalServerError from json.
func (s *ChangePasswordInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePasswordInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChangePasswordInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePasswordInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePasswordInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChangePasswordReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChangePasswordReq) encodeFields(e *jx.Encoder) {
	{
		if s.OldPassword.Set {
			e.FieldStart("old_password")
			s.OldPassword.Encode(e)
		}
	}
	{
		if s.NewPassword.Set {
			e.FieldStart("new_password")
			s.NewPassword.Encode(e)
		}
	}
}

var jsonFieldsNameOfChangePasswordReq = [2]string{
	0: "old_password",
	1: "new_password",
}

// Decode decodes ChangePasswordReq from json.
func (s *ChangePasswordReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePasswordReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "old_password":
			if err := func() error {
				s.OldPassword.Reset()
				if err := s.OldPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_password\"")
			}
		case "new_password":
			if err := func() error {
				s.NewPassword.Reset()
				if err := s.NewPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChangePasswordReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePasswordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePasswordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckAvailabilityOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckAvailabilityOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("available")
		e.Bool(s.Available)
	}
}

var jsonFieldsNameOfCheckAvailabilityOK = [1]string{
	0: "available",
}

// Decode decodes CheckAvailabilityOK from json.
func (s *CheckAvailabilityOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckAvailabilityOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "available":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Available = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckAvailabilityOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckAvailabilityOK) {
					name = jsonFieldsNameOfCheckAvailabilityOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckAvailabilityOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckAvailabilityOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAccountBadRequest as json.
func (s *CreateAccountBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAccountBadRequest from json.
func (s *CreateAccountBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAccountBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAccountBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAccountBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAccountBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAccountInternalServerError as json.
func (s *CreateAccountInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAccountInternalServerError from json.
func (s *CreateAccountInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAccountInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAccountInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAccountInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAccountInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAccountReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAccountReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.SipRealm.Set {
			e.FieldStart("sip_realm")
			s.SipRealm.Encode(e)
		}
	}
	{
		if s.RegistrationHook.Set {
			e.FieldStart("registration_hook")
			s.RegistrationHook.Encode(e)
		}
	}
	{
		if s.QueueEventHook.Set {
			e.FieldStart("queue_event_hook")
			s.QueueEventHook.Encode(e)
		}
	}
	{
		e.FieldStart("service_provider_sid")
		json.EncodeUUID(e, s.ServiceProviderSid)
	}
}

var jsonFieldsNameOfCreateAccountReq = [5]string{
	0: "name",
	1: "sip_realm",
	2: "registration_hook",
	3: "queue_event_hook",
	4: "service_provider_sid",
}

// Decode decodes CreateAccountReq from json.
func (s *CreateAccountReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAccountReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sip_realm":
			if err := func() error {
				s.SipRealm.Reset()
				if err := s.SipRealm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_realm\"")
			}
		case "registration_hook":
			if err := func() error {
				s.RegistrationHook.Reset()
				if err := s.RegistrationHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registration_hook\"")
			}
		case "queue_event_hook":
			if err := func() error {
				s.QueueEventHook.Reset()
				if err := s.QueueEventHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_event_hook\"")
			}
		case "service_provider_sid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ServiceProviderSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAccountReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAccountReq) {
					name = jsonFieldsNameOfCreateAccountReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAccountReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAccountReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAccountUnprocessableEntity as json.
func (s *CreateAccountUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAccountUnprocessableEntity from json.
func (s *CreateAccountUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAccountUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAccountUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAccountUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAccountUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateApikeyBadRequest as json.
func (s *CreateApikeyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateApikeyBadRequest from json.
func (s *CreateApikeyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApikeyBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateApikeyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApikeyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApikeyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateApikeyInternalServerError as json.
func (s *CreateApikeyInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateApikeyInternalServerError from json.
func (s *CreateApikeyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApikeyInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateApikeyInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApikeyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApikeyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApikeyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApikeyReq) encodeFields(e *jx.Encoder) {
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.ExpirySecs.Set {
			e.FieldStart("expiry_secs")
			s.ExpirySecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateApikeyReq = [3]string{
	0: "service_provider_sid",
	1: "account_sid",
	2: "expiry_secs",
}

// Decode decodes CreateApikeyReq from json.
func (s *CreateApikeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApikeyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "expiry_secs":
			if err := func() error {
				s.ExpirySecs.Reset()
				if err := s.ExpirySecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApikeyReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApikeyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApikeyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateApplicationBadRequest as json.
func (s *CreateApplicationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateApplicationBadRequest from json.
func (s *CreateApplicationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApplicationBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateApplicationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApplicationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApplicationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateApplicationInternalServerError as json.
func (s *CreateApplicationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateApplicationInternalServerError from json.
func (s *CreateApplicationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApplicationInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateApplicationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApplicationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApplicationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApplicationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApplicationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("call_hook")
		s.CallHook.Encode(e)
	}
	{
		e.FieldStart("call_status_hook")
		s.CallStatusHook.Encode(e)
	}
	{
		e.FieldStart("record_all_calls")
		s.RecordAllCalls.Encode(e)
	}
	{
		e.FieldStart("messaging_hook")
		s.MessagingHook.Encode(e)
	}
}

var jsonFieldsNameOfCreateApplicationReq = [6]string{
	0: "name",
	1: "account_sid",
	2: "call_hook",
	3: "call_status_hook",
	4: "record_all_calls",
	5: "messaging_hook",
}

// Decode decodes CreateApplicationReq from json.
func (s *CreateApplicationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApplicationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_hook":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.CallHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_hook\"")
			}
		case "call_status_hook":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CallStatusHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_status_hook\"")
			}
		case "record_all_calls":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.RecordAllCalls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_all_calls\"")
			}
		case "messaging_hook":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.MessagingHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_hook\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApplicationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApplicationReq) {
					name = jsonFieldsNameOfCreateApplicationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApplicationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApplicationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateApplicationReqRecordAllCalls as json.
func (s CreateApplicationReqRecordAllCalls) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes CreateApplicationReqRecordAllCalls from json.
func (s *CreateApplicationReqRecordAllCalls) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApplicationReqRecordAllCalls to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = CreateApplicationReqRecordAllCalls(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateApplicationReqRecordAllCalls) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApplicationReqRecordAllCalls) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateApplicationUnprocessableEntity as json.
func (s *CreateApplicationUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateApplicationUnprocessableEntity from json.
func (s *CreateApplicationUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApplicationUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateApplicationUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApplicationUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApplicationUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCallCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCallCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sid")
		json.EncodeUUID(e, s.Sid)
	}
}

var jsonFieldsNameOfCreateCallCreated = [1]string{
	0: "sid",
}

// Decode decodes CreateCallCreated from json.
func (s *CreateCallCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.Sid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCallCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCallCreated) {
					name = jsonFieldsNameOfCreateCallCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCallCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCallReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCallReq) encodeFields(e *jx.Encoder) {
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		if s.AnswerOnBridge.Set {
			e.FieldStart("answerOnBridge")
			s.AnswerOnBridge.Encode(e)
		}
	}
	{
		if s.CallHook.Set {
			e.FieldStart("call_hook")
			s.CallHook.Encode(e)
		}
	}
	{
		if s.CallStatusHook.Set {
			e.FieldStart("call_status_hook")
			s.CallStatusHook.Encode(e)
		}
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		if s.FromHost.Set {
			e.FieldStart("fromHost")
			s.FromHost.Encode(e)
		}
	}
	{
		if s.Timeout.Set {
			e.FieldStart("timeout")
			s.Timeout.Encode(e)
		}
	}
	{
		if s.TimeLimit.Set {
			e.FieldStart("timeLimit")
			s.TimeLimit.Encode(e)
		}
	}
	{
		if s.Tag != nil {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		e.FieldStart("to")
		s.To.Encode(e)
	}
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.SipRequestWithinDialogHook.Set {
			e.FieldStart("sipRequestWithinDialogHook")
			s.SipRequestWithinDialogHook.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateCallReq = [12]string{
	0:  "application_sid",
	1:  "answerOnBridge",
	2:  "call_hook",
	3:  "call_status_hook",
	4:  "from",
	5:  "fromHost",
	6:  "timeout",
	7:  "timeLimit",
	8:  "tag",
	9:  "to",
	10: "headers",
	11: "sipRequestWithinDialogHook",
}

// Decode decodes CreateCallReq from json.
func (s *CreateCallReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "answerOnBridge":
			if err := func() error {
				s.AnswerOnBridge.Reset()
				if err := s.AnswerOnBridge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answerOnBridge\"")
			}
		case "call_hook":
			if err := func() error {
				s.CallHook.Reset()
				if err := s.CallHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_hook\"")
			}
		case "call_status_hook":
			if err := func() error {
				s.CallStatusHook.Reset()
				if err := s.CallStatusHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_status_hook\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "fromHost":
			if err := func() error {
				s.FromHost.Reset()
				if err := s.FromHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fromHost\"")
			}
		case "timeout":
			if err := func() error {
				s.Timeout.Reset()
				if err := s.Timeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		case "timeLimit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeLimit\"")
			}
		case "tag":
			if err := func() error {
				s.Tag = nil
				var elem CreateCallReqTag
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tag = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "to":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "headers":
			if err := func() error {
				s.Headers = nil
				var elem CreateCallReqHeaders
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Headers = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "sipRequestWithinDialogHook":
			if err := func() error {
				s.SipRequestWithinDialogHook.Reset()
				if err := s.SipRequestWithinDialogHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sipRequestWithinDialogHook\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCallReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010000,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCallReq) {
					name = jsonFieldsNameOfCreateCallReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCallReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCallReqHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCallReqHeaders) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateCallReqHeaders = [0]string{}

// Decode decodes CreateCallReqHeaders from json.
func (s *CreateCallReqHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallReqHeaders to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateCallReqHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCallReqHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallReqHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCallReqTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCallReqTag) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateCallReqTag = [0]string{}

// Decode decodes CreateCallReqTag from json.
func (s *CreateCallReqTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallReqTag to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateCallReqTag")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCallReqTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallReqTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateGoogleCustomVoiceBadRequest as json.
func (s *CreateGoogleCustomVoiceBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateGoogleCustomVoiceBadRequest from json.
func (s *CreateGoogleCustomVoiceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateGoogleCustomVoiceBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateGoogleCustomVoiceBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateGoogleCustomVoiceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateGoogleCustomVoiceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateGoogleCustomVoiceInternalServerError as json.
func (s *CreateGoogleCustomVoiceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateGoogleCustomVoiceInternalServerError from json.
func (s *CreateGoogleCustomVoiceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateGoogleCustomVoiceInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateGoogleCustomVoiceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateGoogleCustomVoiceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateGoogleCustomVoiceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateGoogleCustomVoiceUnprocessableEntity as json.
func (s *CreateGoogleCustomVoiceUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateGoogleCustomVoiceUnprocessableEntity from json.
func (s *CreateGoogleCustomVoiceUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateGoogleCustomVoiceUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateGoogleCustomVoiceUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateGoogleCustomVoiceUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateGoogleCustomVoiceUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrBadRequest as json.
func (s *CreateLcrBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrBadRequest from json.
func (s *CreateLcrBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrCarrierSetEntryBadRequest as json.
func (s *CreateLcrCarrierSetEntryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrCarrierSetEntryBadRequest from json.
func (s *CreateLcrCarrierSetEntryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrCarrierSetEntryBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrCarrierSetEntryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrCarrierSetEntryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrCarrierSetEntryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrCarrierSetEntryInternalServerError as json.
func (s *CreateLcrCarrierSetEntryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrCarrierSetEntryInternalServerError from json.
func (s *CreateLcrCarrierSetEntryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrCarrierSetEntryInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrCarrierSetEntryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrCarrierSetEntryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrCarrierSetEntryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrCarrierSetEntryUnprocessableEntity as json.
func (s *CreateLcrCarrierSetEntryUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrCarrierSetEntryUnprocessableEntity from json.
func (s *CreateLcrCarrierSetEntryUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrCarrierSetEntryUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrCarrierSetEntryUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrCarrierSetEntryUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrCarrierSetEntryUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateLcrForServiceProviderReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateLcrForServiceProviderReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateLcrForServiceProviderReq = [1]string{
	0: "name",
}

// Decode decodes CreateLcrForServiceProviderReq from json.
func (s *CreateLcrForServiceProviderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrForServiceProviderReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateLcrForServiceProviderReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateLcrForServiceProviderReq) {
					name = jsonFieldsNameOfCreateLcrForServiceProviderReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrForServiceProviderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrForServiceProviderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrInternalServerError as json.
func (s *CreateLcrInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrInternalServerError from json.
func (s *CreateLcrInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateLcrReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateLcrReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateLcrReq = [1]string{
	0: "name",
}

// Decode decodes CreateLcrReq from json.
func (s *CreateLcrReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateLcrReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateLcrReq) {
					name = jsonFieldsNameOfCreateLcrReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrRoutesBadRequest as json.
func (s *CreateLcrRoutesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrRoutesBadRequest from json.
func (s *CreateLcrRoutesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrRoutesBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrRoutesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrRoutesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrRoutesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrRoutesInternalServerError as json.
func (s *CreateLcrRoutesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrRoutesInternalServerError from json.
func (s *CreateLcrRoutesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrRoutesInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrRoutesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrRoutesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrRoutesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrRoutesUnprocessableEntity as json.
func (s *CreateLcrRoutesUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrRoutesUnprocessableEntity from json.
func (s *CreateLcrRoutesUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrRoutesUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrRoutesUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrRoutesUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrRoutesUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrUnprocessableEntity as json.
func (s *CreateLcrUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLcrUnprocessableEntity from json.
func (s *CreateLcrUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLcrUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLcrUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLcrUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLcrUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest as json.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest from json.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError as json.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError from json.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateMessageCode480) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateMessageCode480) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sid")
		json.EncodeUUID(e, s.Sid)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.SmppErrCode.Set {
			e.FieldStart("smpp_err_code")
			s.SmppErrCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateMessageCode480 = [3]string{
	0: "sid",
	1: "message",
	2: "smpp_err_code",
}

// Decode decodes CreateMessageCode480 from json.
func (s *CreateMessageCode480) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMessageCode480 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.Sid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "smpp_err_code":
			if err := func() error {
				s.SmppErrCode.Reset()
				if err := s.SmppErrCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smpp_err_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateMessageCode480")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateMessageCode480) {
					name = jsonFieldsNameOfCreateMessageCode480[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateMessageCode480) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMessageCode480) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateMessageCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateMessageCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sid")
		json.EncodeUUID(e, s.Sid)
	}
	{
		if s.ProviderResponse.Set {
			e.FieldStart("providerResponse")
			s.ProviderResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateMessageCreated = [2]string{
	0: "sid",
	1: "providerResponse",
}

// Decode decodes CreateMessageCreated from json.
func (s *CreateMessageCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMessageCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.Sid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "providerResponse":
			if err := func() error {
				s.ProviderResponse.Reset()
				if err := s.ProviderResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateMessageCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateMessageCreated) {
					name = jsonFieldsNameOfCreateMessageCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateMessageCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMessageCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateMsTeamsTenantBadRequest as json.
func (s *CreateMsTeamsTenantBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateMsTeamsTenantBadRequest from json.
func (s *CreateMsTeamsTenantBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMsTeamsTenantBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateMsTeamsTenantBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateMsTeamsTenantBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMsTeamsTenantBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateMsTeamsTenantInternalServerError as json.
func (s *CreateMsTeamsTenantInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateMsTeamsTenantInternalServerError from json.
func (s *CreateMsTeamsTenantInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMsTeamsTenantInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateMsTeamsTenantInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateMsTeamsTenantInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMsTeamsTenantInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateMsTeamsTenantReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateMsTeamsTenantReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("service_provider_sid")
		json.EncodeUUID(e, s.ServiceProviderSid)
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		e.FieldStart("tenant_fqdn")
		e.Str(s.TenantFqdn)
	}
}

var jsonFieldsNameOfCreateMsTeamsTenantReq = [4]string{
	0: "service_provider_sid",
	1: "account_sid",
	2: "application_sid",
	3: "tenant_fqdn",
}

// Decode decodes CreateMsTeamsTenantReq from json.
func (s *CreateMsTeamsTenantReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMsTeamsTenantReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service_provider_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ServiceProviderSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "tenant_fqdn":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TenantFqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant_fqdn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateMsTeamsTenantReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateMsTeamsTenantReq) {
					name = jsonFieldsNameOfCreateMsTeamsTenantReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateMsTeamsTenantReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMsTeamsTenantReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSbcBadRequest as json.
func (s *CreateSbcBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSbcBadRequest from json.
func (s *CreateSbcBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSbcBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSbcBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSbcBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSbcBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSbcInternalServerError as json.
func (s *CreateSbcInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSbcInternalServerError from json.
func (s *CreateSbcInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSbcInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSbcInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSbcInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSbcInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSbcReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSbcReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipv4")
		e.Str(s.Ipv4)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSbcReq = [3]string{
	0: "ipv4",
	1: "port",
	2: "service_provider_sid",
}

// Decode decodes CreateSbcReq from json.
func (s *CreateSbcReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSbcReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipv4":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ipv4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSbcReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSbcReq) {
					name = jsonFieldsNameOfCreateSbcReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSbcReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSbcReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateServiceProviderReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateServiceProviderReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.RootDomain.Set {
			e.FieldStart("root_domain")
			s.RootDomain.Encode(e)
		}
	}
	{
		if s.RegistrationHook.Set {
			e.FieldStart("registration_hook")
			s.RegistrationHook.Encode(e)
		}
	}
	{
		if s.MsTeamsFqdn.Set {
			e.FieldStart("ms_teams_fqdn")
			s.MsTeamsFqdn.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateServiceProviderReq = [5]string{
	0: "name",
	1: "description",
	2: "root_domain",
	3: "registration_hook",
	4: "ms_teams_fqdn",
}

// Decode decodes CreateServiceProviderReq from json.
func (s *CreateServiceProviderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateServiceProviderReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "root_domain":
			if err := func() error {
				s.RootDomain.Reset()
				if err := s.RootDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root_domain\"")
			}
		case "registration_hook":
			if err := func() error {
				s.RegistrationHook.Reset()
				if err := s.RegistrationHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registration_hook\"")
			}
		case "ms_teams_fqdn":
			if err := func() error {
				s.MsTeamsFqdn.Reset()
				if err := s.MsTeamsFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ms_teams_fqdn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateServiceProviderReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateServiceProviderReq) {
					name = jsonFieldsNameOfCreateServiceProviderReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateServiceProviderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateServiceProviderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSipGatewayBadRequest as json.
func (s *CreateSipGatewayBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSipGatewayBadRequest from json.
func (s *CreateSipGatewayBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSipGatewayBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSipGatewayBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSipGatewayBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSipGatewayBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSipGatewayInternalServerError as json.
func (s *CreateSipGatewayInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSipGatewayInternalServerError from json.
func (s *CreateSipGatewayInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSipGatewayInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSipGatewayInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSipGatewayInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSipGatewayInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSipGatewayReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSipGatewayReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("voip_carrier_sid")
		json.EncodeUUID(e, s.VoipCarrierSid)
	}
	{
		e.FieldStart("ipv4")
		e.Str(s.Ipv4)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSipGatewayReq = [6]string{
	0: "voip_carrier_sid",
	1: "ipv4",
	2: "port",
	3: "is_active",
	4: "inbound",
	5: "outbound",
}

// Decode decodes CreateSipGatewayReq from json.
func (s *CreateSipGatewayReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSipGatewayReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VoipCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		case "ipv4":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ipv4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSipGatewayReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSipGatewayReq) {
					name = jsonFieldsNameOfCreateSipGatewayReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSipGatewayReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSipGatewayReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSipGatewayUnprocessableEntity as json.
func (s *CreateSipGatewayUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSipGatewayUnprocessableEntity from json.
func (s *CreateSipGatewayUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSipGatewayUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSipGatewayUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSipGatewayUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSipGatewayUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSipRealmBadRequest as json.
func (s *CreateSipRealmBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSipRealmBadRequest from json.
func (s *CreateSipRealmBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSipRealmBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSipRealmBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSipRealmBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSipRealmBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSipRealmInternalServerError as json.
func (s *CreateSipRealmInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSipRealmInternalServerError from json.
func (s *CreateSipRealmInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSipRealmInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSipRealmInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSipRealmInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSipRealmInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSmppGatewayBadRequest as json.
func (s *CreateSmppGatewayBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSmppGatewayBadRequest from json.
func (s *CreateSmppGatewayBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSmppGatewayBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSmppGatewayBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSmppGatewayBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSmppGatewayBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSmppGatewayInternalServerError as json.
func (s *CreateSmppGatewayInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSmppGatewayInternalServerError from json.
func (s *CreateSmppGatewayInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSmppGatewayInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSmppGatewayInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSmppGatewayInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSmppGatewayInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSmppGatewayReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSmppGatewayReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("voip_carrier_sid")
		json.EncodeUUID(e, s.VoipCarrierSid)
	}
	{
		e.FieldStart("ipv4")
		e.Str(s.Ipv4)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Netmask.Set {
			e.FieldStart("netmask")
			s.Netmask.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
	{
		if s.IsPrimary.Set {
			e.FieldStart("is_primary")
			s.IsPrimary.Encode(e)
		}
	}
	{
		if s.UseTLS.Set {
			e.FieldStart("use_tls")
			s.UseTLS.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSmppGatewayReq = [8]string{
	0: "voip_carrier_sid",
	1: "ipv4",
	2: "port",
	3: "netmask",
	4: "inbound",
	5: "outbound",
	6: "is_primary",
	7: "use_tls",
}

// Decode decodes CreateSmppGatewayReq from json.
func (s *CreateSmppGatewayReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSmppGatewayReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VoipCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		case "ipv4":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ipv4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "netmask":
			if err := func() error {
				s.Netmask.Reset()
				if err := s.Netmask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"netmask\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		case "is_primary":
			if err := func() error {
				s.IsPrimary.Reset()
				if err := s.IsPrimary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_primary\"")
			}
		case "use_tls":
			if err := func() error {
				s.UseTLS.Reset()
				if err := s.UseTLS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_tls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSmppGatewayReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSmppGatewayReq) {
					name = jsonFieldsNameOfCreateSmppGatewayReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSmppGatewayReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSmppGatewayReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSmppGatewayUnprocessableEntity as json.
func (s *CreateSmppGatewayUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSmppGatewayUnprocessableEntity from json.
func (s *CreateSmppGatewayUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSmppGatewayUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSmppGatewayUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSmppGatewayUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSmppGatewayUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSpeechCredentialBadRequest as json.
func (s *CreateSpeechCredentialBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSpeechCredentialBadRequest from json.
func (s *CreateSpeechCredentialBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpeechCredentialBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSpeechCredentialBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpeechCredentialBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpeechCredentialBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSpeechCredentialInternalServerError as json.
func (s *CreateSpeechCredentialInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateSpeechCredentialInternalServerError from json.
func (s *CreateSpeechCredentialInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpeechCredentialInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateSpeechCredentialInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpeechCredentialInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpeechCredentialInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserForbidden as json.
func (s *CreateUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateUserForbidden from json.
func (s *CreateUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserForbidden to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserInternalServerError as json.
func (s *CreateUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateUserInternalServerError from json.
func (s *CreateUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
	{
		if s.ForceChange.Set {
			e.FieldStart("force_change")
			s.ForceChange.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Permissions != nil {
			e.FieldStart("permissions")
			e.ArrStart()
			for _, elem := range s.Permissions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OldPassword.Set {
			e.FieldStart("old_password")
			s.OldPassword.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserReq = [7]string{
	0: "name",
	1: "email",
	2: "is_active",
	3: "force_change",
	4: "scope",
	5: "permissions",
	6: "old_password",
}

// Decode decodes CreateUserReq from json.
func (s *CreateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "force_change":
			if err := func() error {
				s.ForceChange.Reset()
				if err := s.ForceChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_change\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "old_password":
			if err := func() error {
				s.OldPassword.Reset()
				if err := s.OldPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVoipCarrierBadRequest as json.
func (s *CreateVoipCarrierBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateVoipCarrierBadRequest from json.
func (s *CreateVoipCarrierBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVoipCarrierBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateVoipCarrierBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVoipCarrierBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVoipCarrierBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVoipCarrierInternalServerError as json.
func (s *CreateVoipCarrierInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateVoipCarrierInternalServerError from json.
func (s *CreateVoipCarrierInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVoipCarrierInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateVoipCarrierInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVoipCarrierInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVoipCarrierInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVoipCarrierReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVoipCarrierReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		if s.E164LeadingPlus.Set {
			e.FieldStart("e164_leading_plus")
			s.E164LeadingPlus.Encode(e)
		}
	}
	{
		if s.RequiresRegister.Set {
			e.FieldStart("requires_register")
			s.RequiresRegister.Encode(e)
		}
	}
	{
		if s.RegisterUseTLS.Set {
			e.FieldStart("register_use_tls")
			s.RegisterUseTLS.Encode(e)
		}
	}
	{
		if s.RegisterUsername.Set {
			e.FieldStart("register_username")
			s.RegisterUsername.Encode(e)
		}
	}
	{
		if s.RegisterSipRealm.Set {
			e.FieldStart("register_sip_realm")
			s.RegisterSipRealm.Encode(e)
		}
	}
	{
		if s.RegisterPassword.Set {
			e.FieldStart("register_password")
			s.RegisterPassword.Encode(e)
		}
	}
	{
		if s.RegisterFromUser.Set {
			e.FieldStart("register_from_user")
			s.RegisterFromUser.Encode(e)
		}
	}
	{
		if s.RegisterFromDomain.Set {
			e.FieldStart("register_from_domain")
			s.RegisterFromDomain.Encode(e)
		}
	}
	{
		if s.RegisterPublicIPInContact.Set {
			e.FieldStart("register_public_ip_in_contact")
			s.RegisterPublicIPInContact.Encode(e)
		}
	}
	{
		if s.TechPrefix.Set {
			e.FieldStart("tech_prefix")
			s.TechPrefix.Encode(e)
		}
	}
	{
		if s.InboundAuthUsername.Set {
			e.FieldStart("inbound_auth_username")
			s.InboundAuthUsername.Encode(e)
		}
	}
	{
		if s.InboundAuthPassword.Set {
			e.FieldStart("inbound_auth_password")
			s.InboundAuthPassword.Encode(e)
		}
	}
	{
		if s.Diversion.Set {
			e.FieldStart("diversion")
			s.Diversion.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVoipCarrierReq = [17]string{
	0:  "name",
	1:  "description",
	2:  "account_sid",
	3:  "application_sid",
	4:  "e164_leading_plus",
	5:  "requires_register",
	6:  "register_use_tls",
	7:  "register_username",
	8:  "register_sip_realm",
	9:  "register_password",
	10: "register_from_user",
	11: "register_from_domain",
	12: "register_public_ip_in_contact",
	13: "tech_prefix",
	14: "inbound_auth_username",
	15: "inbound_auth_password",
	16: "diversion",
}

// Decode decodes CreateVoipCarrierReq from json.
func (s *CreateVoipCarrierReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVoipCarrierReq to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "e164_leading_plus":
			if err := func() error {
				s.E164LeadingPlus.Reset()
				if err := s.E164LeadingPlus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"e164_leading_plus\"")
			}
		case "requires_register":
			if err := func() error {
				s.RequiresRegister.Reset()
				if err := s.RequiresRegister.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_register\"")
			}
		case "register_use_tls":
			if err := func() error {
				s.RegisterUseTLS.Reset()
				if err := s.RegisterUseTLS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_use_tls\"")
			}
		case "register_username":
			if err := func() error {
				s.RegisterUsername.Reset()
				if err := s.RegisterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_username\"")
			}
		case "register_sip_realm":
			if err := func() error {
				s.RegisterSipRealm.Reset()
				if err := s.RegisterSipRealm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_sip_realm\"")
			}
		case "register_password":
			if err := func() error {
				s.RegisterPassword.Reset()
				if err := s.RegisterPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_password\"")
			}
		case "register_from_user":
			if err := func() error {
				s.RegisterFromUser.Reset()
				if err := s.RegisterFromUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_from_user\"")
			}
		case "register_from_domain":
			if err := func() error {
				s.RegisterFromDomain.Reset()
				if err := s.RegisterFromDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_from_domain\"")
			}
		case "register_public_ip_in_contact":
			if err := func() error {
				s.RegisterPublicIPInContact.Reset()
				if err := s.RegisterPublicIPInContact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_public_ip_in_contact\"")
			}
		case "tech_prefix":
			if err := func() error {
				s.TechPrefix.Reset()
				if err := s.TechPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tech_prefix\"")
			}
		case "inbound_auth_username":
			if err := func() error {
				s.InboundAuthUsername.Reset()
				if err := s.InboundAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_auth_username\"")
			}
		case "inbound_auth_password":
			if err := func() error {
				s.InboundAuthPassword.Reset()
				if err := s.InboundAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_auth_password\"")
			}
		case "diversion":
			if err := func() error {
				s.Diversion.Reset()
				if err := s.Diversion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diversion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVoipCarrierReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVoipCarrierReq) {
					name = jsonFieldsNameOfCreateVoipCarrierReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVoipCarrierReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVoipCarrierReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVoipCarrierUnprocessableEntity as json.
func (s *CreateVoipCarrierUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateVoipCarrierUnprocessableEntity from json.
func (s *CreateVoipCarrierUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVoipCarrierUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateVoipCarrierUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVoipCarrierUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVoipCarrierUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAccountInternalServerError as json.
func (s *DeleteAccountInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteAccountInternalServerError from json.
func (s *DeleteAccountInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAccountInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteAccountInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAccountInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAccountInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAccountUnprocessableEntity as json.
func (s *DeleteAccountUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteAccountUnprocessableEntity from json.
func (s *DeleteAccountUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAccountUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteAccountUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAccountUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAccountUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteApplicationInternalServerError as json.
func (s *DeleteApplicationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteApplicationInternalServerError from json.
func (s *DeleteApplicationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteApplicationInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteApplicationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteApplicationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteApplicationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteApplicationUnprocessableEntity as json.
func (s *DeleteApplicationUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteApplicationUnprocessableEntity from json.
func (s *DeleteApplicationUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteApplicationUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteApplicationUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteApplicationUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteApplicationUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCallInternalServerError as json.
func (s *DeleteCallInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCallInternalServerError from json.
func (s *DeleteCallInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCallInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCallInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCallInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCallInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCallUnprocessableEntity as json.
func (s *DeleteCallUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCallUnprocessableEntity from json.
func (s *DeleteCallUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCallUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCallUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCallUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCallUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteGoogleCustomVoiceInternalServerError as json.
func (s *DeleteGoogleCustomVoiceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteGoogleCustomVoiceInternalServerError from json.
func (s *DeleteGoogleCustomVoiceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteGoogleCustomVoiceInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteGoogleCustomVoiceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteGoogleCustomVoiceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteGoogleCustomVoiceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteGoogleCustomVoiceUnprocessableEntity as json.
func (s *DeleteGoogleCustomVoiceUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteGoogleCustomVoiceUnprocessableEntity from json.
func (s *DeleteGoogleCustomVoiceUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteGoogleCustomVoiceUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteGoogleCustomVoiceUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteGoogleCustomVoiceUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteGoogleCustomVoiceUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteLeastCostRoutingCarrierSetEntryInternalServerError as json.
func (s *DeleteLeastCostRoutingCarrierSetEntryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteLeastCostRoutingCarrierSetEntryInternalServerError from json.
func (s *DeleteLeastCostRoutingCarrierSetEntryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteLeastCostRoutingCarrierSetEntryInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteLeastCostRoutingCarrierSetEntryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteLeastCostRoutingCarrierSetEntryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteLeastCostRoutingCarrierSetEntryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity as json.
func (s *DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity from json.
func (s *DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteLeastCostRoutingCarrierSetEntryUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteLeastCostRoutingInternalServerError as json.
func (s *DeleteLeastCostRoutingInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteLeastCostRoutingInternalServerError from json.
func (s *DeleteLeastCostRoutingInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteLeastCostRoutingInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteLeastCostRoutingInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteLeastCostRoutingInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteLeastCostRoutingInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteLeastCostRoutingRouteInternalServerError as json.
func (s *DeleteLeastCostRoutingRouteInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteLeastCostRoutingRouteInternalServerError from json.
func (s *DeleteLeastCostRoutingRouteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteLeastCostRoutingRouteInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteLeastCostRoutingRouteInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteLeastCostRoutingRouteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteLeastCostRoutingRouteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteLeastCostRoutingRouteUnprocessableEntity as json.
func (s *DeleteLeastCostRoutingRouteUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteLeastCostRoutingRouteUnprocessableEntity from json.
func (s *DeleteLeastCostRoutingRouteUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteLeastCostRoutingRouteUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteLeastCostRoutingRouteUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteLeastCostRoutingRouteUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteLeastCostRoutingRouteUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteLeastCostRoutingUnprocessableEntity as json.
func (s *DeleteLeastCostRoutingUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteLeastCostRoutingUnprocessableEntity from json.
func (s *DeleteLeastCostRoutingUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteLeastCostRoutingUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteLeastCostRoutingUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteLeastCostRoutingUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteLeastCostRoutingUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeletePhoneNumberInternalServerError as json.
func (s *DeletePhoneNumberInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeletePhoneNumberInternalServerError from json.
func (s *DeletePhoneNumberInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeletePhoneNumberInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeletePhoneNumberInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeletePhoneNumberInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeletePhoneNumberInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeletePhoneNumberUnprocessableEntity as json.
func (s *DeletePhoneNumberUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeletePhoneNumberUnprocessableEntity from json.
func (s *DeletePhoneNumberUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeletePhoneNumberUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeletePhoneNumberUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeletePhoneNumberUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeletePhoneNumberUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteServiceProviderInternalServerError as json.
func (s *DeleteServiceProviderInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteServiceProviderInternalServerError from json.
func (s *DeleteServiceProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteServiceProviderInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteServiceProviderInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteServiceProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteServiceProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteServiceProviderUnprocessableEntity as json.
func (s *DeleteServiceProviderUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteServiceProviderUnprocessableEntity from json.
func (s *DeleteServiceProviderUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteServiceProviderUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteServiceProviderUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteServiceProviderUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteServiceProviderUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVoipCarrierInternalServerError as json.
func (s *DeleteVoipCarrierInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVoipCarrierInternalServerError from json.
func (s *DeleteVoipCarrierInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVoipCarrierInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVoipCarrierInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVoipCarrierInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVoipCarrierInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVoipCarrierUnprocessableEntity as json.
func (s *DeleteVoipCarrierUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVoipCarrierUnprocessableEntity from json.
func (s *DeleteVoipCarrierUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVoipCarrierUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVoipCarrierUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVoipCarrierUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVoipCarrierUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForgotPasswordBadRequest as json.
func (s *ForgotPasswordBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ForgotPasswordBadRequest from json.
func (s *ForgotPasswordBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForgotPasswordBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ForgotPasswordBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForgotPasswordBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForgotPasswordBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForgotPasswordInternalServerError as json.
func (s *ForgotPasswordInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ForgotPasswordInternalServerError from json.
func (s *ForgotPasswordInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForgotPasswordInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ForgotPasswordInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForgotPasswordInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForgotPasswordInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForgotPasswordReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForgotPasswordReq) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
}

var jsonFieldsNameOfForgotPasswordReq = [1]string{
	0: "email",
}

// Decode decodes ForgotPasswordReq from json.
func (s *ForgotPasswordReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForgotPasswordReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForgotPasswordReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForgotPasswordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForgotPasswordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeneralError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeneralError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("msg")
		e.Str(s.Msg)
	}
}

var jsonFieldsNameOfGeneralError = [1]string{
	0: "msg",
}

// Decode decodes GeneralError from json.
func (s *GeneralError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneralError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "msg":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Msg = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GeneralError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGeneralError) {
					name = jsonFieldsNameOfGeneralError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneralError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneralError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateInviteCodeOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateInviteCodeOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("added")
		e.Float64(s.Added)
	}
}

var jsonFieldsNameOfGenerateInviteCodeOK = [2]string{
	0: "status",
	1: "added",
}

// Decode decodes GenerateInviteCodeOK from json.
func (s *GenerateInviteCodeOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateInviteCodeOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "added":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Added = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"added\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateInviteCodeOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateInviteCodeOK) {
					name = jsonFieldsNameOfGenerateInviteCodeOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateInviteCodeOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateInviteCodeOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateInviteCodeOKStatus as json.
func (s GenerateInviteCodeOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateInviteCodeOKStatus from json.
func (s *GenerateInviteCodeOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateInviteCodeOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateInviteCodeOKStatus(v) {
	case GenerateInviteCodeOKStatusOk:
		*s = GenerateInviteCodeOKStatusOk
	case GenerateInviteCodeOKStatusFailed:
		*s = GenerateInviteCodeOKStatusFailed
	default:
		*s = GenerateInviteCodeOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateInviteCodeOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateInviteCodeOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateInviteCodeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateInviteCodeReq) encodeFields(e *jx.Encoder) {
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateInviteCodeReq = [1]string{
	0: "count",
}

// Decode decodes GenerateInviteCodeReq from json.
func (s *GenerateInviteCodeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateInviteCodeReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateInviteCodeReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateInviteCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateInviteCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAccountApiKeysOKApplicationJSON as json.
func (s GetAccountApiKeysOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ApiKey(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetAccountApiKeysOKApplicationJSON from json.
func (s *GetAccountApiKeysOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAccountApiKeysOKApplicationJSON to nil")
	}
	var unwrapped []ApiKey
	if err := func() error {
		unwrapped = make([]ApiKey, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ApiKey
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAccountApiKeysOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAccountApiKeysOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAccountApiKeysOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAccountLimitsOKApplicationJSON as json.
func (s GetAccountLimitsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Limits(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetAccountLimitsOKApplicationJSON from json.
func (s *GetAccountLimitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAccountLimitsOKApplicationJSON to nil")
	}
	var unwrapped []Limits
	if err := func() error {
		unwrapped = make([]Limits, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Limits
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAccountLimitsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAccountLimitsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAccountLimitsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRecentCallTraceByCallIdOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRecentCallTraceByCallIdOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRecentCallTraceByCallIdOK = [0]string{}

// Decode decodes GetRecentCallTraceByCallIdOK from json.
func (s *GetRecentCallTraceByCallIdOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRecentCallTraceByCallIdOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRecentCallTraceByCallIdOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRecentCallTraceByCallIdOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRecentCallTraceByCallIdOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRecentCallTraceOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRecentCallTraceOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRecentCallTraceOK = [0]string{}

// Decode decodes GetRecentCallTraceOK from json.
func (s *GetRecentCallTraceOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRecentCallTraceOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRecentCallTraceOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRecentCallTraceOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRecentCallTraceOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceProviderAccountsOKApplicationJSON as json.
func (s GetServiceProviderAccountsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Account(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetServiceProviderAccountsOKApplicationJSON from json.
func (s *GetServiceProviderAccountsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceProviderAccountsOKApplicationJSON to nil")
	}
	var unwrapped []Account
	if err := func() error {
		unwrapped = make([]Account, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Account
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceProviderAccountsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetServiceProviderAccountsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceProviderAccountsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceProviderCarriersOKApplicationJSON as json.
func (s GetServiceProviderCarriersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []VoipCarrier(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetServiceProviderCarriersOKApplicationJSON from json.
func (s *GetServiceProviderCarriersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceProviderCarriersOKApplicationJSON to nil")
	}
	var unwrapped []VoipCarrier
	if err := func() error {
		unwrapped = make([]VoipCarrier, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VoipCarrier
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceProviderCarriersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetServiceProviderCarriersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceProviderCarriersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceProviderLcrsOKApplicationJSON as json.
func (s GetServiceProviderLcrsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Lcr(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetServiceProviderLcrsOKApplicationJSON from json.
func (s *GetServiceProviderLcrsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceProviderLcrsOKApplicationJSON to nil")
	}
	var unwrapped []Lcr
	if err := func() error {
		unwrapped = make([]Lcr, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Lcr
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceProviderLcrsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetServiceProviderLcrsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceProviderLcrsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceProviderLimitsOKApplicationJSON as json.
func (s GetServiceProviderLimitsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Limits(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetServiceProviderLimitsOKApplicationJSON from json.
func (s *GetServiceProviderLimitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceProviderLimitsOKApplicationJSON to nil")
	}
	var unwrapped []Limits
	if err := func() error {
		unwrapped = make([]Limits, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Limits
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceProviderLimitsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetServiceProviderLimitsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceProviderLimitsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStripeCustomerIdOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStripeCustomerIdOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stripe_customer_id")
		e.Str(s.StripeCustomerID)
	}
}

var jsonFieldsNameOfGetStripeCustomerIdOK = [1]string{
	0: "stripe_customer_id",
}

// Decode decodes GetStripeCustomerIdOK from json.
func (s *GetStripeCustomerIdOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStripeCustomerIdOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stripe_customer_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.StripeCustomerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stripe_customer_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStripeCustomerIdOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStripeCustomerIdOK) {
					name = jsonFieldsNameOfGetStripeCustomerIdOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStripeCustomerIdOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStripeCustomerIdOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetSubscriptionOK = [0]string{}

// Decode decodes GetSubscriptionOK from json.
func (s *GetSubscriptionOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTestDataOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTestDataOK) encodeFields(e *jx.Encoder) {
	{
		if s.Phonenumbers != nil {
			e.FieldStart("phonenumbers")
			e.ArrStart()
			for _, elem := range s.Phonenumbers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Applications != nil {
			e.FieldStart("applications")
			e.ArrStart()
			for _, elem := range s.Applications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetTestDataOK = [2]string{
	0: "phonenumbers",
	1: "applications",
}

// Decode decodes GetTestDataOK from json.
func (s *GetTestDataOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTestDataOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phonenumbers":
			if err := func() error {
				s.Phonenumbers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Phonenumbers = append(s.Phonenumbers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phonenumbers\"")
			}
		case "applications":
			if err := func() error {
				s.Applications = make([]Application, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Application
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Applications = append(s.Applications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTestDataOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTestDataOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTestDataOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserForbidden as json.
func (s *GetUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserForbidden from json.
func (s *GetUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserForbidden to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserInternalServerError as json.
func (s *GetUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserInternalServerError from json.
func (s *GetUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetWebhookSecretOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetWebhookSecretOK) encodeFields(e *jx.Encoder) {
	{
		if s.WebhookSecret.Set {
			e.FieldStart("webhook_secret")
			s.WebhookSecret.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetWebhookSecretOK = [1]string{
	0: "webhook_secret",
}

// Decode decodes GetWebhookSecretOK from json.
func (s *GetWebhookSecretOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWebhookSecretOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "webhook_secret":
			if err := func() error {
				s.WebhookSecret.Reset()
				if err := s.WebhookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetWebhookSecretOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWebhookSecretOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWebhookSecretOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoogleCustomVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoogleCustomVoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("speech_credential_sid")
		e.Str(s.SpeechCredentialSid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("reported_usage")
		e.Str(s.ReportedUsage)
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
}

var jsonFieldsNameOfGoogleCustomVoice = [4]string{
	0: "speech_credential_sid",
	1: "name",
	2: "reported_usage",
	3: "model",
}

// Decode decodes GoogleCustomVoice from json.
func (s *GoogleCustomVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoogleCustomVoice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "speech_credential_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SpeechCredentialSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_credential_sid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "reported_usage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ReportedUsage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_usage\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoogleCustomVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoogleCustomVoice) {
					name = jsonFieldsNameOfGoogleCustomVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoogleCustomVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoogleCustomVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LanguageVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LanguageVoice) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfLanguageVoice = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes LanguageVoice from json.
func (s *LanguageVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LanguageVoice to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LanguageVoice")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LanguageVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LanguageVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LanguageVoices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LanguageVoices) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Voices != nil {
			e.FieldStart("voices")
			e.ArrStart()
			for _, elem := range s.Voices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfLanguageVoices = [3]string{
	0: "name",
	1: "value",
	2: "voices",
}

// Decode decodes LanguageVoices from json.
func (s *LanguageVoices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LanguageVoices to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "voices":
			if err := func() error {
				s.Voices = make([]LanguageVoice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LanguageVoice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Voices = append(s.Voices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LanguageVoices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LanguageVoices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LanguageVoices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Lcr) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Lcr) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.DefaultCarrierSetEntrySid.Set {
			e.FieldStart("default_carrier_set_entry_sid")
			s.DefaultCarrierSetEntrySid.Encode(e)
		}
	}
}

var jsonFieldsNameOfLcr = [2]string{
	0: "name",
	1: "default_carrier_set_entry_sid",
}

// Decode decodes Lcr from json.
func (s *Lcr) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Lcr to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "default_carrier_set_entry_sid":
			if err := func() error {
				s.DefaultCarrierSetEntrySid.Reset()
				if err := s.DefaultCarrierSetEntrySid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_carrier_set_entry_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Lcr")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLcr) {
					name = jsonFieldsNameOfLcr[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Lcr) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Lcr) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LcrCarrierSetEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LcrCarrierSetEntry) encodeFields(e *jx.Encoder) {
	{
		if s.Workload.Set {
			e.FieldStart("workload")
			s.Workload.Encode(e)
		}
	}
	{
		e.FieldStart("lcr_route_sid")
		e.Str(s.LcrRouteSid)
	}
	{
		e.FieldStart("voip_carrier_sid")
		e.Str(s.VoipCarrierSid)
	}
	{
		e.FieldStart("priority")
		e.Float64(s.Priority)
	}
}

var jsonFieldsNameOfLcrCarrierSetEntry = [4]string{
	0: "workload",
	1: "lcr_route_sid",
	2: "voip_carrier_sid",
	3: "priority",
}

// Decode decodes LcrCarrierSetEntry from json.
func (s *LcrCarrierSetEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LcrCarrierSetEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workload":
			if err := func() error {
				s.Workload.Reset()
				if err := s.Workload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workload\"")
			}
		case "lcr_route_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LcrRouteSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lcr_route_sid\"")
			}
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VoipCarrierSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Priority = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LcrCarrierSetEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLcrCarrierSetEntry) {
					name = jsonFieldsNameOfLcrCarrierSetEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LcrCarrierSetEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LcrCarrierSetEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LcrRoute) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LcrRoute) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lcr_sid")
		e.Str(s.LcrSid)
	}
	{
		e.FieldStart("regex")
		e.Str(s.Regex)
	}
	{
		e.FieldStart("priority")
		e.Float64(s.Priority)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfLcrRoute = [4]string{
	0: "lcr_sid",
	1: "regex",
	2: "priority",
	3: "description",
}

// Decode decodes LcrRoute from json.
func (s *LcrRoute) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LcrRoute to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lcr_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LcrSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lcr_sid\"")
			}
		case "regex":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Regex = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regex\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Priority = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LcrRoute")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLcrRoute) {
					name = jsonFieldsNameOfLcrRoute[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LcrRoute) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LcrRoute) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LcrRouteAndCarrierEntries) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LcrRouteAndCarrierEntries) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lcr_sid")
		e.Str(s.LcrSid)
	}
	{
		e.FieldStart("regex")
		e.Str(s.Regex)
	}
	{
		e.FieldStart("priority")
		e.Float64(s.Priority)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.LcrCarrierSetEntries != nil {
			e.FieldStart("lcr_carrier_set_entries")
			e.ArrStart()
			for _, elem := range s.LcrCarrierSetEntries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfLcrRouteAndCarrierEntries = [5]string{
	0: "lcr_sid",
	1: "regex",
	2: "priority",
	3: "description",
	4: "lcr_carrier_set_entries",
}

// Decode decodes LcrRouteAndCarrierEntries from json.
func (s *LcrRouteAndCarrierEntries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LcrRouteAndCarrierEntries to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lcr_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LcrSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lcr_sid\"")
			}
		case "regex":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Regex = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regex\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Priority = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "lcr_carrier_set_entries":
			if err := func() error {
				s.LcrCarrierSetEntries = make([]LcrCarrierSetEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LcrCarrierSetEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LcrCarrierSetEntries = append(s.LcrCarrierSetEntries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lcr_carrier_set_entries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LcrRouteAndCarrierEntries")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLcrRouteAndCarrierEntries) {
					name = jsonFieldsNameOfLcrRouteAndCarrierEntries[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LcrRouteAndCarrierEntries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LcrRouteAndCarrierEntries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LcrRoutes as json.
func (s LcrRoutes) Encode(e *jx.Encoder) {
	unwrapped := []LcrRouteAndCarrierEntries(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes LcrRoutes from json.
func (s *LcrRoutes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LcrRoutes to nil")
	}
	var unwrapped []LcrRouteAndCarrierEntries
	if err := func() error {
		unwrapped = make([]LcrRouteAndCarrierEntries, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LcrRouteAndCarrierEntries
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LcrRoutes(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LcrRoutes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LcrRoutes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Limits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Limits) encodeFields(e *jx.Encoder) {
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
}

var jsonFieldsNameOfLimits = [1]string{
	0: "category",
}

// Decode decodes Limits from json.
func (s *Limits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Limits to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Limits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Limits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Limits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LimitsCategory as json.
func (s LimitsCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LimitsCategory from json.
func (s *LimitsCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LimitsCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LimitsCategory(v) {
	case LimitsCategoryVoiceCallSession:
		*s = LimitsCategoryVoiceCallSession
	case LimitsCategoryAPILimit:
		*s = LimitsCategoryAPILimit
	case LimitsCategoryDevices:
		*s = LimitsCategoryDevices
	default:
		*s = LimitsCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LimitsCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LimitsCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListAccountsOKApplicationJSON as json.
func (s ListAccountsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Account(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListAccountsOKApplicationJSON from json.
func (s *ListAccountsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAccountsOKApplicationJSON to nil")
	}
	var unwrapped []Account
	if err := func() error {
		unwrapped = make([]Account, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Account
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListAccountsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListAccountsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAccountsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAlertsByAccountOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAlertsByAccountOK) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Batch.Set {
			e.FieldStart("batch")
			s.Batch.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListAlertsByAccountOK = [4]string{
	0: "total",
	1: "batch",
	2: "page",
	3: "data",
}

// Decode decodes ListAlertsByAccountOK from json.
func (s *ListAlertsByAccountOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAlertsByAccountOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "batch":
			if err := func() error {
				s.Batch.Reset()
				if err := s.Batch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]ListAlertsByAccountOKDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ListAlertsByAccountOKDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAlertsByAccountOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAlertsByAccountOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAlertsByAccountOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAlertsByAccountOKDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAlertsByAccountOKDataItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("alert_type")
		e.Str(s.AlertType)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
}

var jsonFieldsNameOfListAlertsByAccountOKDataItem = [5]string{
	0: "time",
	1: "account_sid",
	2: "alert_type",
	3: "message",
	4: "detail",
}

// Decode decodes ListAlertsByAccountOKDataItem from json.
func (s *ListAlertsByAccountOKDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAlertsByAccountOKDataItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "account_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "alert_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AlertType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_type\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAlertsByAccountOKDataItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListAlertsByAccountOKDataItem) {
					name = jsonFieldsNameOfListAlertsByAccountOKDataItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAlertsByAccountOKDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAlertsByAccountOKDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAlertsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAlertsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Batch.Set {
			e.FieldStart("batch")
			s.Batch.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListAlertsOK = [4]string{
	0: "total",
	1: "batch",
	2: "page",
	3: "data",
}

// Decode decodes ListAlertsOK from json.
func (s *ListAlertsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAlertsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "batch":
			if err := func() error {
				s.Batch.Reset()
				if err := s.Batch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]ListAlertsOKDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ListAlertsOKDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAlertsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAlertsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAlertsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAlertsOKDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAlertsOKDataItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("alert_type")
		e.Str(s.AlertType)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
}

var jsonFieldsNameOfListAlertsOKDataItem = [6]string{
	0: "time",
	1: "service_provider_sid",
	2: "account_sid",
	3: "alert_type",
	4: "message",
	5: "detail",
}

// Decode decodes ListAlertsOKDataItem from json.
func (s *ListAlertsOKDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAlertsOKDataItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "account_sid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "alert_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AlertType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_type\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAlertsOKDataItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListAlertsOKDataItem) {
					name = jsonFieldsNameOfListAlertsOKDataItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAlertsOKDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAlertsOKDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListApplicationsOKApplicationJSON as json.
func (s ListApplicationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Application(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListApplicationsOKApplicationJSON from json.
func (s *ListApplicationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListApplicationsOKApplicationJSON to nil")
	}
	var unwrapped []Application
	if err := func() error {
		unwrapped = make([]Application, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Application
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListApplicationsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListApplicationsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListApplicationsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCallsOKApplicationJSON as json.
func (s ListCallsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Call(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListCallsOKApplicationJSON from json.
func (s *ListCallsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCallsOKApplicationJSON to nil")
	}
	var unwrapped []Call
	if err := func() error {
		unwrapped = make([]Call, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Call
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCallsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListCallsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCallsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListConferencesOKApplicationJSON as json.
func (s ListConferencesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes ListConferencesOKApplicationJSON from json.
func (s *ListConferencesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListConferencesOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListConferencesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListConferencesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListConferencesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListGoogleCustomVoicesOKApplicationJSON as json.
func (s ListGoogleCustomVoicesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GoogleCustomVoice(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListGoogleCustomVoicesOKApplicationJSON from json.
func (s *ListGoogleCustomVoicesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListGoogleCustomVoicesOKApplicationJSON to nil")
	}
	var unwrapped []GoogleCustomVoice
	if err := func() error {
		unwrapped = make([]GoogleCustomVoice, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GoogleCustomVoice
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListGoogleCustomVoicesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListGoogleCustomVoicesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListGoogleCustomVoicesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON as json.
func (s ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LcrCarrierSetEntry(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON from json.
func (s *ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON to nil")
	}
	var unwrapped []LcrCarrierSetEntry
	if err := func() error {
		unwrapped = make([]LcrCarrierSetEntry, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LcrCarrierSetEntry
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListLeastCostRoutingCarrierSetEntriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListLeastCostRoutingRoutesOKApplicationJSON as json.
func (s ListLeastCostRoutingRoutesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LcrRoute(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListLeastCostRoutingRoutesOKApplicationJSON from json.
func (s *ListLeastCostRoutingRoutesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListLeastCostRoutingRoutesOKApplicationJSON to nil")
	}
	var unwrapped []LcrRoute
	if err := func() error {
		unwrapped = make([]LcrRoute, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LcrRoute
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListLeastCostRoutingRoutesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListLeastCostRoutingRoutesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListLeastCostRoutingRoutesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListLeastCostRoutingsOKApplicationJSON as json.
func (s ListLeastCostRoutingsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Lcr(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListLeastCostRoutingsOKApplicationJSON from json.
func (s *ListLeastCostRoutingsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListLeastCostRoutingsOKApplicationJSON to nil")
	}
	var unwrapped []Lcr
	if err := func() error {
		unwrapped = make([]Lcr, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Lcr
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListLeastCostRoutingsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListLeastCostRoutingsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListLeastCostRoutingsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListMsTeamsTenantsOKApplicationJSON as json.
func (s ListMsTeamsTenantsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MsTeamsTenant(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListMsTeamsTenantsOKApplicationJSON from json.
func (s *ListMsTeamsTenantsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListMsTeamsTenantsOKApplicationJSON to nil")
	}
	var unwrapped []MsTeamsTenant
	if err := func() error {
		unwrapped = make([]MsTeamsTenant, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MsTeamsTenant
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListMsTeamsTenantsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListMsTeamsTenantsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListMsTeamsTenantsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListProvisionedPhoneNumbersOKApplicationJSON as json.
func (s ListProvisionedPhoneNumbersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PhoneNumber(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListProvisionedPhoneNumbersOKApplicationJSON from json.
func (s *ListProvisionedPhoneNumbersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListProvisionedPhoneNumbersOKApplicationJSON to nil")
	}
	var unwrapped []PhoneNumber
	if err := func() error {
		unwrapped = make([]PhoneNumber, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PhoneNumber
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListProvisionedPhoneNumbersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListProvisionedPhoneNumbersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListProvisionedPhoneNumbersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListQueuesOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListQueuesOKItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Length.Set {
			e.FieldStart("length")
			s.Length.Encode(e)
		}
	}
}

var jsonFieldsNameOfListQueuesOKItem = [2]string{
	0: "name",
	1: "length",
}

// Decode decodes ListQueuesOKItem from json.
func (s *ListQueuesOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListQueuesOKItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "length":
			if err := func() error {
				s.Length.Reset()
				if err := s.Length.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"length\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListQueuesOKItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListQueuesOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListQueuesOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListRecentCallsBySPOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListRecentCallsBySPOK) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Batch.Set {
			e.FieldStart("batch")
			s.Batch.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListRecentCallsBySPOK = [4]string{
	0: "total",
	1: "batch",
	2: "page",
	3: "data",
}

// Decode decodes ListRecentCallsBySPOK from json.
func (s *ListRecentCallsBySPOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRecentCallsBySPOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "batch":
			if err := func() error {
				s.Batch.Reset()
				if err := s.Batch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]ListRecentCallsBySPOKDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ListRecentCallsBySPOKDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListRecentCallsBySPOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListRecentCallsBySPOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRecentCallsBySPOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListRecentCallsBySPOKDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListRecentCallsBySPOKDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("call_sid")
		json.EncodeUUID(e, s.CallSid)
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		e.FieldStart("answered")
		e.Bool(s.Answered)
	}
	{
		if s.SipCallID.Set {
			e.FieldStart("sip_call_id")
			s.SipCallID.Encode(e)
		}
	}
	{
		e.FieldStart("sip_status")
		e.Float64(s.SipStatus)
	}
	{
		e.FieldStart("duration")
		e.Float64(s.Duration)
	}
	{
		e.FieldStart("attempted_at")
		e.Float64(s.AttemptedAt)
	}
	{
		if s.AnsweredAt.Set {
			e.FieldStart("answered_at")
			s.AnsweredAt.Encode(e)
		}
	}
	{
		e.FieldStart("terminated_at")
		e.Float64(s.TerminatedAt)
	}
	{
		if s.TerminationReason.Set {
			e.FieldStart("termination_reason")
			s.TerminationReason.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.RemoteHost.Set {
			e.FieldStart("remote_host")
			s.RemoteHost.Encode(e)
		}
	}
	{
		e.FieldStart("direction")
		s.Direction.Encode(e)
	}
	{
		if s.Trunk.Set {
			e.FieldStart("trunk")
			s.Trunk.Encode(e)
		}
	}
}

var jsonFieldsNameOfListRecentCallsBySPOKDataItem = [17]string{
	0:  "service_provider_sid",
	1:  "account_sid",
	2:  "call_sid",
	3:  "from",
	4:  "to",
	5:  "answered",
	6:  "sip_call_id",
	7:  "sip_status",
	8:  "duration",
	9:  "attempted_at",
	10: "answered_at",
	11: "terminated_at",
	12: "termination_reason",
	13: "host",
	14: "remote_host",
	15: "direction",
	16: "trunk",
}

// Decode decodes ListRecentCallsBySPOKDataItem from json.
func (s *ListRecentCallsBySPOKDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRecentCallsBySPOKDataItem to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "account_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CallSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "answered":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Answered = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answered\"")
			}
		case "sip_call_id":
			if err := func() error {
				s.SipCallID.Reset()
				if err := s.SipCallID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_call_id\"")
			}
		case "sip_status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.SipStatus = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_status\"")
			}
		case "duration":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Duration = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "attempted_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.AttemptedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attempted_at\"")
			}
		case "answered_at":
			if err := func() error {
				s.AnsweredAt.Reset()
				if err := s.AnsweredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answered_at\"")
			}
		case "terminated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TerminatedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminated_at\"")
			}
		case "termination_reason":
			if err := func() error {
				s.TerminationReason.Reset()
				if err := s.TerminationReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination_reason\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "remote_host":
			if err := func() error {
				s.RemoteHost.Reset()
				if err := s.RemoteHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_host\"")
			}
		case "direction":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "trunk":
			if err := func() error {
				s.Trunk.Reset()
				if err := s.Trunk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trunk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListRecentCallsBySPOKDataItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b10111110,
		0b10001011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListRecentCallsBySPOKDataItem) {
					name = jsonFieldsNameOfListRecentCallsBySPOKDataItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListRecentCallsBySPOKDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRecentCallsBySPOKDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListRecentCallsBySPOKDataItemDirection as json.
func (s ListRecentCallsBySPOKDataItemDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListRecentCallsBySPOKDataItemDirection from json.
func (s *ListRecentCallsBySPOKDataItemDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRecentCallsBySPOKDataItemDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListRecentCallsBySPOKDataItemDirection(v) {
	case ListRecentCallsBySPOKDataItemDirectionInbound:
		*s = ListRecentCallsBySPOKDataItemDirectionInbound
	case ListRecentCallsBySPOKDataItemDirectionOutbound:
		*s = ListRecentCallsBySPOKDataItemDirectionOutbound
	default:
		*s = ListRecentCallsBySPOKDataItemDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListRecentCallsBySPOKDataItemDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRecentCallsBySPOKDataItemDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListRecentCallsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListRecentCallsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Batch.Set {
			e.FieldStart("batch")
			s.Batch.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListRecentCallsOK = [4]string{
	0: "total",
	1: "batch",
	2: "page",
	3: "data",
}

// Decode decodes ListRecentCallsOK from json.
func (s *ListRecentCallsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRecentCallsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "batch":
			if err := func() error {
				s.Batch.Reset()
				if err := s.Batch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]ListRecentCallsOKDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ListRecentCallsOKDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListRecentCallsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListRecentCallsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRecentCallsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListRecentCallsOKDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListRecentCallsOKDataItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("call_sid")
		json.EncodeUUID(e, s.CallSid)
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		e.FieldStart("answered")
		e.Bool(s.Answered)
	}
	{
		if s.SipCallID.Set {
			e.FieldStart("sip_call_id")
			s.SipCallID.Encode(e)
		}
	}
	{
		e.FieldStart("sip_status")
		e.Float64(s.SipStatus)
	}
	{
		e.FieldStart("duration")
		e.Float64(s.Duration)
	}
	{
		e.FieldStart("attempted_at")
		e.Float64(s.AttemptedAt)
	}
	{
		if s.AnsweredAt.Set {
			e.FieldStart("answered_at")
			s.AnsweredAt.Encode(e)
		}
	}
	{
		e.FieldStart("terminated_at")
		e.Float64(s.TerminatedAt)
	}
	{
		if s.TerminationReason.Set {
			e.FieldStart("termination_reason")
			s.TerminationReason.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.RemoteHost.Set {
			e.FieldStart("remote_host")
			s.RemoteHost.Encode(e)
		}
	}
	{
		e.FieldStart("direction")
		s.Direction.Encode(e)
	}
	{
		if s.Trunk.Set {
			e.FieldStart("trunk")
			s.Trunk.Encode(e)
		}
	}
}

var jsonFieldsNameOfListRecentCallsOKDataItem = [16]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "from",
	3:  "to",
	4:  "answered",
	5:  "sip_call_id",
	6:  "sip_status",
	7:  "duration",
	8:  "attempted_at",
	9:  "answered_at",
	10: "terminated_at",
	11: "termination_reason",
	12: "host",
	13: "remote_host",
	14: "direction",
	15: "trunk",
}

// Decode decodes ListRecentCallsOKDataItem from json.
func (s *ListRecentCallsOKDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRecentCallsOKDataItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CallSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "answered":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Answered = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answered\"")
			}
		case "sip_call_id":
			if err := func() error {
				s.SipCallID.Reset()
				if err := s.SipCallID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_call_id\"")
			}
		case "sip_status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.SipStatus = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_status\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Duration = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "attempted_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AttemptedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attempted_at\"")
			}
		case "answered_at":
			if err := func() error {
				s.AnsweredAt.Reset()
				if err := s.AnsweredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answered_at\"")
			}
		case "terminated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TerminatedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminated_at\"")
			}
		case "termination_reason":
			if err := func() error {
				s.TerminationReason.Reset()
				if err := s.TerminationReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination_reason\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "remote_host":
			if err := func() error {
				s.RemoteHost.Reset()
				if err := s.RemoteHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_host\"")
			}
		case "direction":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "trunk":
			if err := func() error {
				s.Trunk.Reset()
				if err := s.Trunk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trunk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListRecentCallsOKDataItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11011111,
		0b01000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListRecentCallsOKDataItem) {
					name = jsonFieldsNameOfListRecentCallsOKDataItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListRecentCallsOKDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRecentCallsOKDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListRecentCallsOKDataItemDirection as json.
func (s ListRecentCallsOKDataItemDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListRecentCallsOKDataItemDirection from json.
func (s *ListRecentCallsOKDataItemDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRecentCallsOKDataItemDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListRecentCallsOKDataItemDirection(v) {
	case ListRecentCallsOKDataItemDirectionInbound:
		*s = ListRecentCallsOKDataItemDirectionInbound
	case ListRecentCallsOKDataItemDirectionOutbound:
		*s = ListRecentCallsOKDataItemDirectionOutbound
	default:
		*s = ListRecentCallsOKDataItemDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListRecentCallsOKDataItemDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRecentCallsOKDataItemDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListSbcsOKApplicationJSON as json.
func (s ListSbcsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ListSbcsOKItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListSbcsOKApplicationJSON from json.
func (s *ListSbcsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSbcsOKApplicationJSON to nil")
	}
	var unwrapped []ListSbcsOKItem
	if err := func() error {
		unwrapped = make([]ListSbcsOKItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ListSbcsOKItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListSbcsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListSbcsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSbcsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListSbcsOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListSbcsOKItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipv4")
		e.Str(s.Ipv4)
	}
}

var jsonFieldsNameOfListSbcsOKItem = [1]string{
	0: "ipv4",
}

// Decode decodes ListSbcsOKItem from json.
func (s *ListSbcsOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSbcsOKItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipv4":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ipv4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListSbcsOKItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListSbcsOKItem) {
					name = jsonFieldsNameOfListSbcsOKItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListSbcsOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSbcsOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListServiceProvidersOKApplicationJSON as json.
func (s ListServiceProvidersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ServiceProvider(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListServiceProvidersOKApplicationJSON from json.
func (s *ListServiceProvidersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListServiceProvidersOKApplicationJSON to nil")
	}
	var unwrapped []ServiceProvider
	if err := func() error {
		unwrapped = make([]ServiceProvider, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ServiceProvider
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListServiceProvidersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListServiceProvidersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListServiceProvidersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListSipGatewaysOKApplicationJSON as json.
func (s ListSipGatewaysOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SipGateway(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListSipGatewaysOKApplicationJSON from json.
func (s *ListSipGatewaysOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSipGatewaysOKApplicationJSON to nil")
	}
	var unwrapped []SipGateway
	if err := func() error {
		unwrapped = make([]SipGateway, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SipGateway
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListSipGatewaysOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListSipGatewaysOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSipGatewaysOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListSmppGatewaysOKApplicationJSON as json.
func (s ListSmppGatewaysOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SmppGateway(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListSmppGatewaysOKApplicationJSON from json.
func (s *ListSmppGatewaysOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSmppGatewaysOKApplicationJSON to nil")
	}
	var unwrapped []SmppGateway
	if err := func() error {
		unwrapped = make([]SmppGateway, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SmppGateway
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListSmppGatewaysOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListSmppGatewaysOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSmppGatewaysOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListSmppsOKApplicationJSON as json.
func (s ListSmppsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ListSmppsOKItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListSmppsOKApplicationJSON from json.
func (s *ListSmppsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSmppsOKApplicationJSON to nil")
	}
	var unwrapped []ListSmppsOKItem
	if err := func() error {
		unwrapped = make([]ListSmppsOKItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ListSmppsOKItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListSmppsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListSmppsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSmppsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListSmppsOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListSmppsOKItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipv4")
		e.Str(s.Ipv4)
	}
	{
		e.FieldStart("port")
		e.Float64(s.Port)
	}
	{
		e.FieldStart("use_tls")
		e.Bool(s.UseTLS)
	}
	{
		e.FieldStart("is_primary")
		e.Bool(s.IsPrimary)
	}
}

var jsonFieldsNameOfListSmppsOKItem = [4]string{
	0: "ipv4",
	1: "port",
	2: "use_tls",
	3: "is_primary",
}

// Decode decodes ListSmppsOKItem from json.
func (s *ListSmppsOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSmppsOKItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipv4":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ipv4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Port = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "use_tls":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.UseTLS = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_tls\"")
			}
		case "is_primary":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsPrimary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListSmppsOKItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListSmppsOKItem) {
					name = jsonFieldsNameOfListSmppsOKItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListSmppsOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSmppsOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListSpeechCredentialsOKApplicationJSON as json.
func (s ListSpeechCredentialsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SpeechCredential(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListSpeechCredentialsOKApplicationJSON from json.
func (s *ListSpeechCredentialsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSpeechCredentialsOKApplicationJSON to nil")
	}
	var unwrapped []SpeechCredential
	if err := func() error {
		unwrapped = make([]SpeechCredential, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SpeechCredential
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListSpeechCredentialsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListSpeechCredentialsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSpeechCredentialsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUsersOKApplicationJSON as json.
func (s ListUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListUsersOKApplicationJSON from json.
func (s *ListUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUsersOKApplicationJSON to nil")
	}
	var unwrapped []UserList
	if err := func() error {
		unwrapped = make([]UserList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUsersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListUsersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUsersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListVoipCarriersOKApplicationJSON as json.
func (s ListVoipCarriersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []VoipCarrier(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListVoipCarriersOKApplicationJSON from json.
func (s *ListVoipCarriersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVoipCarriersOKApplicationJSON to nil")
	}
	var unwrapped []VoipCarrier
	if err := func() error {
		unwrapped = make([]VoipCarrier, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VoipCarrier
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListVoipCarriersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListVoipCarriersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListVoipCarriersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Login) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Login) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfLogin = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes Login from json.
func (s *Login) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Login to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Login")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLogin) {
					name = jsonFieldsNameOfLogin[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Login) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Login) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginUserReq) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfLoginUserReq = [2]string{
	0: "email",
	1: "password",
}

// Decode decodes LoginUserReq from json.
func (s *LoginUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginUserReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginUserReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ManageSubscriptionCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ManageSubscriptionCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("customer_id")
		e.Str(s.CustomerID)
	}
	{
		if s.ClientSecret.Set {
			e.FieldStart("client_secret")
			s.ClientSecret.Encode(e)
		}
	}
}

var jsonFieldsNameOfManageSubscriptionCreated = [3]string{
	0: "status",
	1: "customer_id",
	2: "client_secret",
}

// Decode decodes ManageSubscriptionCreated from json.
func (s *ManageSubscriptionCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManageSubscriptionCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "customer_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CustomerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customer_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ManageSubscriptionCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfManageSubscriptionCreated) {
					name = jsonFieldsNameOfManageSubscriptionCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ManageSubscriptionCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManageSubscriptionCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ManageSubscriptionCreatedStatus as json.
func (s ManageSubscriptionCreatedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ManageSubscriptionCreatedStatus from json.
func (s *ManageSubscriptionCreatedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManageSubscriptionCreatedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ManageSubscriptionCreatedStatus(v) {
	case ManageSubscriptionCreatedStatusSuccess:
		*s = ManageSubscriptionCreatedStatusSuccess
	case ManageSubscriptionCreatedStatusCardError:
		*s = ManageSubscriptionCreatedStatusCardError
	case ManageSubscriptionCreatedStatusActionRequired:
		*s = ManageSubscriptionCreatedStatusActionRequired
	default:
		*s = ManageSubscriptionCreatedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ManageSubscriptionCreatedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManageSubscriptionCreatedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ManageSubscriptionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ManageSubscriptionReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		if s.PaymentMethodID.Set {
			e.FieldStart("payment_method_id")
			s.PaymentMethodID.Encode(e)
		}
	}
	{
		if s.DryRun.Set {
			e.FieldStart("dry_run")
			s.DryRun.Encode(e)
		}
	}
	{
		if s.Products != nil {
			e.FieldStart("products")
			e.ArrStart()
			for _, elem := range s.Products {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfManageSubscriptionReq = [4]string{
	0: "action",
	1: "payment_method_id",
	2: "dry_run",
	3: "products",
}

// Decode decodes ManageSubscriptionReq from json.
func (s *ManageSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManageSubscriptionReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "payment_method_id":
			if err := func() error {
				s.PaymentMethodID.Reset()
				if err := s.PaymentMethodID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_method_id\"")
			}
		case "dry_run":
			if err := func() error {
				s.DryRun.Reset()
				if err := s.DryRun.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dry_run\"")
			}
		case "products":
			if err := func() error {
				s.Products = make([]ManageSubscriptionReqProductsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ManageSubscriptionReqProductsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Products = append(s.Products, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"products\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ManageSubscriptionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfManageSubscriptionReq) {
					name = jsonFieldsNameOfManageSubscriptionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ManageSubscriptionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManageSubscriptionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ManageSubscriptionReqAction as json.
func (s ManageSubscriptionReqAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ManageSubscriptionReqAction from json.
func (s *ManageSubscriptionReqAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManageSubscriptionReqAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ManageSubscriptionReqAction(v) {
	case ManageSubscriptionReqActionUpgradeToPaid:
		*s = ManageSubscriptionReqActionUpgradeToPaid
	case ManageSubscriptionReqActionDowngradeToFree:
		*s = ManageSubscriptionReqActionDowngradeToFree
	case ManageSubscriptionReqActionUpdatePaymentMethod:
		*s = ManageSubscriptionReqActionUpdatePaymentMethod
	case ManageSubscriptionReqActionUpdateQuantities:
		*s = ManageSubscriptionReqActionUpdateQuantities
	default:
		*s = ManageSubscriptionReqAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ManageSubscriptionReqAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManageSubscriptionReqAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ManageSubscriptionReqProductsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ManageSubscriptionReqProductsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ProductSid.Set {
			e.FieldStart("product_sid")
			s.ProductSid.Encode(e)
		}
	}
	{
		if s.PriceID.Set {
			e.FieldStart("price_id")
			s.PriceID.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfManageSubscriptionReqProductsItem = [3]string{
	0: "product_sid",
	1: "price_id",
	2: "quantity",
}

// Decode decodes ManageSubscriptionReqProductsItem from json.
func (s *ManageSubscriptionReqProductsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManageSubscriptionReqProductsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "product_sid":
			if err := func() error {
				s.ProductSid.Reset()
				if err := s.ProductSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_sid\"")
			}
		case "price_id":
			if err := func() error {
				s.PriceID.Reset()
				if err := s.PriceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_id\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ManageSubscriptionReqProductsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ManageSubscriptionReqProductsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManageSubscriptionReqProductsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Message) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Message) encodeFields(e *jx.Encoder) {
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Media.Set {
			e.FieldStart("media")
			s.Media.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessage = [5]string{
	0: "provider",
	1: "from",
	2: "to",
	3: "text",
	4: "media",
}

// Decode decodes Message from json.
func (s *Message) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Message to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "media":
			if err := func() error {
				s.Media.Reset()
				if err := s.Media.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Message")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessage) {
					name = jsonFieldsNameOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Message) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Message) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MsTeamsTenant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MsTeamsTenant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("service_provider_sid")
		json.EncodeUUID(e, s.ServiceProviderSid)
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		e.FieldStart("tenant_fqdn")
		e.Str(s.TenantFqdn)
	}
}

var jsonFieldsNameOfMsTeamsTenant = [4]string{
	0: "service_provider_sid",
	1: "account_sid",
	2: "application_sid",
	3: "tenant_fqdn",
}

// Decode decodes MsTeamsTenant from json.
func (s *MsTeamsTenant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MsTeamsTenant to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service_provider_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ServiceProviderSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "tenant_fqdn":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TenantFqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant_fqdn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MsTeamsTenant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMsTeamsTenant) {
					name = jsonFieldsNameOfMsTeamsTenant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MsTeamsTenant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MsTeamsTenant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o NilUUID) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *NilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Account as json.
func (o OptAccount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Account from json.
func (o *OptAccount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChangePasswordReq as json.
func (o OptChangePasswordReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChangePasswordReq from json.
func (o *OptChangePasswordReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChangePasswordReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChangePasswordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChangePasswordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAccountReq as json.
func (o OptCreateAccountReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateAccountReq from json.
func (o *OptCreateAccountReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateAccountReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateAccountReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateAccountReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateApikeyReq as json.
func (o OptCreateApikeyReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateApikeyReq from json.
func (o *OptCreateApikeyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateApikeyReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateApikeyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateApikeyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCallReq as json.
func (o OptCreateCallReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateCallReq from json.
func (o *OptCreateCallReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateCallReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateCallReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateCallReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrForServiceProviderReq as json.
func (o OptCreateLcrForServiceProviderReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateLcrForServiceProviderReq from json.
func (o *OptCreateLcrForServiceProviderReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateLcrForServiceProviderReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateLcrForServiceProviderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateLcrForServiceProviderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateLcrReq as json.
func (o OptCreateLcrReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateLcrReq from json.
func (o *OptCreateLcrReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateLcrReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateLcrReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateLcrReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateMsTeamsTenantReq as json.
func (o OptCreateMsTeamsTenantReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateMsTeamsTenantReq from json.
func (o *OptCreateMsTeamsTenantReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateMsTeamsTenantReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateMsTeamsTenantReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateMsTeamsTenantReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSbcReq as json.
func (o OptCreateSbcReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateSbcReq from json.
func (o *OptCreateSbcReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateSbcReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateSbcReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateSbcReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateServiceProviderReq as json.
func (o OptCreateServiceProviderReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateServiceProviderReq from json.
func (o *OptCreateServiceProviderReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateServiceProviderReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateServiceProviderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateServiceProviderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSipGatewayReq as json.
func (o OptCreateSipGatewayReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateSipGatewayReq from json.
func (o *OptCreateSipGatewayReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateSipGatewayReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateSipGatewayReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateSipGatewayReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSmppGatewayReq as json.
func (o OptCreateSmppGatewayReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateSmppGatewayReq from json.
func (o *OptCreateSmppGatewayReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateSmppGatewayReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateSmppGatewayReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateSmppGatewayReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReq as json.
func (o OptCreateUserReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateUserReq from json.
func (o *OptCreateUserReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVoipCarrierReq as json.
func (o OptCreateVoipCarrierReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateVoipCarrierReq from json.
func (o *OptCreateVoipCarrierReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateVoipCarrierReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateVoipCarrierReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateVoipCarrierReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForgotPasswordReq as json.
func (o OptForgotPasswordReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ForgotPasswordReq from json.
func (o *OptForgotPasswordReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForgotPasswordReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptForgotPasswordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptForgotPasswordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateInviteCodeReq as json.
func (o OptGenerateInviteCodeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GenerateInviteCodeReq from json.
func (o *OptGenerateInviteCodeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateInviteCodeReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateInviteCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateInviteCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoogleCustomVoice as json.
func (o OptGoogleCustomVoice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GoogleCustomVoice from json.
func (o *OptGoogleCustomVoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGoogleCustomVoice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGoogleCustomVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGoogleCustomVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Lcr as json.
func (o OptLcr) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Lcr from json.
func (o *OptLcr) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLcr to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLcr) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLcr) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LcrCarrierSetEntry as json.
func (o OptLcrCarrierSetEntry) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LcrCarrierSetEntry from json.
func (o *OptLcrCarrierSetEntry) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLcrCarrierSetEntry to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLcrCarrierSetEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLcrCarrierSetEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LcrRoute as json.
func (o OptLcrRoute) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LcrRoute from json.
func (o *OptLcrRoute) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLcrRoute to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLcrRoute) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLcrRoute) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Limits as json.
func (o OptLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Limits from json.
func (o *OptLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLimits to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LimitsCategory as json.
func (o OptLimitsCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LimitsCategory from json.
func (o *OptLimitsCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLimitsCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLimitsCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLimitsCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Login as json.
func (o OptLogin) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Login from json.
func (o *OptLogin) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogin to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLogin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLogin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoginUserReq as json.
func (o OptLoginUserReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LoginUserReq from json.
func (o *OptLoginUserReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoginUserReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoginUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoginUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ManageSubscriptionReq as json.
func (o OptManageSubscriptionReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ManageSubscriptionReq from json.
func (o *OptManageSubscriptionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptManageSubscriptionReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptManageSubscriptionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptManageSubscriptionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Message as json.
func (o OptMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Message from json.
func (o *OptMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MsTeamsTenant as json.
func (o OptMsTeamsTenant) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MsTeamsTenant from json.
func (o *OptMsTeamsTenant) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMsTeamsTenant to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMsTeamsTenant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMsTeamsTenant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountRegistrationHook as json.
func (o OptNilAccountRegistrationHook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccountRegistrationHook from json.
func (o *OptNilAccountRegistrationHook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAccountRegistrationHook to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AccountRegistrationHook
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAccountRegistrationHook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAccountRegistrationHook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptNilUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptNilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterUserReq as json.
func (o OptRegisterUserReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RegisterUserReq from json.
func (o *OptRegisterUserReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegisterUserReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegisterUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegisterUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisteredClientRegisteredStatus as json.
func (o OptRegisteredClientRegisteredStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RegisteredClientRegisteredStatus from json.
func (o *OptRegisteredClientRegisteredStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegisteredClientRegisteredStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegisteredClientRegisteredStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegisteredClientRegisteredStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendActivationCodeReq as json.
func (o OptSendActivationCodeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendActivationCodeReq from json.
func (o *OptSendActivationCodeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendActivationCodeReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendActivationCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendActivationCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendActivationCodeReqType as json.
func (o OptSendActivationCodeReqType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SendActivationCodeReqType from json.
func (o *OptSendActivationCodeReqType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendActivationCodeReqType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendActivationCodeReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendActivationCodeReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceProvider as json.
func (o OptServiceProvider) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ServiceProvider from json.
func (o *OptServiceProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceProvider to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SipGateway as json.
func (o OptSipGateway) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SipGateway from json.
func (o *OptSipGateway) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSipGateway to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSipGateway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSipGateway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SmppGateway as json.
func (o OptSmppGateway) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SmppGateway from json.
func (o *OptSmppGateway) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSmppGateway to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSmppGateway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSmppGateway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechCredential as json.
func (o OptSpeechCredential) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpeechCredential from json.
func (o *OptSpeechCredential) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeechCredential to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeechCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeechCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechCredentialUpdate as json.
func (o OptSpeechCredentialUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpeechCredentialUpdate from json.
func (o *OptSpeechCredentialUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeechCredentialUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeechCredentialUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeechCredentialUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechCredentialVendor as json.
func (o OptSpeechCredentialVendor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeechCredentialVendor from json.
func (o *OptSpeechCredentialVendor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeechCredentialVendor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeechCredentialVendor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeechCredentialVendor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynthesizeReq as json.
func (o OptSynthesizeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SynthesizeReq from json.
func (o *OptSynthesizeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSynthesizeReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSynthesizeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSynthesizeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TargetAuth as json.
func (o OptTargetAuth) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TargetAuth from json.
func (o *OptTargetAuth) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTargetAuth to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTargetAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTargetAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialByAccountOKStt as json.
func (o OptTestSpeechCredentialByAccountOKStt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestSpeechCredentialByAccountOKStt from json.
func (o *OptTestSpeechCredentialByAccountOKStt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialByAccountOKStt to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialByAccountOKStt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialByAccountOKStt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialByAccountOKSttStatus as json.
func (o OptTestSpeechCredentialByAccountOKSttStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestSpeechCredentialByAccountOKSttStatus from json.
func (o *OptTestSpeechCredentialByAccountOKSttStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialByAccountOKSttStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialByAccountOKSttStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialByAccountOKSttStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialByAccountOKTts as json.
func (o OptTestSpeechCredentialByAccountOKTts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestSpeechCredentialByAccountOKTts from json.
func (o *OptTestSpeechCredentialByAccountOKTts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialByAccountOKTts to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialByAccountOKTts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialByAccountOKTts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialByAccountOKTtsStatus as json.
func (o OptTestSpeechCredentialByAccountOKTtsStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestSpeechCredentialByAccountOKTtsStatus from json.
func (o *OptTestSpeechCredentialByAccountOKTtsStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialByAccountOKTtsStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialByAccountOKTtsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialByAccountOKTtsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialOKStt as json.
func (o OptTestSpeechCredentialOKStt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestSpeechCredentialOKStt from json.
func (o *OptTestSpeechCredentialOKStt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialOKStt to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialOKStt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialOKStt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialOKSttStatus as json.
func (o OptTestSpeechCredentialOKSttStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestSpeechCredentialOKSttStatus from json.
func (o *OptTestSpeechCredentialOKSttStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialOKSttStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialOKSttStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialOKSttStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialOKTts as json.
func (o OptTestSpeechCredentialOKTts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestSpeechCredentialOKTts from json.
func (o *OptTestSpeechCredentialOKTts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialOKTts to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialOKTts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialOKTts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialOKTtsStatus as json.
func (o OptTestSpeechCredentialOKTtsStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestSpeechCredentialOKTtsStatus from json.
func (o *OptTestSpeechCredentialOKTtsStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestSpeechCredentialOKTtsStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestSpeechCredentialOKTtsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestSpeechCredentialOKTtsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReq as json.
func (o OptUpdateCallReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateCallReq from json.
func (o *OptUpdateCallReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqCallStatus as json.
func (o OptUpdateCallReqCallStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallReqCallStatus from json.
func (o *OptUpdateCallReqCallStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqCallStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqCallStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqCallStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqConfHoldStatus as json.
func (o OptUpdateCallReqConfHoldStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallReqConfHoldStatus from json.
func (o *OptUpdateCallReqConfHoldStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqConfHoldStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqConfHoldStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqConfHoldStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqConfMuteStatus as json.
func (o OptUpdateCallReqConfMuteStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallReqConfMuteStatus from json.
func (o *OptUpdateCallReqConfMuteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqConfMuteStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqConfMuteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqConfMuteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqConferenceParticipantAction as json.
func (o OptUpdateCallReqConferenceParticipantAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateCallReqConferenceParticipantAction from json.
func (o *OptUpdateCallReqConferenceParticipantAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqConferenceParticipantAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqConferenceParticipantAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqConferenceParticipantAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqConferenceParticipantActionAction as json.
func (o OptUpdateCallReqConferenceParticipantActionAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallReqConferenceParticipantActionAction from json.
func (o *OptUpdateCallReqConferenceParticipantActionAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqConferenceParticipantActionAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqConferenceParticipantActionAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqConferenceParticipantActionAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqListenStatus as json.
func (o OptUpdateCallReqListenStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallReqListenStatus from json.
func (o *OptUpdateCallReqListenStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqListenStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqListenStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqListenStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqMuteStatus as json.
func (o OptUpdateCallReqMuteStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallReqMuteStatus from json.
func (o *OptUpdateCallReqMuteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqMuteStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqMuteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqMuteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqRecord as json.
func (o OptUpdateCallReqRecord) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateCallReqRecord from json.
func (o *OptUpdateCallReqRecord) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqRecord to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqRecordAction as json.
func (o OptUpdateCallReqRecordAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallReqRecordAction from json.
func (o *OptUpdateCallReqRecordAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqRecordAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqRecordAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqRecordAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqSipRequest as json.
func (o OptUpdateCallReqSipRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateCallReqSipRequest from json.
func (o *OptUpdateCallReqSipRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallReqSipRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallReqSipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallReqSipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReq as json.
func (o OptUpdateUserReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateUserReq from json.
func (o *OptUpdateUserReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAndAccountDetailAccount as json.
func (o OptUserAndAccountDetailAccount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserAndAccountDetailAccount from json.
func (o *OptUserAndAccountDetailAccount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAndAccountDetailAccount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAndAccountDetailAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAndAccountDetailAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAndAccountDetailBalance as json.
func (o OptUserAndAccountDetailBalance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserAndAccountDetailBalance from json.
func (o *OptUserAndAccountDetailBalance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAndAccountDetailBalance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAndAccountDetailBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAndAccountDetailBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAndAccountDetailBalanceCurrency as json.
func (o OptUserAndAccountDetailBalanceCurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserAndAccountDetailBalanceCurrency from json.
func (o *OptUserAndAccountDetailBalanceCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAndAccountDetailBalanceCurrency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAndAccountDetailBalanceCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAndAccountDetailBalanceCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAndAccountDetailCapacities as json.
func (o OptUserAndAccountDetailCapacities) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserAndAccountDetailCapacities from json.
func (o *OptUserAndAccountDetailCapacities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAndAccountDetailCapacities to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAndAccountDetailCapacities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAndAccountDetailCapacities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAndAccountDetailTestapp as json.
func (o OptUserAndAccountDetailTestapp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserAndAccountDetailTestapp from json.
func (o *OptUserAndAccountDetailTestapp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAndAccountDetailTestapp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAndAccountDetailTestapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAndAccountDetailTestapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAndAccountDetailUser as json.
func (o OptUserAndAccountDetailUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserAndAccountDetailUser from json.
func (o *OptUserAndAccountDetailUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAndAccountDetailUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAndAccountDetailUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAndAccountDetailUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateActivationCodeReq as json.
func (o OptValidateActivationCodeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidateActivationCodeReq from json.
func (o *OptValidateActivationCodeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidateActivationCodeReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidateActivationCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidateActivationCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateActivationCodeReqType as json.
func (o OptValidateActivationCodeReqType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ValidateActivationCodeReqType from json.
func (o *OptValidateActivationCodeReqType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidateActivationCodeReqType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidateActivationCodeReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidateActivationCodeReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateInviteCodeReq as json.
func (o OptValidateInviteCodeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidateInviteCodeReq from json.
func (o *OptValidateInviteCodeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidateInviteCodeReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidateInviteCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidateInviteCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoipCarrier as json.
func (o OptVoipCarrier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoipCarrier from json.
func (o *OptVoipCarrier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoipCarrier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoipCarrier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoipCarrier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Webhook as json.
func (o OptWebhook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Webhook from json.
func (o *OptWebhook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhook to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PhoneNumber) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PhoneNumber) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number_sid")
		json.EncodeUUID(e, s.PhoneNumberSid)
	}
	{
		e.FieldStart("number")
		e.Str(s.Number)
	}
	{
		e.FieldStart("voip_carrier_sid")
		json.EncodeUUID(e, s.VoipCarrierSid)
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
}

var jsonFieldsNameOfPhoneNumber = [5]string{
	0: "phone_number_sid",
	1: "number",
	2: "voip_carrier_sid",
	3: "account_sid",
	4: "application_sid",
}

// Decode decodes PhoneNumber from json.
func (s *PhoneNumber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhoneNumber to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PhoneNumberSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_sid\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Number = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VoipCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PhoneNumber")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPhoneNumber) {
					name = jsonFieldsNameOfPhoneNumber[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PhoneNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhoneNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PredefinedCarrier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PredefinedCarrier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("predefined_carrier_sid")
		json.EncodeUUID(e, s.PredefinedCarrierSid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("requires_static_ip")
		e.Bool(s.RequiresStaticIP)
	}
	{
		e.FieldStart("e164_leading_plus")
		e.Bool(s.E164LeadingPlus)
	}
	{
		e.FieldStart("requires_register")
		e.Bool(s.RequiresRegister)
	}
	{
		if s.RegisterUsername.Set {
			e.FieldStart("register_username")
			s.RegisterUsername.Encode(e)
		}
	}
	{
		if s.RegisterSipRealm.Set {
			e.FieldStart("register_sip_realm")
			s.RegisterSipRealm.Encode(e)
		}
	}
	{
		if s.RegisterPassword.Set {
			e.FieldStart("register_password")
			s.RegisterPassword.Encode(e)
		}
	}
	{
		if s.RegisterFromUser.Set {
			e.FieldStart("register_from_user")
			s.RegisterFromUser.Encode(e)
		}
	}
	{
		if s.RegisterFromDomain.Set {
			e.FieldStart("register_from_domain")
			s.RegisterFromDomain.Encode(e)
		}
	}
	{
		if s.RegisterPublicIPInContact.Set {
			e.FieldStart("register_public_ip_in_contact")
			s.RegisterPublicIPInContact.Encode(e)
		}
	}
	{
		if s.TechPrefix.Set {
			e.FieldStart("tech_prefix")
			s.TechPrefix.Encode(e)
		}
	}
	{
		if s.InboundAuthUsername.Set {
			e.FieldStart("inbound_auth_username")
			s.InboundAuthUsername.Encode(e)
		}
	}
	{
		if s.InboundAuthPassword.Set {
			e.FieldStart("inbound_auth_password")
			s.InboundAuthPassword.Encode(e)
		}
	}
	{
		if s.Diversion.Set {
			e.FieldStart("diversion")
			s.Diversion.Encode(e)
		}
	}
}

var jsonFieldsNameOfPredefinedCarrier = [15]string{
	0:  "predefined_carrier_sid",
	1:  "name",
	2:  "requires_static_ip",
	3:  "e164_leading_plus",
	4:  "requires_register",
	5:  "register_username",
	6:  "register_sip_realm",
	7:  "register_password",
	8:  "register_from_user",
	9:  "register_from_domain",
	10: "register_public_ip_in_contact",
	11: "tech_prefix",
	12: "inbound_auth_username",
	13: "inbound_auth_password",
	14: "diversion",
}

// Decode decodes PredefinedCarrier from json.
func (s *PredefinedCarrier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PredefinedCarrier to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "predefined_carrier_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PredefinedCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"predefined_carrier_sid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "requires_static_ip":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.RequiresStaticIP = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_static_ip\"")
			}
		case "e164_leading_plus":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.E164LeadingPlus = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"e164_leading_plus\"")
			}
		case "requires_register":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.RequiresRegister = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_register\"")
			}
		case "register_username":
			if err := func() error {
				s.RegisterUsername.Reset()
				if err := s.RegisterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_username\"")
			}
		case "register_sip_realm":
			if err := func() error {
				s.RegisterSipRealm.Reset()
				if err := s.RegisterSipRealm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_sip_realm\"")
			}
		case "register_password":
			if err := func() error {
				s.RegisterPassword.Reset()
				if err := s.RegisterPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_password\"")
			}
		case "register_from_user":
			if err := func() error {
				s.RegisterFromUser.Reset()
				if err := s.RegisterFromUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_from_user\"")
			}
		case "register_from_domain":
			if err := func() error {
				s.RegisterFromDomain.Reset()
				if err := s.RegisterFromDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_from_domain\"")
			}
		case "register_public_ip_in_contact":
			if err := func() error {
				s.RegisterPublicIPInContact.Reset()
				if err := s.RegisterPublicIPInContact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_public_ip_in_contact\"")
			}
		case "tech_prefix":
			if err := func() error {
				s.TechPrefix.Reset()
				if err := s.TechPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tech_prefix\"")
			}
		case "inbound_auth_username":
			if err := func() error {
				s.InboundAuthUsername.Reset()
				if err := s.InboundAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_auth_username\"")
			}
		case "inbound_auth_password":
			if err := func() error {
				s.InboundAuthPassword.Reset()
				if err := s.InboundAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_auth_password\"")
			}
		case "diversion":
			if err := func() error {
				s.Diversion.Reset()
				if err := s.Diversion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diversion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PredefinedCarrier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPredefinedCarrier) {
					name = jsonFieldsNameOfPredefinedCarrier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PredefinedCarrier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PredefinedCarrier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Product) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Product) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("product_sid")
		e.Str(s.ProductSid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("unit_label")
		e.Str(s.UnitLabel)
	}
	{
		e.FieldStart("category")
		e.Str(s.Category)
	}
}

var jsonFieldsNameOfProduct = [5]string{
	0: "product_sid",
	1: "name",
	2: "description",
	3: "unit_label",
	4: "category",
}

// Decode decodes Product from json.
func (s *Product) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Product to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "product_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProductSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_sid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "unit_label":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UnitLabel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_label\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Product")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProduct) {
					name = jsonFieldsNameOfProduct[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Product) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Product) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProvisionPhoneNumberBadRequest as json.
func (s *ProvisionPhoneNumberBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProvisionPhoneNumberBadRequest from json.
func (s *ProvisionPhoneNumberBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProvisionPhoneNumberBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProvisionPhoneNumberBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProvisionPhoneNumberBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProvisionPhoneNumberBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProvisionPhoneNumberInternalServerError as json.
func (s *ProvisionPhoneNumberInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProvisionPhoneNumberInternalServerError from json.
func (s *ProvisionPhoneNumberInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProvisionPhoneNumberInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProvisionPhoneNumberInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProvisionPhoneNumberInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProvisionPhoneNumberInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProvisionPhoneNumberReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProvisionPhoneNumberReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		e.FieldStart("number")
		e.Str(s.Number)
	}
	{
		e.FieldStart("voip_carrier_sid")
		json.EncodeUUID(e, s.VoipCarrierSid)
	}
}

var jsonFieldsNameOfProvisionPhoneNumberReq = [4]string{
	0: "account_sid",
	1: "application_sid",
	2: "number",
	3: "voip_carrier_sid",
}

// Decode decodes ProvisionPhoneNumberReq from json.
func (s *ProvisionPhoneNumberReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProvisionPhoneNumberReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Number = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VoipCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProvisionPhoneNumberReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProvisionPhoneNumberReq) {
					name = jsonFieldsNameOfProvisionPhoneNumberReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProvisionPhoneNumberReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProvisionPhoneNumberReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProvisionPhoneNumberUnprocessableEntity as json.
func (s *ProvisionPhoneNumberUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProvisionPhoneNumberUnprocessableEntity from json.
func (s *ProvisionPhoneNumberUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProvisionPhoneNumberUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProvisionPhoneNumberUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProvisionPhoneNumberUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProvisionPhoneNumberUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutTenantInternalServerError as json.
func (s *PutTenantInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PutTenantInternalServerError from json.
func (s *PutTenantInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutTenantInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PutTenantInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutTenantInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutTenantInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutTenantUnprocessableEntity as json.
func (s *PutTenantUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PutTenantUnprocessableEntity from json.
func (s *PutTenantUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutTenantUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PutTenantUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutTenantUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutTenantUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterUserBadRequest as json.
func (s *RegisterUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RegisterUserBadRequest from json.
func (s *RegisterUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterUserBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RegisterUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterUserForbidden as json.
func (s *RegisterUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RegisterUserForbidden from json.
func (s *RegisterUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterUserForbidden to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RegisterUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterUserInternalServerError as json.
func (s *RegisterUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RegisterUserInternalServerError from json.
func (s *RegisterUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterUserInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RegisterUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("service_provider_sid")
		e.Str(s.ServiceProviderSid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.EmailActivationCode.Set {
			e.FieldStart("email_activation_code")
			s.EmailActivationCode.Encode(e)
		}
	}
	{
		if s.OAuth2Code.Set {
			e.FieldStart("oauth2_code")
			s.OAuth2Code.Encode(e)
		}
	}
	{
		if s.OAuth2State.Set {
			e.FieldStart("oauth2_state")
			s.OAuth2State.Encode(e)
		}
	}
	{
		if s.OAuth2ClientID.Set {
			e.FieldStart("oauth2_client_id")
			s.OAuth2ClientID.Encode(e)
		}
	}
	{
		if s.OAuth2RedirectURI.Set {
			e.FieldStart("oauth2_redirect_uri")
			s.OAuth2RedirectURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegisterUserReq = [9]string{
	0: "service_provider_sid",
	1: "provider",
	2: "email",
	3: "password",
	4: "email_activation_code",
	5: "oauth2_code",
	6: "oauth2_state",
	7: "oauth2_client_id",
	8: "oauth2_redirect_uri",
}

// Decode decodes RegisterUserReq from json.
func (s *RegisterUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterUserReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service_provider_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServiceProviderSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "email_activation_code":
			if err := func() error {
				s.EmailActivationCode.Reset()
				if err := s.EmailActivationCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email_activation_code\"")
			}
		case "oauth2_code":
			if err := func() error {
				s.OAuth2Code.Reset()
				if err := s.OAuth2Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_code\"")
			}
		case "oauth2_state":
			if err := func() error {
				s.OAuth2State.Reset()
				if err := s.OAuth2State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_state\"")
			}
		case "oauth2_client_id":
			if err := func() error {
				s.OAuth2ClientID.Reset()
				if err := s.OAuth2ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_client_id\"")
			}
		case "oauth2_redirect_uri":
			if err := func() error {
				s.OAuth2RedirectURI.Reset()
				if err := s.OAuth2RedirectURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_redirect_uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterUserReq) {
					name = jsonFieldsNameOfRegisterUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterUserReqProvider as json.
func (s RegisterUserReqProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RegisterUserReqProvider from json.
func (s *RegisterUserReqProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterUserReqProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RegisterUserReqProvider(v) {
	case RegisterUserReqProviderGithub:
		*s = RegisterUserReqProviderGithub
	case RegisterUserReqProviderGoogle:
		*s = RegisterUserReqProviderGoogle
	case RegisterUserReqProviderTwitter:
		*s = RegisterUserReqProviderTwitter
	case RegisterUserReqProviderLocal:
		*s = RegisterUserReqProviderLocal
	default:
		*s = RegisterUserReqProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RegisterUserReqProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterUserReqProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterUserUnprocessableEntity as json.
func (s *RegisterUserUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RegisterUserUnprocessableEntity from json.
func (s *RegisterUserUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterUserUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RegisterUserUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterUserUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterUserUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisteredClient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisteredClient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Contact.Set {
			e.FieldStart("contact")
			s.Contact.Encode(e)
		}
	}
	{
		if s.ExpiryTime.Set {
			e.FieldStart("expiryTime")
			s.ExpiryTime.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.AllowDirectAppCalling.Set {
			e.FieldStart("allow_direct_app_calling")
			s.AllowDirectAppCalling.Encode(e)
		}
	}
	{
		if s.AllowDirectQueueCalling.Set {
			e.FieldStart("allow_direct_queue_calling")
			s.AllowDirectQueueCalling.Encode(e)
		}
	}
	{
		if s.AllowDirectUserCalling.Set {
			e.FieldStart("allow_direct_user_calling")
			s.AllowDirectUserCalling.Encode(e)
		}
	}
	{
		if s.RegisteredStatus.Set {
			e.FieldStart("registered_status")
			s.RegisteredStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegisteredClient = [8]string{
	0: "name",
	1: "contact",
	2: "expiryTime",
	3: "protocol",
	4: "allow_direct_app_calling",
	5: "allow_direct_queue_calling",
	6: "allow_direct_user_calling",
	7: "registered_status",
}

// Decode decodes RegisteredClient from json.
func (s *RegisteredClient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisteredClient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "contact":
			if err := func() error {
				s.Contact.Reset()
				if err := s.Contact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contact\"")
			}
		case "expiryTime":
			if err := func() error {
				s.ExpiryTime.Reset()
				if err := s.ExpiryTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiryTime\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "allow_direct_app_calling":
			if err := func() error {
				s.AllowDirectAppCalling.Reset()
				if err := s.AllowDirectAppCalling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_direct_app_calling\"")
			}
		case "allow_direct_queue_calling":
			if err := func() error {
				s.AllowDirectQueueCalling.Reset()
				if err := s.AllowDirectQueueCalling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_direct_queue_calling\"")
			}
		case "allow_direct_user_calling":
			if err := func() error {
				s.AllowDirectUserCalling.Reset()
				if err := s.AllowDirectUserCalling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_direct_user_calling\"")
			}
		case "registered_status":
			if err := func() error {
				s.RegisteredStatus.Reset()
				if err := s.RegisteredStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registered_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisteredClient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisteredClient) {
					name = jsonFieldsNameOfRegisteredClient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisteredClient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisteredClient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisteredClientRegisteredStatus as json.
func (s RegisteredClientRegisteredStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RegisteredClientRegisteredStatus from json.
func (s *RegisteredClientRegisteredStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisteredClientRegisteredStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RegisteredClientRegisteredStatus(v) {
	case RegisteredClientRegisteredStatusActive:
		*s = RegisteredClientRegisteredStatusActive
	case RegisteredClientRegisteredStatusInactive:
		*s = RegisteredClientRegisteredStatusInactive
	default:
		*s = RegisteredClientRegisteredStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RegisteredClientRegisteredStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisteredClientRegisteredStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveInvoiceOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveInvoiceOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRetrieveInvoiceOK = [0]string{}

// Decode decodes RetrieveInvoiceOK from json.
func (s *RetrieveInvoiceOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveInvoiceOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveInvoiceOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveInvoiceOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveInvoiceOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendActivationCodeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendActivationCodeReq) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.UserSid.Set {
			e.FieldStart("user_sid")
			s.UserSid.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendActivationCodeReq = [4]string{
	0: "code",
	1: "user_sid",
	2: "type",
	3: "value",
}

// Decode decodes SendActivationCodeReq from json.
func (s *SendActivationCodeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendActivationCodeReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "user_sid":
			if err := func() error {
				s.UserSid.Reset()
				if err := s.UserSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_sid\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendActivationCodeReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendActivationCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendActivationCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendActivationCodeReqType as json.
func (s SendActivationCodeReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SendActivationCodeReqType from json.
func (s *SendActivationCodeReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendActivationCodeReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SendActivationCodeReqType(v) {
	case SendActivationCodeReqTypeEmail:
		*s = SendActivationCodeReqTypeEmail
	case SendActivationCodeReqTypePhone:
		*s = SendActivationCodeReqTypePhone
	default:
		*s = SendActivationCodeReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendActivationCodeReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendActivationCodeReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("service_provider_sid")
		json.EncodeUUID(e, s.ServiceProviderSid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.RootDomain.Set {
			e.FieldStart("root_domain")
			s.RootDomain.Encode(e)
		}
	}
	{
		if s.RegistrationHook.Set {
			e.FieldStart("registration_hook")
			s.RegistrationHook.Encode(e)
		}
	}
	{
		if s.MsTeamsFqdn.Set {
			e.FieldStart("ms_teams_fqdn")
			s.MsTeamsFqdn.Encode(e)
		}
	}
	{
		if s.TestNumber.Set {
			e.FieldStart("test_number")
			s.TestNumber.Encode(e)
		}
	}
	{
		if s.TestApplicationName.Set {
			e.FieldStart("test_application_name")
			s.TestApplicationName.Encode(e)
		}
	}
	{
		if s.TestApplicationSid.Set {
			e.FieldStart("test_application_sid")
			s.TestApplicationSid.Encode(e)
		}
	}
}

var jsonFieldsNameOfServiceProvider = [9]string{
	0: "service_provider_sid",
	1: "name",
	2: "description",
	3: "root_domain",
	4: "registration_hook",
	5: "ms_teams_fqdn",
	6: "test_number",
	7: "test_application_name",
	8: "test_application_sid",
}

// Decode decodes ServiceProvider from json.
func (s *ServiceProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceProvider to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service_provider_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ServiceProviderSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "root_domain":
			if err := func() error {
				s.RootDomain.Reset()
				if err := s.RootDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root_domain\"")
			}
		case "registration_hook":
			if err := func() error {
				s.RegistrationHook.Reset()
				if err := s.RegistrationHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registration_hook\"")
			}
		case "ms_teams_fqdn":
			if err := func() error {
				s.MsTeamsFqdn.Reset()
				if err := s.MsTeamsFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ms_teams_fqdn\"")
			}
		case "test_number":
			if err := func() error {
				s.TestNumber.Reset()
				if err := s.TestNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_number\"")
			}
		case "test_application_name":
			if err := func() error {
				s.TestApplicationName.Reset()
				if err := s.TestApplicationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_application_name\"")
			}
		case "test_application_sid":
			if err := func() error {
				s.TestApplicationSid.Reset()
				if err := s.TestApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_application_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceProvider) {
					name = jsonFieldsNameOfServiceProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SipGateway) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SipGateway) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sip_gateway_sid")
		json.EncodeUUID(e, s.SipGatewaySid)
	}
	{
		e.FieldStart("ipv4")
		e.Str(s.Ipv4)
	}
	{
		e.FieldStart("port")
		e.Float64(s.Port)
	}
	{
		e.FieldStart("netmask")
		e.Float64(s.Netmask)
	}
	{
		e.FieldStart("voip_carrier_sid")
		json.EncodeUUID(e, s.VoipCarrierSid)
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
}

var jsonFieldsNameOfSipGateway = [7]string{
	0: "sip_gateway_sid",
	1: "ipv4",
	2: "port",
	3: "netmask",
	4: "voip_carrier_sid",
	5: "inbound",
	6: "outbound",
}

// Decode decodes SipGateway from json.
func (s *SipGateway) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SipGateway to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sip_gateway_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SipGatewaySid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_gateway_sid\"")
			}
		case "ipv4":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ipv4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Port = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "netmask":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Netmask = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"netmask\"")
			}
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VoipCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SipGateway")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSipGateway) {
					name = jsonFieldsNameOfSipGateway[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SipGateway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SipGateway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SmppGateway) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SmppGateway) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("smpp_gateway_sid")
		json.EncodeUUID(e, s.SmppGatewaySid)
	}
	{
		e.FieldStart("ipv4")
		e.Str(s.Ipv4)
	}
	{
		e.FieldStart("port")
		e.Float64(s.Port)
	}
	{
		e.FieldStart("netmask")
		e.Float64(s.Netmask)
	}
	{
		e.FieldStart("voip_carrier_sid")
		json.EncodeUUID(e, s.VoipCarrierSid)
	}
	{
		if s.IsPrimary.Set {
			e.FieldStart("is_primary")
			s.IsPrimary.Encode(e)
		}
	}
	{
		if s.UseTLS.Set {
			e.FieldStart("use_tls")
			s.UseTLS.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
}

var jsonFieldsNameOfSmppGateway = [9]string{
	0: "smpp_gateway_sid",
	1: "ipv4",
	2: "port",
	3: "netmask",
	4: "voip_carrier_sid",
	5: "is_primary",
	6: "use_tls",
	7: "inbound",
	8: "outbound",
}

// Decode decodes SmppGateway from json.
func (s *SmppGateway) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SmppGateway to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "smpp_gateway_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SmppGatewaySid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smpp_gateway_sid\"")
			}
		case "ipv4":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ipv4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Port = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "netmask":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Netmask = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"netmask\"")
			}
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VoipCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		case "is_primary":
			if err := func() error {
				s.IsPrimary.Reset()
				if err := s.IsPrimary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_primary\"")
			}
		case "use_tls":
			if err := func() error {
				s.UseTLS.Reset()
				if err := s.UseTLS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_tls\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SmppGateway")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSmppGateway) {
					name = jsonFieldsNameOfSmppGateway[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SmppGateway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SmppGateway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechCredential) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechCredential) encodeFields(e *jx.Encoder) {
	{
		if s.SpeechCredentialSid.Set {
			e.FieldStart("speech_credential_sid")
			s.SpeechCredentialSid.Encode(e)
		}
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.Vendor.Set {
			e.FieldStart("vendor")
			s.Vendor.Encode(e)
		}
	}
	{
		if s.ServiceKey.Set {
			e.FieldStart("service_key")
			s.ServiceKey.Encode(e)
		}
	}
	{
		if s.AccessKeyID.Set {
			e.FieldStart("access_key_id")
			s.AccessKeyID.Encode(e)
		}
	}
	{
		if s.SecretAccessKey.Set {
			e.FieldStart("secret_access_key")
			s.SecretAccessKey.Encode(e)
		}
	}
	{
		if s.AWSRegion.Set {
			e.FieldStart("aws_region")
			s.AWSRegion.Encode(e)
		}
	}
	{
		if s.LastUsed.Set {
			e.FieldStart("last_used")
			s.LastUsed.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastTested.Set {
			e.FieldStart("last_tested")
			s.LastTested.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UseForTts.Set {
			e.FieldStart("use_for_tts")
			s.UseForTts.Encode(e)
		}
	}
	{
		if s.UseForStt.Set {
			e.FieldStart("use_for_stt")
			s.UseForStt.Encode(e)
		}
	}
	{
		if s.TtsTestedOk.Set {
			e.FieldStart("tts_tested_ok")
			s.TtsTestedOk.Encode(e)
		}
	}
	{
		if s.SttTestedOk.Set {
			e.FieldStart("stt_tested_ok")
			s.SttTestedOk.Encode(e)
		}
	}
	{
		if s.RivaServerURI.Set {
			e.FieldStart("riva_server_uri")
			s.RivaServerURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpeechCredential = [14]string{
	0:  "speech_credential_sid",
	1:  "account_sid",
	2:  "vendor",
	3:  "service_key",
	4:  "access_key_id",
	5:  "secret_access_key",
	6:  "aws_region",
	7:  "last_used",
	8:  "last_tested",
	9:  "use_for_tts",
	10: "use_for_stt",
	11: "tts_tested_ok",
	12: "stt_tested_ok",
	13: "riva_server_uri",
}

// Decode decodes SpeechCredential from json.
func (s *SpeechCredential) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechCredential to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "speech_credential_sid":
			if err := func() error {
				s.SpeechCredentialSid.Reset()
				if err := s.SpeechCredentialSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_credential_sid\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "vendor":
			if err := func() error {
				s.Vendor.Reset()
				if err := s.Vendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "service_key":
			if err := func() error {
				s.ServiceKey.Reset()
				if err := s.ServiceKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_key\"")
			}
		case "access_key_id":
			if err := func() error {
				s.AccessKeyID.Reset()
				if err := s.AccessKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_key_id\"")
			}
		case "secret_access_key":
			if err := func() error {
				s.SecretAccessKey.Reset()
				if err := s.SecretAccessKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_access_key\"")
			}
		case "aws_region":
			if err := func() error {
				s.AWSRegion.Reset()
				if err := s.AWSRegion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aws_region\"")
			}
		case "last_used":
			if err := func() error {
				s.LastUsed.Reset()
				if err := s.LastUsed.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_used\"")
			}
		case "last_tested":
			if err := func() error {
				s.LastTested.Reset()
				if err := s.LastTested.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_tested\"")
			}
		case "use_for_tts":
			if err := func() error {
				s.UseForTts.Reset()
				if err := s.UseForTts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_for_tts\"")
			}
		case "use_for_stt":
			if err := func() error {
				s.UseForStt.Reset()
				if err := s.UseForStt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_for_stt\"")
			}
		case "tts_tested_ok":
			if err := func() error {
				s.TtsTestedOk.Reset()
				if err := s.TtsTestedOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tts_tested_ok\"")
			}
		case "stt_tested_ok":
			if err := func() error {
				s.SttTestedOk.Reset()
				if err := s.SttTestedOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stt_tested_ok\"")
			}
		case "riva_server_uri":
			if err := func() error {
				s.RivaServerURI.Reset()
				if err := s.RivaServerURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riva_server_uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeechCredential")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechCredentialUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechCredentialUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.UseForTts.Set {
			e.FieldStart("use_for_tts")
			s.UseForTts.Encode(e)
		}
	}
	{
		if s.UseForStt.Set {
			e.FieldStart("use_for_stt")
			s.UseForStt.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpeechCredentialUpdate = [2]string{
	0: "use_for_tts",
	1: "use_for_stt",
}

// Decode decodes SpeechCredentialUpdate from json.
func (s *SpeechCredentialUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechCredentialUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "use_for_tts":
			if err := func() error {
				s.UseForTts.Reset()
				if err := s.UseForTts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_for_tts\"")
			}
		case "use_for_stt":
			if err := func() error {
				s.UseForStt.Reset()
				if err := s.UseForStt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_for_stt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeechCredentialUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechCredentialUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechCredentialUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechCredentialVendor as json.
func (s SpeechCredentialVendor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeechCredentialVendor from json.
func (s *SpeechCredentialVendor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechCredentialVendor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeechCredentialVendor(v) {
	case SpeechCredentialVendorGoogle:
		*s = SpeechCredentialVendorGoogle
	case SpeechCredentialVendorAWS:
		*s = SpeechCredentialVendorAWS
	default:
		*s = SpeechCredentialVendor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeechCredentialVendor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechCredentialVendor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechLanguagesVoices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechLanguagesVoices) encodeFields(e *jx.Encoder) {
	{
		if s.Tts != nil {
			e.FieldStart("tts")
			e.ArrStart()
			for _, elem := range s.Tts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Stt != nil {
			e.FieldStart("stt")
			e.ArrStart()
			for _, elem := range s.Stt {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TtsModel != nil {
			e.FieldStart("ttsModel")
			e.ArrStart()
			for _, elem := range s.TtsModel {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSpeechLanguagesVoices = [3]string{
	0: "tts",
	1: "stt",
	2: "ttsModel",
}

// Decode decodes SpeechLanguagesVoices from json.
func (s *SpeechLanguagesVoices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechLanguagesVoices to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tts":
			if err := func() error {
				s.Tts = make([]LanguageVoices, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LanguageVoices
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tts = append(s.Tts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tts\"")
			}
		case "stt":
			if err := func() error {
				s.Stt = make([]LanguageVoice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LanguageVoice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Stt = append(s.Stt, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stt\"")
			}
		case "ttsModel":
			if err := func() error {
				s.TtsModel = make([]TtsModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TtsModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TtsModel = append(s.TtsModel, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttsModel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeechLanguagesVoices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechLanguagesVoices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechLanguagesVoices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessfulAdd) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessfulAdd) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sid")
		e.Str(s.Sid)
	}
}

var jsonFieldsNameOfSuccessfulAdd = [1]string{
	0: "sid",
}

// Decode decodes SuccessfulAdd from json.
func (s *SuccessfulAdd) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessfulAdd to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessfulAdd")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessfulAdd) {
					name = jsonFieldsNameOfSuccessfulAdd[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessfulAdd) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessfulAdd) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessfulApiKeyAdd) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessfulApiKeyAdd) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sid")
		e.Str(s.Sid)
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfSuccessfulApiKeyAdd = [2]string{
	0: "sid",
	1: "token",
}

// Decode decodes SuccessfulApiKeyAdd from json.
func (s *SuccessfulApiKeyAdd) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessfulApiKeyAdd to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessfulApiKeyAdd")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessfulApiKeyAdd) {
					name = jsonFieldsNameOfSuccessfulApiKeyAdd[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessfulApiKeyAdd) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessfulApiKeyAdd) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessfulLogin) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessfulLogin) encodeFields(e *jx.Encoder) {
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
	{
		if s.UserSid.Set {
			e.FieldStart("user_sid")
			s.UserSid.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.ForceChange.Set {
			e.FieldStart("force_change")
			s.ForceChange.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessfulLogin = [4]string{
	0: "token",
	1: "user_sid",
	2: "scope",
	3: "force_change",
}

// Decode decodes SuccessfulLogin from json.
func (s *SuccessfulLogin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessfulLogin to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "user_sid":
			if err := func() error {
				s.UserSid.Reset()
				if err := s.UserSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_sid\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "force_change":
			if err := func() error {
				s.ForceChange.Reset()
				if err := s.ForceChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_change\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessfulLogin")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessfulLogin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessfulLogin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynthesizeBadRequest as json.
func (s *SynthesizeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes SynthesizeBadRequest from json.
func (s *SynthesizeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynthesizeBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SynthesizeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynthesizeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynthesizeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynthesizeInternalServerError as json.
func (s *SynthesizeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes SynthesizeInternalServerError from json.
func (s *SynthesizeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynthesizeInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SynthesizeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynthesizeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynthesizeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynthesizeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynthesizeReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("speech_credential_sid")
		e.Str(s.SpeechCredentialSid)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("language")
		e.Str(s.Language)
	}
	{
		e.FieldStart("voice")
		e.Str(s.Voice)
	}
	{
		if s.EncodingMp3.Set {
			e.FieldStart("encodingMp3")
			s.EncodingMp3.Encode(e)
		}
	}
}

var jsonFieldsNameOfSynthesizeReq = [5]string{
	0: "speech_credential_sid",
	1: "text",
	2: "language",
	3: "voice",
	4: "encodingMp3",
}

// Decode decodes SynthesizeReq from json.
func (s *SynthesizeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynthesizeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "speech_credential_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SpeechCredentialSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_credential_sid\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "language":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Language = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Voice = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "encodingMp3":
			if err := func() error {
				s.EncodingMp3.Reset()
				if err := s.EncodingMp3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodingMp3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SynthesizeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSynthesizeReq) {
					name = jsonFieldsNameOfSynthesizeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynthesizeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynthesizeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynthesizeUnprocessableEntity as json.
func (s *SynthesizeUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes SynthesizeUnprocessableEntity from json.
func (s *SynthesizeUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynthesizeUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SynthesizeUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynthesizeUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynthesizeUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Target) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Target) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Number.Set {
			e.FieldStart("number")
			s.Number.Encode(e)
		}
	}
	{
		if s.SipUri.Set {
			e.FieldStart("sipUri")
			s.SipUri.Encode(e)
		}
	}
	{
		if s.Tenant.Set {
			e.FieldStart("tenant")
			s.Tenant.Encode(e)
		}
	}
	{
		if s.Trunk.Set {
			e.FieldStart("trunk")
			s.Trunk.Encode(e)
		}
	}
	{
		if s.Vmail.Set {
			e.FieldStart("vmail")
			s.Vmail.Encode(e)
		}
	}
	{
		if s.OverrideTo.Set {
			e.FieldStart("overrideTo")
			s.OverrideTo.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Auth.Set {
			e.FieldStart("auth")
			s.Auth.Encode(e)
		}
	}
}

var jsonFieldsNameOfTarget = [9]string{
	0: "type",
	1: "number",
	2: "sipUri",
	3: "tenant",
	4: "trunk",
	5: "vmail",
	6: "overrideTo",
	7: "name",
	8: "auth",
}

// Decode decodes Target from json.
func (s *Target) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Target to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "sipUri":
			if err := func() error {
				s.SipUri.Reset()
				if err := s.SipUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sipUri\"")
			}
		case "tenant":
			if err := func() error {
				s.Tenant.Reset()
				if err := s.Tenant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant\"")
			}
		case "trunk":
			if err := func() error {
				s.Trunk.Reset()
				if err := s.Trunk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trunk\"")
			}
		case "vmail":
			if err := func() error {
				s.Vmail.Reset()
				if err := s.Vmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmail\"")
			}
		case "overrideTo":
			if err := func() error {
				s.OverrideTo.Reset()
				if err := s.OverrideTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideTo\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "auth":
			if err := func() error {
				s.Auth.Reset()
				if err := s.Auth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Target")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTarget) {
					name = jsonFieldsNameOfTarget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Target) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Target) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TargetAuth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TargetAuth) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfTargetAuth = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes TargetAuth from json.
func (s *TargetAuth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TargetAuth to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TargetAuth")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TargetAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TargetAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TargetType as json.
func (s TargetType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TargetType from json.
func (s *TargetType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TargetType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TargetType(v) {
	case TargetTypePhone:
		*s = TargetTypePhone
	case TargetTypeSip:
		*s = TargetTypeSip
	case TargetTypeUser:
		*s = TargetTypeUser
	case TargetTypeTeams:
		*s = TargetTypeTeams
	default:
		*s = TargetType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestSpeechCredentialByAccountOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestSpeechCredentialByAccountOK) encodeFields(e *jx.Encoder) {
	{
		if s.Tts.Set {
			e.FieldStart("tts")
			s.Tts.Encode(e)
		}
	}
	{
		if s.Stt.Set {
			e.FieldStart("stt")
			s.Stt.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestSpeechCredentialByAccountOK = [2]string{
	0: "tts",
	1: "stt",
}

// Decode decodes TestSpeechCredentialByAccountOK from json.
func (s *TestSpeechCredentialByAccountOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialByAccountOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tts":
			if err := func() error {
				s.Tts.Reset()
				if err := s.Tts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tts\"")
			}
		case "stt":
			if err := func() error {
				s.Stt.Reset()
				if err := s.Stt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpeechCredentialByAccountOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestSpeechCredentialByAccountOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialByAccountOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestSpeechCredentialByAccountOKStt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestSpeechCredentialByAccountOKStt) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestSpeechCredentialByAccountOKStt = [2]string{
	0: "status",
	1: "reason",
}

// Decode decodes TestSpeechCredentialByAccountOKStt from json.
func (s *TestSpeechCredentialByAccountOKStt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialByAccountOKStt to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpeechCredentialByAccountOKStt")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestSpeechCredentialByAccountOKStt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialByAccountOKStt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialByAccountOKSttStatus as json.
func (s TestSpeechCredentialByAccountOKSttStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestSpeechCredentialByAccountOKSttStatus from json.
func (s *TestSpeechCredentialByAccountOKSttStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialByAccountOKSttStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestSpeechCredentialByAccountOKSttStatus(v) {
	case TestSpeechCredentialByAccountOKSttStatusSuccess:
		*s = TestSpeechCredentialByAccountOKSttStatusSuccess
	case TestSpeechCredentialByAccountOKSttStatusFail:
		*s = TestSpeechCredentialByAccountOKSttStatusFail
	default:
		*s = TestSpeechCredentialByAccountOKSttStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestSpeechCredentialByAccountOKSttStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialByAccountOKSttStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestSpeechCredentialByAccountOKTts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestSpeechCredentialByAccountOKTts) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestSpeechCredentialByAccountOKTts = [2]string{
	0: "status",
	1: "reason",
}

// Decode decodes TestSpeechCredentialByAccountOKTts from json.
func (s *TestSpeechCredentialByAccountOKTts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialByAccountOKTts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpeechCredentialByAccountOKTts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestSpeechCredentialByAccountOKTts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialByAccountOKTts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialByAccountOKTtsStatus as json.
func (s TestSpeechCredentialByAccountOKTtsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestSpeechCredentialByAccountOKTtsStatus from json.
func (s *TestSpeechCredentialByAccountOKTtsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialByAccountOKTtsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestSpeechCredentialByAccountOKTtsStatus(v) {
	case TestSpeechCredentialByAccountOKTtsStatusSuccess:
		*s = TestSpeechCredentialByAccountOKTtsStatusSuccess
	case TestSpeechCredentialByAccountOKTtsStatusFail:
		*s = TestSpeechCredentialByAccountOKTtsStatusFail
	case TestSpeechCredentialByAccountOKTtsStatusNotTested:
		*s = TestSpeechCredentialByAccountOKTtsStatusNotTested
	default:
		*s = TestSpeechCredentialByAccountOKTtsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestSpeechCredentialByAccountOKTtsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialByAccountOKTtsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestSpeechCredentialOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestSpeechCredentialOK) encodeFields(e *jx.Encoder) {
	{
		if s.Tts.Set {
			e.FieldStart("tts")
			s.Tts.Encode(e)
		}
	}
	{
		if s.Stt.Set {
			e.FieldStart("stt")
			s.Stt.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestSpeechCredentialOK = [2]string{
	0: "tts",
	1: "stt",
}

// Decode decodes TestSpeechCredentialOK from json.
func (s *TestSpeechCredentialOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tts":
			if err := func() error {
				s.Tts.Reset()
				if err := s.Tts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tts\"")
			}
		case "stt":
			if err := func() error {
				s.Stt.Reset()
				if err := s.Stt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpeechCredentialOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestSpeechCredentialOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestSpeechCredentialOKStt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestSpeechCredentialOKStt) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestSpeechCredentialOKStt = [2]string{
	0: "status",
	1: "reason",
}

// Decode decodes TestSpeechCredentialOKStt from json.
func (s *TestSpeechCredentialOKStt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialOKStt to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpeechCredentialOKStt")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestSpeechCredentialOKStt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialOKStt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialOKSttStatus as json.
func (s TestSpeechCredentialOKSttStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestSpeechCredentialOKSttStatus from json.
func (s *TestSpeechCredentialOKSttStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialOKSttStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestSpeechCredentialOKSttStatus(v) {
	case TestSpeechCredentialOKSttStatusSuccess:
		*s = TestSpeechCredentialOKSttStatusSuccess
	case TestSpeechCredentialOKSttStatusFail:
		*s = TestSpeechCredentialOKSttStatusFail
	default:
		*s = TestSpeechCredentialOKSttStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestSpeechCredentialOKSttStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialOKSttStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestSpeechCredentialOKTts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestSpeechCredentialOKTts) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestSpeechCredentialOKTts = [2]string{
	0: "status",
	1: "reason",
}

// Decode decodes TestSpeechCredentialOKTts from json.
func (s *TestSpeechCredentialOKTts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialOKTts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpeechCredentialOKTts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestSpeechCredentialOKTts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialOKTts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestSpeechCredentialOKTtsStatus as json.
func (s TestSpeechCredentialOKTtsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestSpeechCredentialOKTtsStatus from json.
func (s *TestSpeechCredentialOKTtsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpeechCredentialOKTtsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestSpeechCredentialOKTtsStatus(v) {
	case TestSpeechCredentialOKTtsStatusSuccess:
		*s = TestSpeechCredentialOKTtsStatusSuccess
	case TestSpeechCredentialOKTtsStatusFail:
		*s = TestSpeechCredentialOKTtsStatusFail
	case TestSpeechCredentialOKTtsStatusNotTested:
		*s = TestSpeechCredentialOKTtsStatusNotTested
	default:
		*s = TestSpeechCredentialOKTtsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestSpeechCredentialOKTtsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpeechCredentialOKTtsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TtsModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TtsModel) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfTtsModel = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes TtsModel from json.
func (s *TtsModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TtsModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TtsModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TtsModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TtsModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAccountInternalServerError as json.
func (s *UpdateAccountInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateAccountInternalServerError from json.
func (s *UpdateAccountInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAccountInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateAccountInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAccountInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAccountInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAccountUnprocessableEntity as json.
func (s *UpdateAccountUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateAccountUnprocessableEntity from json.
func (s *UpdateAccountUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAccountUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateAccountUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAccountUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAccountUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateApplicationInternalServerError as json.
func (s *UpdateApplicationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateApplicationInternalServerError from json.
func (s *UpdateApplicationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateApplicationInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateApplicationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateApplicationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateApplicationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateApplicationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateApplicationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("call_hook")
		s.CallHook.Encode(e)
	}
	{
		e.FieldStart("call_status_hook")
		s.CallStatusHook.Encode(e)
	}
	{
		e.FieldStart("messaging_hook")
		s.MessagingHook.Encode(e)
	}
	{
		e.FieldStart("record_all_calls")
		s.RecordAllCalls.Encode(e)
	}
}

var jsonFieldsNameOfUpdateApplicationReq = [6]string{
	0: "name",
	1: "account_sid",
	2: "call_hook",
	3: "call_status_hook",
	4: "messaging_hook",
	5: "record_all_calls",
}

// Decode decodes UpdateApplicationReq from json.
func (s *UpdateApplicationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateApplicationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_hook":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.CallHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_hook\"")
			}
		case "call_status_hook":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CallStatusHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_status_hook\"")
			}
		case "messaging_hook":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.MessagingHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_hook\"")
			}
		case "record_all_calls":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.RecordAllCalls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_all_calls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateApplicationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateApplicationReq) {
					name = jsonFieldsNameOfUpdateApplicationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateApplicationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateApplicationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateApplicationReqRecordAllCalls as json.
func (s UpdateApplicationReqRecordAllCalls) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes UpdateApplicationReqRecordAllCalls from json.
func (s *UpdateApplicationReqRecordAllCalls) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateApplicationReqRecordAllCalls to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = UpdateApplicationReqRecordAllCalls(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateApplicationReqRecordAllCalls) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateApplicationReqRecordAllCalls) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateApplicationUnprocessableEntity as json.
func (s *UpdateApplicationUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateApplicationUnprocessableEntity from json.
func (s *UpdateApplicationUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateApplicationUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateApplicationUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateApplicationUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateApplicationUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallInternalServerError as json.
func (s *UpdateCallInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCallInternalServerError from json.
func (s *UpdateCallInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCallInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallReq) encodeFields(e *jx.Encoder) {
	{
		if s.CallHook.Set {
			e.FieldStart("call_hook")
			s.CallHook.Encode(e)
		}
	}
	{
		if s.ChildCallHook.Set {
			e.FieldStart("child_call_hook")
			s.ChildCallHook.Encode(e)
		}
	}
	{
		if s.CallStatus.Set {
			e.FieldStart("call_status")
			s.CallStatus.Encode(e)
		}
	}
	{
		if s.ConfMuteStatus.Set {
			e.FieldStart("conf_mute_status")
			s.ConfMuteStatus.Encode(e)
		}
	}
	{
		if s.ConfHoldStatus.Set {
			e.FieldStart("conf_hold_status")
			s.ConfHoldStatus.Encode(e)
		}
	}
	{
		if s.ListenStatus.Set {
			e.FieldStart("listen_status")
			s.ListenStatus.Encode(e)
		}
	}
	{
		if s.MuteStatus.Set {
			e.FieldStart("mute_status")
			s.MuteStatus.Encode(e)
		}
	}
	{
		if s.Whisper.Set {
			e.FieldStart("whisper")
			s.Whisper.Encode(e)
		}
	}
	{
		if s.SipRequest.Set {
			e.FieldStart("sip_request")
			s.SipRequest.Encode(e)
		}
	}
	{
		if s.Record.Set {
			e.FieldStart("record")
			s.Record.Encode(e)
		}
	}
	{
		if s.ConferenceParticipantAction.Set {
			e.FieldStart("conferenceParticipantAction")
			s.ConferenceParticipantAction.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCallReq = [11]string{
	0:  "call_hook",
	1:  "child_call_hook",
	2:  "call_status",
	3:  "conf_mute_status",
	4:  "conf_hold_status",
	5:  "listen_status",
	6:  "mute_status",
	7:  "whisper",
	8:  "sip_request",
	9:  "record",
	10: "conferenceParticipantAction",
}

// Decode decodes UpdateCallReq from json.
func (s *UpdateCallReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "call_hook":
			if err := func() error {
				s.CallHook.Reset()
				if err := s.CallHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_hook\"")
			}
		case "child_call_hook":
			if err := func() error {
				s.ChildCallHook.Reset()
				if err := s.ChildCallHook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"child_call_hook\"")
			}
		case "call_status":
			if err := func() error {
				s.CallStatus.Reset()
				if err := s.CallStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_status\"")
			}
		case "conf_mute_status":
			if err := func() error {
				s.ConfMuteStatus.Reset()
				if err := s.ConfMuteStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conf_mute_status\"")
			}
		case "conf_hold_status":
			if err := func() error {
				s.ConfHoldStatus.Reset()
				if err := s.ConfHoldStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conf_hold_status\"")
			}
		case "listen_status":
			if err := func() error {
				s.ListenStatus.Reset()
				if err := s.ListenStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"listen_status\"")
			}
		case "mute_status":
			if err := func() error {
				s.MuteStatus.Reset()
				if err := s.MuteStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mute_status\"")
			}
		case "whisper":
			if err := func() error {
				s.Whisper.Reset()
				if err := s.Whisper.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whisper\"")
			}
		case "sip_request":
			if err := func() error {
				s.SipRequest.Reset()
				if err := s.SipRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_request\"")
			}
		case "record":
			if err := func() error {
				s.Record.Reset()
				if err := s.Record.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record\"")
			}
		case "conferenceParticipantAction":
			if err := func() error {
				s.ConferenceParticipantAction.Reset()
				if err := s.ConferenceParticipantAction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conferenceParticipantAction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqCallStatus as json.
func (s UpdateCallReqCallStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallReqCallStatus from json.
func (s *UpdateCallReqCallStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqCallStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallReqCallStatus(v) {
	case UpdateCallReqCallStatusCompleted:
		*s = UpdateCallReqCallStatusCompleted
	case UpdateCallReqCallStatusNoAnswer:
		*s = UpdateCallReqCallStatusNoAnswer
	default:
		*s = UpdateCallReqCallStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallReqCallStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqCallStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqConfHoldStatus as json.
func (s UpdateCallReqConfHoldStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallReqConfHoldStatus from json.
func (s *UpdateCallReqConfHoldStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqConfHoldStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallReqConfHoldStatus(v) {
	case UpdateCallReqConfHoldStatusHold:
		*s = UpdateCallReqConfHoldStatusHold
	case UpdateCallReqConfHoldStatusUnhold:
		*s = UpdateCallReqConfHoldStatusUnhold
	default:
		*s = UpdateCallReqConfHoldStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallReqConfHoldStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqConfHoldStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqConfMuteStatus as json.
func (s UpdateCallReqConfMuteStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallReqConfMuteStatus from json.
func (s *UpdateCallReqConfMuteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqConfMuteStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallReqConfMuteStatus(v) {
	case UpdateCallReqConfMuteStatusMute:
		*s = UpdateCallReqConfMuteStatusMute
	case UpdateCallReqConfMuteStatusUnmute:
		*s = UpdateCallReqConfMuteStatusUnmute
	default:
		*s = UpdateCallReqConfMuteStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallReqConfMuteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqConfMuteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallReqConferenceParticipantAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallReqConferenceParticipantAction) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCallReqConferenceParticipantAction = [2]string{
	0: "action",
	1: "tag",
}

// Decode decodes UpdateCallReqConferenceParticipantAction from json.
func (s *UpdateCallReqConferenceParticipantAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqConferenceParticipantAction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallReqConferenceParticipantAction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallReqConferenceParticipantAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqConferenceParticipantAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqConferenceParticipantActionAction as json.
func (s UpdateCallReqConferenceParticipantActionAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallReqConferenceParticipantActionAction from json.
func (s *UpdateCallReqConferenceParticipantActionAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqConferenceParticipantActionAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallReqConferenceParticipantActionAction(v) {
	case UpdateCallReqConferenceParticipantActionActionTag:
		*s = UpdateCallReqConferenceParticipantActionActionTag
	case UpdateCallReqConferenceParticipantActionActionUntag:
		*s = UpdateCallReqConferenceParticipantActionActionUntag
	case UpdateCallReqConferenceParticipantActionActionCoach:
		*s = UpdateCallReqConferenceParticipantActionActionCoach
	case UpdateCallReqConferenceParticipantActionActionUncoach:
		*s = UpdateCallReqConferenceParticipantActionActionUncoach
	case UpdateCallReqConferenceParticipantActionActionMute:
		*s = UpdateCallReqConferenceParticipantActionActionMute
	case UpdateCallReqConferenceParticipantActionActionUnmute:
		*s = UpdateCallReqConferenceParticipantActionActionUnmute
	case UpdateCallReqConferenceParticipantActionActionHold:
		*s = UpdateCallReqConferenceParticipantActionActionHold
	case UpdateCallReqConferenceParticipantActionActionUnhold:
		*s = UpdateCallReqConferenceParticipantActionActionUnhold
	default:
		*s = UpdateCallReqConferenceParticipantActionAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallReqConferenceParticipantActionAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqConferenceParticipantActionAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqListenStatus as json.
func (s UpdateCallReqListenStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallReqListenStatus from json.
func (s *UpdateCallReqListenStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqListenStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallReqListenStatus(v) {
	case UpdateCallReqListenStatusPause:
		*s = UpdateCallReqListenStatusPause
	case UpdateCallReqListenStatusSilence:
		*s = UpdateCallReqListenStatusSilence
	case UpdateCallReqListenStatusResume:
		*s = UpdateCallReqListenStatusResume
	default:
		*s = UpdateCallReqListenStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallReqListenStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqListenStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqMuteStatus as json.
func (s UpdateCallReqMuteStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallReqMuteStatus from json.
func (s *UpdateCallReqMuteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqMuteStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallReqMuteStatus(v) {
	case UpdateCallReqMuteStatusMute:
		*s = UpdateCallReqMuteStatusMute
	case UpdateCallReqMuteStatusUnmute:
		*s = UpdateCallReqMuteStatusUnmute
	default:
		*s = UpdateCallReqMuteStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallReqMuteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqMuteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallReqRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallReqRecord) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.RecordingID.Set {
			e.FieldStart("recordingID")
			s.RecordingID.Encode(e)
		}
	}
	{
		if s.SiprecServerURL.Set {
			e.FieldStart("siprecServerURL")
			s.SiprecServerURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCallReqRecord = [3]string{
	0: "action",
	1: "recordingID",
	2: "siprecServerURL",
}

// Decode decodes UpdateCallReqRecord from json.
func (s *UpdateCallReqRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "recordingID":
			if err := func() error {
				s.RecordingID.Reset()
				if err := s.RecordingID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordingID\"")
			}
		case "siprecServerURL":
			if err := func() error {
				s.SiprecServerURL.Reset()
				if err := s.SiprecServerURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"siprecServerURL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallReqRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallReqRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallReqRecordAction as json.
func (s UpdateCallReqRecordAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallReqRecordAction from json.
func (s *UpdateCallReqRecordAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqRecordAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallReqRecordAction(v) {
	case UpdateCallReqRecordActionStartCallRecording:
		*s = UpdateCallReqRecordActionStartCallRecording
	case UpdateCallReqRecordActionStopCallRecording:
		*s = UpdateCallReqRecordActionStopCallRecording
	case UpdateCallReqRecordActionPauseCallRecording:
		*s = UpdateCallReqRecordActionPauseCallRecording
	case UpdateCallReqRecordActionResumeCallRecording:
		*s = UpdateCallReqRecordActionResumeCallRecording
	default:
		*s = UpdateCallReqRecordAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallReqRecordAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqRecordAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallReqSipRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallReqSipRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCallReqSipRequest = [4]string{
	0: "method",
	1: "content_type",
	2: "content",
	3: "headers",
}

// Decode decodes UpdateCallReqSipRequest from json.
func (s *UpdateCallReqSipRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqSipRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "headers":
			if err := func() error {
				s.Headers = nil
				var elem UpdateCallReqSipRequestHeaders
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Headers = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallReqSipRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallReqSipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqSipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallReqSipRequestHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallReqSipRequestHeaders) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateCallReqSipRequestHeaders = [0]string{}

// Decode decodes UpdateCallReqSipRequestHeaders from json.
func (s *UpdateCallReqSipRequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallReqSipRequestHeaders to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallReqSipRequestHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallReqSipRequestHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallReqSipRequestHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallUnprocessableEntity as json.
func (s *UpdateCallUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCallUnprocessableEntity from json.
func (s *UpdateCallUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCallUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateGoogleCustomVoiceBadRequest as json.
func (s *UpdateGoogleCustomVoiceBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateGoogleCustomVoiceBadRequest from json.
func (s *UpdateGoogleCustomVoiceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGoogleCustomVoiceBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateGoogleCustomVoiceBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateGoogleCustomVoiceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateGoogleCustomVoiceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateGoogleCustomVoiceInternalServerError as json.
func (s *UpdateGoogleCustomVoiceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateGoogleCustomVoiceInternalServerError from json.
func (s *UpdateGoogleCustomVoiceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGoogleCustomVoiceInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateGoogleCustomVoiceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateGoogleCustomVoiceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateGoogleCustomVoiceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingBadRequest as json.
func (s *UpdateLeastCostRoutingBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingBadRequest from json.
func (s *UpdateLeastCostRoutingBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingCarrierSetEntryBadRequest as json.
func (s *UpdateLeastCostRoutingCarrierSetEntryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingCarrierSetEntryBadRequest from json.
func (s *UpdateLeastCostRoutingCarrierSetEntryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingCarrierSetEntryBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingCarrierSetEntryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingCarrierSetEntryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingCarrierSetEntryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingCarrierSetEntryInternalServerError as json.
func (s *UpdateLeastCostRoutingCarrierSetEntryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingCarrierSetEntryInternalServerError from json.
func (s *UpdateLeastCostRoutingCarrierSetEntryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingCarrierSetEntryInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingCarrierSetEntryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingCarrierSetEntryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingCarrierSetEntryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingInternalServerError as json.
func (s *UpdateLeastCostRoutingInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingInternalServerError from json.
func (s *UpdateLeastCostRoutingInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingRouteBadRequest as json.
func (s *UpdateLeastCostRoutingRouteBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingRouteBadRequest from json.
func (s *UpdateLeastCostRoutingRouteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingRouteBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingRouteBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingRouteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingRouteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingRouteInternalServerError as json.
func (s *UpdateLeastCostRoutingRouteInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingRouteInternalServerError from json.
func (s *UpdateLeastCostRoutingRouteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingRouteInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingRouteInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingRouteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingRouteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest as json.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest from json.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError as json.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError from json.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLeastCostRoutingRoutesAndCarrierEntriesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePhoneNumberBadRequest as json.
func (s *UpdatePhoneNumberBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePhoneNumberBadRequest from json.
func (s *UpdatePhoneNumberBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePhoneNumberBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePhoneNumberBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePhoneNumberBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePhoneNumberBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePhoneNumberInternalServerError as json.
func (s *UpdatePhoneNumberInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePhoneNumberInternalServerError from json.
func (s *UpdatePhoneNumberInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePhoneNumberInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePhoneNumberInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePhoneNumberInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePhoneNumberInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePhoneNumberReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePhoneNumberReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_sid")
		json.EncodeUUID(e, s.AccountSid)
	}
	{
		e.FieldStart("application_sid")
		s.ApplicationSid.Encode(e)
	}
}

var jsonFieldsNameOfUpdatePhoneNumberReq = [2]string{
	0: "account_sid",
	1: "application_sid",
}

// Decode decodes UpdatePhoneNumberReq from json.
func (s *UpdatePhoneNumberReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePhoneNumberReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePhoneNumberReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePhoneNumberReq) {
					name = jsonFieldsNameOfUpdatePhoneNumberReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePhoneNumberReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePhoneNumberReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceProviderInternalServerError as json.
func (s *UpdateServiceProviderInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateServiceProviderInternalServerError from json.
func (s *UpdateServiceProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceProviderInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateServiceProviderInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceProviderUnprocessableEntity as json.
func (s *UpdateServiceProviderUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateServiceProviderUnprocessableEntity from json.
func (s *UpdateServiceProviderUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceProviderUnprocessableEntity to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateServiceProviderUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceProviderUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceProviderUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSipGatewayBadRequest as json.
func (s *UpdateSipGatewayBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSipGatewayBadRequest from json.
func (s *UpdateSipGatewayBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSipGatewayBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSipGatewayBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSipGatewayBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSipGatewayBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSipGatewayInternalServerError as json.
func (s *UpdateSipGatewayInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSipGatewayInternalServerError from json.
func (s *UpdateSipGatewayInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSipGatewayInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSipGatewayInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSipGatewayInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSipGatewayInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSmppGatewayBadRequest as json.
func (s *UpdateSmppGatewayBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSmppGatewayBadRequest from json.
func (s *UpdateSmppGatewayBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSmppGatewayBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSmppGatewayBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSmppGatewayBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSmppGatewayBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSmppGatewayInternalServerError as json.
func (s *UpdateSmppGatewayInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSmppGatewayInternalServerError from json.
func (s *UpdateSmppGatewayInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSmppGatewayInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSmppGatewayInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSmppGatewayInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSmppGatewayInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserForbidden as json.
func (s *UpdateUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserForbidden from json.
func (s *UpdateUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserForbidden to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserInternalServerError as json.
func (s *UpdateUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserInternalServerError from json.
func (s *UpdateUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.EmailActivationCode.Set {
			e.FieldStart("email_activation_code")
			s.EmailActivationCode.Encode(e)
		}
	}
	{
		if s.OldPassword.Set {
			e.FieldStart("old_password")
			s.OldPassword.Encode(e)
		}
	}
	{
		if s.NewPassword.Set {
			e.FieldStart("new_password")
			s.NewPassword.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
	{
		if s.ForceChange.Set {
			e.FieldStart("force_change")
			s.ForceChange.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Permissions != nil {
			e.FieldStart("permissions")
			e.ArrStart()
			for _, elem := range s.Permissions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateUserReq = [9]string{
	0: "name",
	1: "email",
	2: "email_activation_code",
	3: "old_password",
	4: "new_password",
	5: "is_active",
	6: "force_change",
	7: "scope",
	8: "permissions",
}

// Decode decodes UpdateUserReq from json.
func (s *UpdateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "email_activation_code":
			if err := func() error {
				s.EmailActivationCode.Reset()
				if err := s.EmailActivationCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email_activation_code\"")
			}
		case "old_password":
			if err := func() error {
				s.OldPassword.Reset()
				if err := s.OldPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_password\"")
			}
		case "new_password":
			if err := func() error {
				s.NewPassword.Reset()
				if err := s.NewPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_password\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "force_change":
			if err := func() error {
				s.ForceChange.Reset()
				if err := s.ForceChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_change\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVoipCarrierBadRequest as json.
func (s *UpdateVoipCarrierBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVoipCarrierBadRequest from json.
func (s *UpdateVoipCarrierBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVoipCarrierBadRequest to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVoipCarrierBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVoipCarrierBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVoipCarrierBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVoipCarrierInternalServerError as json.
func (s *UpdateVoipCarrierInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVoipCarrierInternalServerError from json.
func (s *UpdateVoipCarrierInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVoipCarrierInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVoipCarrierInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVoipCarrierInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVoipCarrierInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetail) encodeFields(e *jx.Encoder) {
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Account.Set {
			e.FieldStart("account")
			s.Account.Encode(e)
		}
	}
	{
		if s.Testapp.Set {
			e.FieldStart("testapp")
			s.Testapp.Encode(e)
		}
	}
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
	{
		if s.Capacities.Set {
			e.FieldStart("capacities")
			s.Capacities.Encode(e)
		}
	}
	{
		if s.APIKeys != nil {
			e.FieldStart("api_keys")
			e.ArrStart()
			for _, elem := range s.APIKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Products != nil {
			e.FieldStart("products")
			e.ArrStart()
			for _, elem := range s.Products {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetail = [7]string{
	0: "user",
	1: "account",
	2: "testapp",
	3: "balance",
	4: "capacities",
	5: "api_keys",
	6: "products",
}

// Decode decodes UserAndAccountDetail from json.
func (s *UserAndAccountDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "account":
			if err := func() error {
				s.Account.Reset()
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "testapp":
			if err := func() error {
				s.Testapp.Reset()
				if err := s.Testapp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"testapp\"")
			}
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "capacities":
			if err := func() error {
				s.Capacities.Reset()
				if err := s.Capacities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacities\"")
			}
		case "api_keys":
			if err := func() error {
				s.APIKeys = make([]UserAndAccountDetailAPIKeysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserAndAccountDetailAPIKeysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.APIKeys = append(s.APIKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_keys\"")
			}
		case "products":
			if err := func() error {
				s.Products = make([]UserAndAccountDetailProductsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserAndAccountDetailProductsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Products = append(s.Products, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"products\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetailAPIKeysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetailAPIKeysItem) encodeFields(e *jx.Encoder) {
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
	{
		if s.LastUsed.Set {
			e.FieldStart("last_used")
			s.LastUsed.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetailAPIKeysItem = [3]string{
	0: "token",
	1: "last_used",
	2: "created_at",
}

// Decode decodes UserAndAccountDetailAPIKeysItem from json.
func (s *UserAndAccountDetailAPIKeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailAPIKeysItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "last_used":
			if err := func() error {
				s.LastUsed.Reset()
				if err := s.LastUsed.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_used\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetailAPIKeysItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetailAPIKeysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailAPIKeysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetailAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetailAccount) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.SipRealm.Set {
			e.FieldStart("sip_realm")
			s.SipRealm.Encode(e)
		}
	}
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
	{
		if s.RegistrationHookSid.Set {
			e.FieldStart("registration_hook_sid")
			s.RegistrationHookSid.Encode(e)
		}
	}
	{
		if s.QueueEventHookSid.Set {
			e.FieldStart("queue_event_hook_sid")
			s.QueueEventHookSid.Encode(e)
		}
	}
	{
		if s.DeviceCallingApplicationSid.Set {
			e.FieldStart("device_calling_application_sid")
			s.DeviceCallingApplicationSid.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetailAccount = [8]string{
	0: "account_sid",
	1: "sip_realm",
	2: "service_provider_sid",
	3: "registration_hook_sid",
	4: "queue_event_hook_sid",
	5: "device_calling_application_sid",
	6: "is_active",
	7: "created_at",
}

// Decode decodes UserAndAccountDetailAccount from json.
func (s *UserAndAccountDetailAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailAccount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "sip_realm":
			if err := func() error {
				s.SipRealm.Reset()
				if err := s.SipRealm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_realm\"")
			}
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "registration_hook_sid":
			if err := func() error {
				s.RegistrationHookSid.Reset()
				if err := s.RegistrationHookSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registration_hook_sid\"")
			}
		case "queue_event_hook_sid":
			if err := func() error {
				s.QueueEventHookSid.Reset()
				if err := s.QueueEventHookSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_event_hook_sid\"")
			}
		case "device_calling_application_sid":
			if err := func() error {
				s.DeviceCallingApplicationSid.Reset()
				if err := s.DeviceCallingApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"device_calling_application_sid\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetailAccount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetailAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetailBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetailBalance) encodeFields(e *jx.Encoder) {
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastTransactionID.Set {
			e.FieldStart("last_transaction_id")
			s.LastTransactionID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetailBalance = [5]string{
	0: "currency",
	1: "balance",
	2: "last_updated_at",
	3: "created_at",
	4: "last_transaction_id",
}

// Decode decodes UserAndAccountDetailBalance from json.
func (s *UserAndAccountDetailBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailBalance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_transaction_id":
			if err := func() error {
				s.LastTransactionID.Reset()
				if err := s.LastTransactionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_transaction_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetailBalance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetailBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAndAccountDetailBalanceCurrency as json.
func (s UserAndAccountDetailBalanceCurrency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserAndAccountDetailBalanceCurrency from json.
func (s *UserAndAccountDetailBalanceCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailBalanceCurrency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserAndAccountDetailBalanceCurrency(v) {
	case UserAndAccountDetailBalanceCurrencyUSD:
		*s = UserAndAccountDetailBalanceCurrencyUSD
	case UserAndAccountDetailBalanceCurrencyEUR:
		*s = UserAndAccountDetailBalanceCurrencyEUR
	default:
		*s = UserAndAccountDetailBalanceCurrency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserAndAccountDetailBalanceCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailBalanceCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetailCapacities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetailCapacities) encodeFields(e *jx.Encoder) {
	{
		if s.EffectiveStartDate.Set {
			e.FieldStart("effective_start_date")
			s.EffectiveStartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EffectiveEndDate.Set {
			e.FieldStart("effective_end_date")
			s.EffectiveEndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LimitSessions.Set {
			e.FieldStart("limit_sessions")
			s.LimitSessions.Encode(e)
		}
	}
	{
		if s.LimitRegistrations.Set {
			e.FieldStart("limit_registrations")
			s.LimitRegistrations.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetailCapacities = [4]string{
	0: "effective_start_date",
	1: "effective_end_date",
	2: "limit_sessions",
	3: "limit_registrations",
}

// Decode decodes UserAndAccountDetailCapacities from json.
func (s *UserAndAccountDetailCapacities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailCapacities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effective_start_date":
			if err := func() error {
				s.EffectiveStartDate.Reset()
				if err := s.EffectiveStartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_start_date\"")
			}
		case "effective_end_date":
			if err := func() error {
				s.EffectiveEndDate.Reset()
				if err := s.EffectiveEndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_end_date\"")
			}
		case "limit_sessions":
			if err := func() error {
				s.LimitSessions.Reset()
				if err := s.LimitSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit_sessions\"")
			}
		case "limit_registrations":
			if err := func() error {
				s.LimitRegistrations.Reset()
				if err := s.LimitRegistrations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit_registrations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetailCapacities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetailCapacities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailCapacities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetailProductsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetailProductsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.InStarterSet.Set {
			e.FieldStart("in_starter_set")
			s.InStarterSet.Encode(e)
		}
	}
	{
		if s.ProductSid.Set {
			e.FieldStart("product_sid")
			s.ProductSid.Encode(e)
		}
	}
	{
		if s.EffectiveStartDate.Set {
			e.FieldStart("effective_start_date")
			s.EffectiveStartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EffectiveEndDate.Set {
			e.FieldStart("effective_end_date")
			s.EffectiveEndDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetailProductsItem = [8]string{
	0: "name",
	1: "description",
	2: "category",
	3: "quantity",
	4: "in_starter_set",
	5: "product_sid",
	6: "effective_start_date",
	7: "effective_end_date",
}

// Decode decodes UserAndAccountDetailProductsItem from json.
func (s *UserAndAccountDetailProductsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailProductsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "in_starter_set":
			if err := func() error {
				s.InStarterSet.Reset()
				if err := s.InStarterSet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_starter_set\"")
			}
		case "product_sid":
			if err := func() error {
				s.ProductSid.Reset()
				if err := s.ProductSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_sid\"")
			}
		case "effective_start_date":
			if err := func() error {
				s.EffectiveStartDate.Reset()
				if err := s.EffectiveStartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_start_date\"")
			}
		case "effective_end_date":
			if err := func() error {
				s.EffectiveEndDate.Reset()
				if err := s.EffectiveEndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_end_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetailProductsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetailProductsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailProductsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetailTestapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetailTestapp) encodeFields(e *jx.Encoder) {
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallHookSid.Set {
			e.FieldStart("call_hook_sid")
			s.CallHookSid.Encode(e)
		}
	}
	{
		if s.CallStatusHookSid.Set {
			e.FieldStart("call_status_hook_sid")
			s.CallStatusHookSid.Encode(e)
		}
	}
	{
		if s.MessagingHookSid.Set {
			e.FieldStart("messaging_hook_sid")
			s.MessagingHookSid.Encode(e)
		}
	}
	{
		if s.SpeechSynthesisVendor.Set {
			e.FieldStart("speech_synthesis_vendor")
			s.SpeechSynthesisVendor.Encode(e)
		}
	}
	{
		if s.SpeechSynthesisLanguage.Set {
			e.FieldStart("speech_synthesis_language")
			s.SpeechSynthesisLanguage.Encode(e)
		}
	}
	{
		if s.SpeechSynthesisVoice.Set {
			e.FieldStart("speech_synthesis_voice")
			s.SpeechSynthesisVoice.Encode(e)
		}
	}
	{
		if s.SpeechRecognizerVendor.Set {
			e.FieldStart("speech_recognizer_vendor")
			s.SpeechRecognizerVendor.Encode(e)
		}
	}
	{
		if s.SpeechRecognizerLanguage.Set {
			e.FieldStart("speech_recognizer_language")
			s.SpeechRecognizerLanguage.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetailTestapp = [12]string{
	0:  "application_sid",
	1:  "name",
	2:  "service_provider_sid",
	3:  "account_sid",
	4:  "call_hook_sid",
	5:  "call_status_hook_sid",
	6:  "messaging_hook_sid",
	7:  "speech_synthesis_vendor",
	8:  "speech_synthesis_language",
	9:  "speech_synthesis_voice",
	10: "speech_recognizer_vendor",
	11: "speech_recognizer_language",
}

// Decode decodes UserAndAccountDetailTestapp from json.
func (s *UserAndAccountDetailTestapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailTestapp to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_hook_sid":
			if err := func() error {
				s.CallHookSid.Reset()
				if err := s.CallHookSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_hook_sid\"")
			}
		case "call_status_hook_sid":
			if err := func() error {
				s.CallStatusHookSid.Reset()
				if err := s.CallStatusHookSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_status_hook_sid\"")
			}
		case "messaging_hook_sid":
			if err := func() error {
				s.MessagingHookSid.Reset()
				if err := s.MessagingHookSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_hook_sid\"")
			}
		case "speech_synthesis_vendor":
			if err := func() error {
				s.SpeechSynthesisVendor.Reset()
				if err := s.SpeechSynthesisVendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_synthesis_vendor\"")
			}
		case "speech_synthesis_language":
			if err := func() error {
				s.SpeechSynthesisLanguage.Reset()
				if err := s.SpeechSynthesisLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_synthesis_language\"")
			}
		case "speech_synthesis_voice":
			if err := func() error {
				s.SpeechSynthesisVoice.Reset()
				if err := s.SpeechSynthesisVoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_synthesis_voice\"")
			}
		case "speech_recognizer_vendor":
			if err := func() error {
				s.SpeechRecognizerVendor.Reset()
				if err := s.SpeechRecognizerVendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_recognizer_vendor\"")
			}
		case "speech_recognizer_language":
			if err := func() error {
				s.SpeechRecognizerLanguage.Reset()
				if err := s.SpeechRecognizerLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speech_recognizer_language\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetailTestapp")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetailTestapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailTestapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAndAccountDetailUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAndAccountDetailUser) encodeFields(e *jx.Encoder) {
	{
		if s.UserSid.Set {
			e.FieldStart("user_sid")
			s.UserSid.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Phone.Set {
			e.FieldStart("phone")
			s.Phone.Encode(e)
		}
	}
	{
		if s.ServiceProviderSid.Set {
			e.FieldStart("service_provider_sid")
			s.ServiceProviderSid.Encode(e)
		}
	}
	{
		if s.ForceChange.Set {
			e.FieldStart("force_change")
			s.ForceChange.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.ProviderUserid.Set {
			e.FieldStart("provider_userid")
			s.ProviderUserid.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.EmailValidated.Set {
			e.FieldStart("email_validated")
			s.EmailValidated.Encode(e)
		}
	}
	{
		if s.PhoneValidated.Set {
			e.FieldStart("phone_validated")
			s.PhoneValidated.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAndAccountDetailUser = [11]string{
	0:  "user_sid",
	1:  "name",
	2:  "email",
	3:  "phone",
	4:  "service_provider_sid",
	5:  "force_change",
	6:  "provider",
	7:  "provider_userid",
	8:  "scope",
	9:  "email_validated",
	10: "phone_validated",
}

// Decode decodes UserAndAccountDetailUser from json.
func (s *UserAndAccountDetailUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAndAccountDetailUser to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_sid":
			if err := func() error {
				s.UserSid.Reset()
				if err := s.UserSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_sid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "phone":
			if err := func() error {
				s.Phone.Reset()
				if err := s.Phone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone\"")
			}
		case "service_provider_sid":
			if err := func() error {
				s.ServiceProviderSid.Reset()
				if err := s.ServiceProviderSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_provider_sid\"")
			}
		case "force_change":
			if err := func() error {
				s.ForceChange.Reset()
				if err := s.ForceChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_change\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "provider_userid":
			if err := func() error {
				s.ProviderUserid.Reset()
				if err := s.ProviderUserid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_userid\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "email_validated":
			if err := func() error {
				s.EmailValidated.Reset()
				if err := s.EmailValidated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email_validated\"")
			}
		case "phone_validated":
			if err := func() error {
				s.PhoneValidated.Reset()
				if err := s.PhoneValidated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_validated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAndAccountDetailUser")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAndAccountDetailUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAndAccountDetailUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserList) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
	{
		if s.ForceChange.Set {
			e.FieldStart("force_change")
			s.ForceChange.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Permissions != nil {
			e.FieldStart("permissions")
			e.ArrStart()
			for _, elem := range s.Permissions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUserList = [6]string{
	0: "name",
	1: "email",
	2: "is_active",
	3: "force_change",
	4: "scope",
	5: "permissions",
}

// Decode decodes UserList from json.
func (s *UserList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "force_change":
			if err := func() error {
				s.ForceChange.Reset()
				if err := s.ForceChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_change\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_sid")
		e.Str(s.UserSid)
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		e.FieldStart("is_active")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Phone.Set {
			e.FieldStart("phone")
			s.Phone.Encode(e)
		}
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("scope")
		s.Scope.Encode(e)
	}
	{
		e.FieldStart("pristine")
		e.Bool(s.Pristine)
	}
	{
		if s.EmailValidated.Set {
			e.FieldStart("email_validated")
			s.EmailValidated.Encode(e)
		}
	}
	{
		if s.PhoneValidated.Set {
			e.FieldStart("phone_validated")
			s.PhoneValidated.Encode(e)
		}
	}
	{
		if s.TutorialCompletion.Set {
			e.FieldStart("tutorial_completion")
			s.TutorialCompletion.Encode(e)
		}
	}
	{
		e.FieldStart("jwt")
		e.Str(s.Jwt)
	}
}

var jsonFieldsNameOfUserProfile = [13]string{
	0:  "user_sid",
	1:  "account_sid",
	2:  "is_active",
	3:  "name",
	4:  "email",
	5:  "phone",
	6:  "provider",
	7:  "scope",
	8:  "pristine",
	9:  "email_validated",
	10: "phone_validated",
	11: "tutorial_completion",
	12: "jwt",
}

// Decode decodes UserProfile from json.
func (s *UserProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UserSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_sid\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "is_active":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "phone":
			if err := func() error {
				s.Phone.Reset()
				if err := s.Phone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "scope":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "pristine":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Pristine = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pristine\"")
			}
		case "email_validated":
			if err := func() error {
				s.EmailValidated.Reset()
				if err := s.EmailValidated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email_validated\"")
			}
		case "phone_validated":
			if err := func() error {
				s.PhoneValidated.Reset()
				if err := s.PhoneValidated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_validated\"")
			}
		case "tutorial_completion":
			if err := func() error {
				s.TutorialCompletion.Reset()
				if err := s.TutorialCompletion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tutorial_completion\"")
			}
		case "jwt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Jwt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11011101,
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserProfile) {
					name = jsonFieldsNameOfUserProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserProfileProvider as json.
func (s UserProfileProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserProfileProvider from json.
func (s *UserProfileProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserProfileProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserProfileProvider(v) {
	case UserProfileProviderGithub:
		*s = UserProfileProviderGithub
	case UserProfileProviderGoogle:
		*s = UserProfileProviderGoogle
	case UserProfileProviderLocal:
		*s = UserProfileProviderLocal
	default:
		*s = UserProfileProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserProfileProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserProfileProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserProfileScope as json.
func (s UserProfileScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserProfileScope from json.
func (s *UserProfileScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserProfileScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserProfileScope(v) {
	case UserProfileScopeReadOnly:
		*s = UserProfileScopeReadOnly
	case UserProfileScopeReadWrite:
		*s = UserProfileScopeReadWrite
	default:
		*s = UserProfileScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserProfileScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserProfileScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateActivationCodeInternalServerError as json.
func (s *ValidateActivationCodeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateActivationCodeInternalServerError from json.
func (s *ValidateActivationCodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateActivationCodeInternalServerError to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateActivationCodeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateActivationCodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateActivationCodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateActivationCodeNotFound as json.
func (s *ValidateActivationCodeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*GeneralError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateActivationCodeNotFound from json.
func (s *ValidateActivationCodeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateActivationCodeNotFound to nil")
	}
	var unwrapped GeneralError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateActivationCodeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateActivationCodeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateActivationCodeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateActivationCodeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateActivationCodeReq) encodeFields(e *jx.Encoder) {
	{
		if s.UserSid.Set {
			e.FieldStart("user_sid")
			s.UserSid.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfValidateActivationCodeReq = [2]string{
	0: "user_sid",
	1: "type",
}

// Decode decodes ValidateActivationCodeReq from json.
func (s *ValidateActivationCodeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateActivationCodeReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_sid":
			if err := func() error {
				s.UserSid.Reset()
				if err := s.UserSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_sid\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateActivationCodeReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateActivationCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateActivationCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateActivationCodeReqType as json.
func (s ValidateActivationCodeReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValidateActivationCodeReqType from json.
func (s *ValidateActivationCodeReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateActivationCodeReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValidateActivationCodeReqType(v) {
	case ValidateActivationCodeReqTypeEmail:
		*s = ValidateActivationCodeReqTypeEmail
	case ValidateActivationCodeReqTypePhone:
		*s = ValidateActivationCodeReqTypePhone
	default:
		*s = ValidateActivationCodeReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidateActivationCodeReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateActivationCodeReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateInviteCodeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateInviteCodeReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfValidateInviteCodeReq = [1]string{
	0: "code",
}

// Decode decodes ValidateInviteCodeReq from json.
func (s *ValidateInviteCodeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateInviteCodeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateInviteCodeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidateInviteCodeReq) {
					name = jsonFieldsNameOfValidateInviteCodeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateInviteCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateInviteCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoipCarrier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoipCarrier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("voip_carrier_sid")
		json.EncodeUUID(e, s.VoipCarrierSid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.ApplicationSid.Set {
			e.FieldStart("application_sid")
			s.ApplicationSid.Encode(e)
		}
	}
	{
		if s.E164LeadingPlus.Set {
			e.FieldStart("e164_leading_plus")
			s.E164LeadingPlus.Encode(e)
		}
	}
	{
		if s.RequiresRegister.Set {
			e.FieldStart("requires_register")
			s.RequiresRegister.Encode(e)
		}
	}
	{
		if s.RegisterUsername.Set {
			e.FieldStart("register_username")
			s.RegisterUsername.Encode(e)
		}
	}
	{
		if s.RegisterSipRealm.Set {
			e.FieldStart("register_sip_realm")
			s.RegisterSipRealm.Encode(e)
		}
	}
	{
		if s.RegisterPassword.Set {
			e.FieldStart("register_password")
			s.RegisterPassword.Encode(e)
		}
	}
	{
		if s.TechPrefix.Set {
			e.FieldStart("tech_prefix")
			s.TechPrefix.Encode(e)
		}
	}
	{
		if s.InboundAuthUsername.Set {
			e.FieldStart("inbound_auth_username")
			s.InboundAuthUsername.Encode(e)
		}
	}
	{
		if s.InboundAuthPassword.Set {
			e.FieldStart("inbound_auth_password")
			s.InboundAuthPassword.Encode(e)
		}
	}
	{
		if s.Diversion.Set {
			e.FieldStart("diversion")
			s.Diversion.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
	{
		if s.SmppSystemID.Set {
			e.FieldStart("smpp_system_id")
			s.SmppSystemID.Encode(e)
		}
	}
	{
		if s.SmppPassword.Set {
			e.FieldStart("smpp_password")
			s.SmppPassword.Encode(e)
		}
	}
	{
		if s.SmppInboundSystemID.Set {
			e.FieldStart("smpp_inbound_system_id")
			s.SmppInboundSystemID.Encode(e)
		}
	}
	{
		if s.SmppInboundPassword.Set {
			e.FieldStart("smpp_inbound_password")
			s.SmppInboundPassword.Encode(e)
		}
	}
	{
		if s.SmppEnquireLinkInterval.Set {
			e.FieldStart("smpp_enquire_link_interval")
			s.SmppEnquireLinkInterval.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoipCarrier = [20]string{
	0:  "voip_carrier_sid",
	1:  "name",
	2:  "description",
	3:  "account_sid",
	4:  "application_sid",
	5:  "e164_leading_plus",
	6:  "requires_register",
	7:  "register_username",
	8:  "register_sip_realm",
	9:  "register_password",
	10: "tech_prefix",
	11: "inbound_auth_username",
	12: "inbound_auth_password",
	13: "diversion",
	14: "is_active",
	15: "smpp_system_id",
	16: "smpp_password",
	17: "smpp_inbound_system_id",
	18: "smpp_inbound_password",
	19: "smpp_enquire_link_interval",
}

// Decode decodes VoipCarrier from json.
func (s *VoipCarrier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoipCarrier to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "voip_carrier_sid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VoipCarrierSid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voip_carrier_sid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "application_sid":
			if err := func() error {
				s.ApplicationSid.Reset()
				if err := s.ApplicationSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_sid\"")
			}
		case "e164_leading_plus":
			if err := func() error {
				s.E164LeadingPlus.Reset()
				if err := s.E164LeadingPlus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"e164_leading_plus\"")
			}
		case "requires_register":
			if err := func() error {
				s.RequiresRegister.Reset()
				if err := s.RequiresRegister.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_register\"")
			}
		case "register_username":
			if err := func() error {
				s.RegisterUsername.Reset()
				if err := s.RegisterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_username\"")
			}
		case "register_sip_realm":
			if err := func() error {
				s.RegisterSipRealm.Reset()
				if err := s.RegisterSipRealm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_sip_realm\"")
			}
		case "register_password":
			if err := func() error {
				s.RegisterPassword.Reset()
				if err := s.RegisterPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"register_password\"")
			}
		case "tech_prefix":
			if err := func() error {
				s.TechPrefix.Reset()
				if err := s.TechPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tech_prefix\"")
			}
		case "inbound_auth_username":
			if err := func() error {
				s.InboundAuthUsername.Reset()
				if err := s.InboundAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_auth_username\"")
			}
		case "inbound_auth_password":
			if err := func() error {
				s.InboundAuthPassword.Reset()
				if err := s.InboundAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_auth_password\"")
			}
		case "diversion":
			if err := func() error {
				s.Diversion.Reset()
				if err := s.Diversion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diversion\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "smpp_system_id":
			if err := func() error {
				s.SmppSystemID.Reset()
				if err := s.SmppSystemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smpp_system_id\"")
			}
		case "smpp_password":
			if err := func() error {
				s.SmppPassword.Reset()
				if err := s.SmppPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smpp_password\"")
			}
		case "smpp_inbound_system_id":
			if err := func() error {
				s.SmppInboundSystemID.Reset()
				if err := s.SmppInboundSystemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smpp_inbound_system_id\"")
			}
		case "smpp_inbound_password":
			if err := func() error {
				s.SmppInboundPassword.Reset()
				if err := s.SmppInboundPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smpp_inbound_password\"")
			}
		case "smpp_enquire_link_interval":
			if err := func() error {
				s.SmppEnquireLinkInterval.Reset()
				if err := s.SmppEnquireLinkInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smpp_enquire_link_interval\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoipCarrier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoipCarrier) {
					name = jsonFieldsNameOfVoipCarrier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoipCarrier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoipCarrier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Webhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Webhook) encodeFields(e *jx.Encoder) {
	{
		if s.WebhookSid.Set {
			e.FieldStart("webhook_sid")
			s.WebhookSid.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("method")
		s.Method.Encode(e)
	}
	{
		e.FieldStart("username")
		s.Username.Encode(e)
	}
	{
		e.FieldStart("password")
		s.Password.Encode(e)
	}
}

var jsonFieldsNameOfWebhook = [5]string{
	0: "webhook_sid",
	1: "url",
	2: "method",
	3: "username",
	4: "password",
}

// Decode decodes Webhook from json.
func (s *Webhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Webhook to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "webhook_sid":
			if err := func() error {
				s.WebhookSid.Reset()
				if err := s.WebhookSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_sid\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "method":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Webhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhook) {
					name = jsonFieldsNameOfWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Webhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Webhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookMethod as json.
func (s WebhookMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookMethod from json.
func (s *WebhookMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookMethod(v) {
	case WebhookMethodGET:
		*s = WebhookMethodGET
	case WebhookMethodPOST:
		*s = WebhookMethodPOST
	default:
		*s = WebhookMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
