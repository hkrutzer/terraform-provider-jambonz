// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddLimitForAccount invokes addLimitForAccount operation.
	//
	// Create a limit for an account.
	//
	// POST /Accounts/{AccountSid}/Limits
	AddLimitForAccount(ctx context.Context, request OptLimits, params AddLimitForAccountParams) (AddLimitForAccountRes, error)
	// AddLimitForServiceProvider invokes addLimitForServiceProvider operation.
	//
	// Create a limit for a service provider.
	//
	// POST /ServiceProviders/{ServiceProviderSid}/Limits
	AddLimitForServiceProvider(ctx context.Context, request OptLimits, params AddLimitForServiceProviderParams) (AddLimitForServiceProviderRes, error)
	// AddSpeechCredentialForSeerviceProvider invokes addSpeechCredentialForSeerviceProvider operation.
	//
	// Create a speech credential for a service provider.
	//
	// POST /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/
	AddSpeechCredentialForSeerviceProvider(ctx context.Context, request OptSpeechCredential, params AddSpeechCredentialForSeerviceProviderParams) (AddSpeechCredentialForSeerviceProviderRes, error)
	// ApplicationsApplicationSidGet invokes GET /Applications/{ApplicationSid} operation.
	//
	// Retrieve an application.
	//
	// GET /Applications/{ApplicationSid}
	ApplicationsApplicationSidGet(ctx context.Context, params ApplicationsApplicationSidGetParams) (ApplicationsApplicationSidGetRes, error)
	// ChangePassword invokes changePassword operation.
	//
	// ChangePassword.
	//
	// POST /change-password
	ChangePassword(ctx context.Context, request OptChangePasswordReq) (ChangePasswordRes, error)
	// CheckAvailability invokes checkAvailability operation.
	//
	// Check if a limited-availability entity such as a subdomain, email or phone number is already in use.
	//
	// GET /Availability
	CheckAvailability(ctx context.Context, params CheckAvailabilityParams) (CheckAvailabilityRes, error)
	// CreateAccount invokes createAccount operation.
	//
	// Create an account.
	//
	// POST /Accounts
	CreateAccount(ctx context.Context, request OptCreateAccountReq) (CreateAccountRes, error)
	// CreateApikey invokes createApikey operation.
	//
	// Create an api key.
	//
	// POST /ApiKeys
	CreateApikey(ctx context.Context, request OptCreateApikeyReq) (CreateApikeyRes, error)
	// CreateApplication invokes createApplication operation.
	//
	// Create application.
	//
	// POST /Applications
	CreateApplication(ctx context.Context, request OptCreateApplicationReq) (CreateApplicationRes, error)
	// CreateCall invokes createCall operation.
	//
	// Create a call.
	//
	// POST /Accounts/{AccountSid}/Calls
	CreateCall(ctx context.Context, request OptCreateCallReq, params CreateCallParams) (CreateCallRes, error)
	// CreateCarrierForServiceProvider invokes createCarrierForServiceProvider operation.
	//
	// Create a carrier.
	//
	// POST /ServiceProviders/{ServiceProviderSid}/VoipCarriers
	CreateCarrierForServiceProvider(ctx context.Context, request OptVoipCarrier, params CreateCarrierForServiceProviderParams) (CreateCarrierForServiceProviderRes, error)
	// CreateGoogleCustomVoice invokes createGoogleCustomVoice operation.
	//
	// Create a Google custom voice.
	//
	// POST /GoogleCustomVoices
	CreateGoogleCustomVoice(ctx context.Context, request []GoogleCustomVoice) (CreateGoogleCustomVoiceRes, error)
	// CreateLcr invokes createLcr operation.
	//
	// Create a Least Cost Routing.
	//
	// POST /Lcrs
	CreateLcr(ctx context.Context, request OptCreateLcrReq) (CreateLcrRes, error)
	// CreateLcrCarrierSetEntry invokes createLcrCarrierSetEntry operation.
	//
	// Create a Least Cost Routing Carrier Set Entry.
	//
	// POST /LcrCarrierSetEntries
	CreateLcrCarrierSetEntry(ctx context.Context, request []LcrCarrierSetEntry) (CreateLcrCarrierSetEntryRes, error)
	// CreateLcrForServiceProvider invokes createLcrForServiceProvider operation.
	//
	// Create a Lest cost routing.
	//
	// POST /ServiceProviders/{ServiceProviderSid}/Lcrs
	CreateLcrForServiceProvider(ctx context.Context, request OptCreateLcrForServiceProviderReq, params CreateLcrForServiceProviderParams) (CreateLcrForServiceProviderRes, error)
	// CreateLcrRoutes invokes createLcrRoutes operation.
	//
	// Create a Least Cost Routing Routes.
	//
	// POST /LcrRoutes
	CreateLcrRoutes(ctx context.Context, request []LcrRoute) (CreateLcrRoutesRes, error)
	// CreateLeastCostRoutingRoutesAndCarrierEntries invokes createLeastCostRoutingRoutesAndCarrierEntries operation.
	//
	// Create least cost routing routes and carrier set entries.
	//
	// POST /Lcrs/{LcrSid}/Routes
	CreateLeastCostRoutingRoutesAndCarrierEntries(ctx context.Context, request LcrRoutes, params CreateLeastCostRoutingRoutesAndCarrierEntriesParams) (CreateLeastCostRoutingRoutesAndCarrierEntriesRes, error)
	// CreateMessage invokes createMessage operation.
	//
	// Create an outgoing SMS message.
	//
	// POST /Accounts/{AccountSid}/Messages
	CreateMessage(ctx context.Context, request OptMessage, params CreateMessageParams) (CreateMessageRes, error)
	// CreateMsTeamsTenant invokes createMsTeamsTenant operation.
	//
	// Provision a customer tenant for MS Teams.
	//
	// POST /MicrosoftTeamsTenants
	CreateMsTeamsTenant(ctx context.Context, request OptCreateMsTeamsTenantReq) (CreateMsTeamsTenantRes, error)
	// CreateSbc invokes createSbc operation.
	//
	// Add an SBC address.
	//
	// POST /Sbcs
	CreateSbc(ctx context.Context, request OptCreateSbcReq) (CreateSbcRes, error)
	// CreateServiceProvider invokes createServiceProvider operation.
	//
	// Create service provider.
	//
	// POST /ServiceProviders
	CreateServiceProvider(ctx context.Context, request OptCreateServiceProviderReq) (CreateServiceProviderRes, error)
	// CreateSipGateway invokes createSipGateway operation.
	//
	// Create sip gateway.
	//
	// POST /SipGateways
	CreateSipGateway(ctx context.Context, request OptCreateSipGatewayReq) (CreateSipGatewayRes, error)
	// CreateSipRealm invokes createSipRealm operation.
	//
	// Add or change the sip realm.
	//
	// POST /Accounts/{AccountSid}/SipRealms/{SipRealm}
	CreateSipRealm(ctx context.Context, params CreateSipRealmParams) (CreateSipRealmRes, error)
	// CreateSmppGateway invokes createSmppGateway operation.
	//
	// Create smpp gateway.
	//
	// POST /SmppGateways
	CreateSmppGateway(ctx context.Context, request OptCreateSmppGatewayReq) (CreateSmppGatewayRes, error)
	// CreateSpeechCredential invokes createSpeechCredential operation.
	//
	// Add a speech credential.
	//
	// POST /Accounts/{AccountSid}/SpeechCredentials
	CreateSpeechCredential(ctx context.Context, request OptSpeechCredential, params CreateSpeechCredentialParams) (CreateSpeechCredentialRes, error)
	// CreateUser invokes createUser operation.
	//
	// Create a new user.
	//
	// POST /Users/{UserSid}
	CreateUser(ctx context.Context, request OptCreateUserReq, params CreateUserParams) (CreateUserRes, error)
	// CreateVoipCarrier invokes createVoipCarrier operation.
	//
	// Create voip carrier.
	//
	// POST /VoipCarriers
	CreateVoipCarrier(ctx context.Context, request OptCreateVoipCarrierReq) (CreateVoipCarrierRes, error)
	// CreateVoipCarrierFromTemplate invokes createVoipCarrierFromTemplate operation.
	//
	// Add a VoiPCarrier to an account based on PredefinedCarrier template.
	//
	// POST /Accounts/{AccountSid}/PredefinedCarriers/{PredefinedCarrierSid}
	CreateVoipCarrierFromTemplate(ctx context.Context, params CreateVoipCarrierFromTemplateParams) (CreateVoipCarrierFromTemplateRes, error)
	// CreateVoipCarrierFromTemplateBySP invokes createVoipCarrierFromTemplateBySP operation.
	//
	// Add a VoiPCarrier to a service provider based on PredefinedCarrier template.
	//
	// POST /ServiceProviders/{ServiceProviderSid}/PredefinedCarriers/{PredefinedCarrierSid}
	CreateVoipCarrierFromTemplateBySP(ctx context.Context, params CreateVoipCarrierFromTemplateBySPParams) (CreateVoipCarrierFromTemplateBySPRes, error)
	// DeleteAccount invokes deleteAccount operation.
	//
	// Delete an account.
	//
	// DELETE /Accounts/{AccountSid}
	DeleteAccount(ctx context.Context, params DeleteAccountParams) (DeleteAccountRes, error)
	// DeleteApiKey invokes deleteApiKey operation.
	//
	// Delete api key.
	//
	// DELETE /ApiKeys/{ApiKeySid}
	DeleteApiKey(ctx context.Context, params DeleteApiKeyParams) (DeleteApiKeyRes, error)
	// DeleteApplication invokes deleteApplication operation.
	//
	// Delete an application.
	//
	// DELETE /Applications/{ApplicationSid}
	DeleteApplication(ctx context.Context, params DeleteApplicationParams) (DeleteApplicationRes, error)
	// DeleteCall invokes deleteCall operation.
	//
	// Delete a call.
	//
	// DELETE /Accounts/{AccountSid}/Calls/{CallSid}
	DeleteCall(ctx context.Context, params DeleteCallParams) (DeleteCallRes, error)
	// DeleteGoogleCustomVoice invokes deleteGoogleCustomVoice operation.
	//
	// Delete a google custom voice.
	//
	// DELETE /GoogleCustomVoices/{GoogleCustomVoiceSid}
	DeleteGoogleCustomVoice(ctx context.Context, params DeleteGoogleCustomVoiceParams) (DeleteGoogleCustomVoiceRes, error)
	// DeleteLeastCostRouting invokes deleteLeastCostRouting operation.
	//
	// Delete a least cost routing.
	//
	// DELETE /Lcrs/{LcrSid}
	DeleteLeastCostRouting(ctx context.Context, params DeleteLeastCostRoutingParams) (DeleteLeastCostRoutingRes, error)
	// DeleteLeastCostRoutingCarrierSetEntry invokes deleteLeastCostRoutingCarrierSetEntry operation.
	//
	// Delete a least cost routing carrier set entry.
	//
	// DELETE /LcrCarrierSetEntries/{LcrCarrierSetEntrySid}
	DeleteLeastCostRoutingCarrierSetEntry(ctx context.Context, params DeleteLeastCostRoutingCarrierSetEntryParams) (DeleteLeastCostRoutingCarrierSetEntryRes, error)
	// DeleteLeastCostRoutingRoute invokes deleteLeastCostRoutingRoute operation.
	//
	// Delete a least cost routing route.
	//
	// DELETE /LcrRoutes/{LcrRouteSid}
	DeleteLeastCostRoutingRoute(ctx context.Context, params DeleteLeastCostRoutingRouteParams) (DeleteLeastCostRoutingRouteRes, error)
	// DeletePhoneNumber invokes deletePhoneNumber operation.
	//
	// Delete a phone number.
	//
	// DELETE /PhoneNumbers/{PhoneNumberSid}
	DeletePhoneNumber(ctx context.Context, params DeletePhoneNumberParams) (DeletePhoneNumberRes, error)
	// DeleteSbcAddress invokes deleteSbcAddress operation.
	//
	// Delete SBC address.
	//
	// DELETE /Sbcs/{SbcSid}
	DeleteSbcAddress(ctx context.Context, params DeleteSbcAddressParams) (DeleteSbcAddressRes, error)
	// DeleteServiceProvider invokes deleteServiceProvider operation.
	//
	// Delete a service provider.
	//
	// DELETE /ServiceProviders/{ServiceProviderSid}
	DeleteServiceProvider(ctx context.Context, params DeleteServiceProviderParams) (DeleteServiceProviderRes, error)
	// DeleteSipGateway invokes deleteSipGateway operation.
	//
	// Delete a sip gateway.
	//
	// DELETE /SipGateways/{SipGatewaySid}
	DeleteSipGateway(ctx context.Context, params DeleteSipGatewayParams) (DeleteSipGatewayRes, error)
	// DeleteSmppGateway invokes deleteSmppGateway operation.
	//
	// Delete a smpp gateway.
	//
	// DELETE /SmppGateways/{SmppGatewaySid}
	DeleteSmppGateway(ctx context.Context, params DeleteSmppGatewayParams) (DeleteSmppGatewayRes, error)
	// DeleteSpeechCredential invokes deleteSpeechCredential operation.
	//
	// Delete a speech credential.
	//
	// DELETE /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}
	DeleteSpeechCredential(ctx context.Context, params DeleteSpeechCredentialParams) (DeleteSpeechCredentialRes, error)
	// DeleteSpeechCredentialByAccount invokes deleteSpeechCredentialByAccount operation.
	//
	// Delete a speech credential.
	//
	// DELETE /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}
	DeleteSpeechCredentialByAccount(ctx context.Context, params DeleteSpeechCredentialByAccountParams) (DeleteSpeechCredentialByAccountRes, error)
	// DeleteTenant invokes deleteTenant operation.
	//
	// Delete an MS Teams tenant.
	//
	// DELETE /MicrosoftTeamsTenants/{TenantSid}
	DeleteTenant(ctx context.Context, params DeleteTenantParams) (DeleteTenantRes, error)
	// DeleteUser invokes deleteUser operation.
	//
	// Delete a user.
	//
	// DELETE /Users/{UserSid}
	DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error)
	// DeleteVoipCarrier invokes deleteVoipCarrier operation.
	//
	// Delete a voip carrier.
	//
	// DELETE /VoipCarriers/{VoipCarrierSid}
	DeleteVoipCarrier(ctx context.Context, params DeleteVoipCarrierParams) (DeleteVoipCarrierRes, error)
	// ForgotPassword invokes forgotPassword operation.
	//
	// Send link to reset password.
	//
	// POST /forgot-password
	ForgotPassword(ctx context.Context, request OptForgotPasswordReq) (ForgotPasswordRes, error)
	// GenerateInviteCode invokes generateInviteCode operation.
	//
	// Generate one or more beta invite codes.
	//
	// POST /BetaInviteCodes
	GenerateInviteCode(ctx context.Context, request OptGenerateInviteCodeReq) (GenerateInviteCodeRes, error)
	// GetAccount invokes getAccount operation.
	//
	// Retrieve account.
	//
	// GET /Accounts/{AccountSid}
	GetAccount(ctx context.Context, params GetAccountParams) (GetAccountRes, error)
	// GetAccountApiKeys invokes getAccountApiKeys operation.
	//
	// Get all api keys for an account.
	//
	// GET /Accounts/{AccountSid}/ApiKeys
	GetAccountApiKeys(ctx context.Context, params GetAccountApiKeysParams) (GetAccountApiKeysRes, error)
	// GetAccountLimits invokes getAccountLimits operation.
	//
	// Retrieve call capacity and other limits from the account.
	//
	// GET /Accounts/{AccountSid}/Limits
	GetAccountLimits(ctx context.Context, params GetAccountLimitsParams) (GetAccountLimitsRes, error)
	// GetCall invokes getCall operation.
	//
	// Retrieve a call.
	//
	// GET /Accounts/{AccountSid}/Calls/{CallSid}
	GetCall(ctx context.Context, params GetCallParams) (GetCallRes, error)
	// GetGoogleCustomVoice invokes getGoogleCustomVoice operation.
	//
	// Retrieve google custom voice.
	//
	// GET /GoogleCustomVoices/{GoogleCustomVoiceSid}
	GetGoogleCustomVoice(ctx context.Context, params GetGoogleCustomVoiceParams) (GetGoogleCustomVoiceRes, error)
	// GetLeastCostRouting invokes getLeastCostRouting operation.
	//
	// Retrieve least cost routing.
	//
	// GET /Lcrs/{LcrSid}
	GetLeastCostRouting(ctx context.Context, params GetLeastCostRoutingParams) (GetLeastCostRoutingRes, error)
	// GetLeastCostRoutingCarrierSetEntry invokes getLeastCostRoutingCarrierSetEntry operation.
	//
	// Retrieve least cost routing carrier set entry.
	//
	// GET /LcrCarrierSetEntries/{LcrCarrierSetEntrySid}
	GetLeastCostRoutingCarrierSetEntry(ctx context.Context, params GetLeastCostRoutingCarrierSetEntryParams) (GetLeastCostRoutingCarrierSetEntryRes, error)
	// GetLeastCostRoutingRoute invokes getLeastCostRoutingRoute operation.
	//
	// Retrieve least cost routing route.
	//
	// GET /LcrRoutes/{LcrRouteSid}
	GetLeastCostRoutingRoute(ctx context.Context, params GetLeastCostRoutingRouteParams) (GetLeastCostRoutingRouteRes, error)
	// GetMyDetails invokes getMyDetails operation.
	//
	// Retrieve details about logged-in user and associated account.
	//
	// GET /Users/me
	GetMyDetails(ctx context.Context) (GetMyDetailsRes, error)
	// GetPhoneNumber invokes getPhoneNumber operation.
	//
	// Retrieve phone number.
	//
	// GET /PhoneNumbers/{PhoneNumberSid}
	GetPhoneNumber(ctx context.Context, params GetPhoneNumberParams) (GetPhoneNumberRes, error)
	// GetRecentCallTrace invokes getRecentCallTrace operation.
	//
	// Retrieve sip trace detail for a call.
	//
	// GET /Accounts/{AccountSid}/RecentCalls/{CallId}
	GetRecentCallTrace(ctx context.Context, params GetRecentCallTraceParams) (GetRecentCallTraceRes, error)
	// GetRecentCallTraceByAccount invokes getRecentCallTraceByAccount operation.
	//
	// Retrieve pcap for a call.
	//
	// GET /Accounts/{AccountSid}/RecentCalls/{CallId}/pcap
	GetRecentCallTraceByAccount(ctx context.Context, params GetRecentCallTraceByAccountParams) (GetRecentCallTraceByAccountRes, error)
	// GetRecentCallTraceByCallId invokes getRecentCallTraceByCallId operation.
	//
	// Retrieve sip trace detail for a call.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/RecentCalls/{CallId}
	GetRecentCallTraceByCallId(ctx context.Context, params GetRecentCallTraceByCallIdParams) (GetRecentCallTraceByCallIdRes, error)
	// GetRecentCallTraceBySP invokes getRecentCallTraceBySP operation.
	//
	// Retrieve pcap for a call.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/RecentCalls/{CallId}/pcap
	GetRecentCallTraceBySP(ctx context.Context, params GetRecentCallTraceBySPParams) (GetRecentCallTraceBySPRes, error)
	// GetRegisteredClient invokes getRegisteredClient operation.
	//
	// Retrieve registered client registration.
	//
	// GET /Accounts/{AccountSid}/RegisteredSipUsers/{Client}
	GetRegisteredClient(ctx context.Context, params GetRegisteredClientParams) (*RegisteredClient, error)
	// GetServiceProvider invokes getServiceProvider operation.
	//
	// Retrieve service provider.
	//
	// GET /ServiceProviders/{ServiceProviderSid}
	GetServiceProvider(ctx context.Context, params GetServiceProviderParams) (GetServiceProviderRes, error)
	// GetServiceProviderAccounts invokes getServiceProviderAccounts operation.
	//
	// Get all accounts for a service provider.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/Accounts
	GetServiceProviderAccounts(ctx context.Context, params GetServiceProviderAccountsParams) (GetServiceProviderAccountsRes, error)
	// GetServiceProviderCarriers invokes getServiceProviderCarriers operation.
	//
	// Get all carriers for a service provider.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/VoipCarriers
	GetServiceProviderCarriers(ctx context.Context, params GetServiceProviderCarriersParams) (GetServiceProviderCarriersRes, error)
	// GetServiceProviderLcrs invokes getServiceProviderLcrs operation.
	//
	// Get all Least Cost Routings for a service provider.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/Lcrs
	GetServiceProviderLcrs(ctx context.Context, params GetServiceProviderLcrsParams) (GetServiceProviderLcrsRes, error)
	// GetServiceProviderLimits invokes getServiceProviderLimits operation.
	//
	// Retrieve call capacity and other limits from the service provider.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/Limits
	GetServiceProviderLimits(ctx context.Context, params GetServiceProviderLimitsParams) (GetServiceProviderLimitsRes, error)
	// GetSipGateway invokes getSipGateway operation.
	//
	// Retrieve sip gateway.
	//
	// GET /SipGateways/{SipGatewaySid}
	GetSipGateway(ctx context.Context, params GetSipGatewayParams) (GetSipGatewayRes, error)
	// GetSmppGateway invokes getSmppGateway operation.
	//
	// Retrieve smpp gateway.
	//
	// GET /SmppGateways/{SmppGatewaySid}
	GetSmppGateway(ctx context.Context, params GetSmppGatewayParams) (GetSmppGatewayRes, error)
	// GetSpeechCredential invokes getSpeechCredential operation.
	//
	// Get a specific speech credential.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}
	GetSpeechCredential(ctx context.Context, params GetSpeechCredentialParams) (GetSpeechCredentialRes, error)
	// GetSpeechCredentialByAccount invokes getSpeechCredentialByAccount operation.
	//
	// Get a specific speech credential.
	//
	// GET /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}
	GetSpeechCredentialByAccount(ctx context.Context, params GetSpeechCredentialByAccountParams) (GetSpeechCredentialByAccountRes, error)
	// GetStripeCustomerId invokes getStripeCustomerId operation.
	//
	// Retrieve stripe customer id for an account, creating if necessary.
	//
	// GET /StripeCustomerId
	GetStripeCustomerId(ctx context.Context) (GetStripeCustomerIdRes, error)
	// GetSubscription invokes getSubscription operation.
	//
	// Get subscription details from stripe.
	//
	// GET /Subscriptions
	GetSubscription(ctx context.Context) error
	// GetTenant invokes getTenant operation.
	//
	// Retrieve an MS Teams tenant.
	//
	// GET /MicrosoftTeamsTenants/{TenantSid}
	GetTenant(ctx context.Context, params GetTenantParams) (GetTenantRes, error)
	// GetTestData invokes getTestData operation.
	//
	// Get test phone numbers and applications.
	//
	// GET /AccountTest/{ServiceProviderSid}
	GetTestData(ctx context.Context, params GetTestDataParams) (GetTestDataRes, error)
	// GetUser invokes getUser operation.
	//
	// Retrieve user information.
	//
	// GET /Users/{UserSid}
	GetUser(ctx context.Context, params GetUserParams) (GetUserRes, error)
	// GetVoipCarrier invokes getVoipCarrier operation.
	//
	// Retrieve voip carrier.
	//
	// GET /VoipCarriers/{VoipCarrierSid}
	GetVoipCarrier(ctx context.Context, params GetVoipCarrierParams) (GetVoipCarrierRes, error)
	// GetWebhook invokes getWebhook operation.
	//
	// Retrieve webhook.
	//
	// GET /Webhooks/{WebhookSid}
	GetWebhook(ctx context.Context, params GetWebhookParams) (GetWebhookRes, error)
	// GetWebhookSecret invokes getWebhookSecret operation.
	//
	// Get webhook signing secret, regenerating if requested.
	//
	// GET /Accounts/{AccountSid}/WebhookSecret
	GetWebhookSecret(ctx context.Context, params GetWebhookSecretParams) (GetWebhookSecretRes, error)
	// ListAccounts invokes listAccounts operation.
	//
	// List accounts.
	//
	// GET /Accounts
	ListAccounts(ctx context.Context) (ListAccountsRes, error)
	// ListAlerts invokes listAlerts operation.
	//
	// Retrieve alerts for a service provider.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/Alerts
	ListAlerts(ctx context.Context, params ListAlertsParams) (ListAlertsRes, error)
	// ListAlertsByAccount invokes listAlertsByAccount operation.
	//
	// Retrieve alerts for an account.
	//
	// GET /Accounts/{AccountSid}/Alerts
	ListAlertsByAccount(ctx context.Context, params ListAlertsByAccountParams) (ListAlertsByAccountRes, error)
	// ListApplications invokes listApplications operation.
	//
	// List applications.
	//
	// GET /Applications
	ListApplications(ctx context.Context) (ListApplicationsRes, error)
	// ListCalls invokes listCalls operation.
	//
	// List calls.
	//
	// GET /Accounts/{AccountSid}/Calls
	ListCalls(ctx context.Context, params ListCallsParams) (ListCallsRes, error)
	// ListConferences invokes listConferences operation.
	//
	// List conferences.
	//
	// GET /Accounts/{AccountSid}/Conferences
	ListConferences(ctx context.Context, params ListConferencesParams) (ListConferencesRes, error)
	// ListGoogleCustomVoices invokes listGoogleCustomVoices operation.
	//
	// List google custom voices.
	//
	// GET /GoogleCustomVoices
	ListGoogleCustomVoices(ctx context.Context, params ListGoogleCustomVoicesParams) (ListGoogleCustomVoicesRes, error)
	// ListLeastCostRoutingCarrierSetEntries invokes listLeastCostRoutingCarrierSetEntries operation.
	//
	// List least cost routings routes.
	//
	// GET /LcrCarrierSetEntries
	ListLeastCostRoutingCarrierSetEntries(ctx context.Context) (ListLeastCostRoutingCarrierSetEntriesRes, error)
	// ListLeastCostRoutingRoutes invokes listLeastCostRoutingRoutes operation.
	//
	// List least cost routings routes.
	//
	// GET /LcrRoutes
	ListLeastCostRoutingRoutes(ctx context.Context) (ListLeastCostRoutingRoutesRes, error)
	// ListLeastCostRoutings invokes listLeastCostRoutings operation.
	//
	// List least cost routings.
	//
	// GET /Lcrs
	ListLeastCostRoutings(ctx context.Context) (ListLeastCostRoutingsRes, error)
	// ListMsTeamsTenants invokes listMsTeamsTenants operation.
	//
	// List MS Teams tenants.
	//
	// GET /MicrosoftTeamsTenants
	ListMsTeamsTenants(ctx context.Context) (ListMsTeamsTenantsRes, error)
	// ListPredefinedCarriers invokes listPredefinedCarriers operation.
	//
	// Get a list of predefined carriers.
	//
	// GET /PredefinedCarriers
	ListPredefinedCarriers(ctx context.Context) ([]PredefinedCarrier, error)
	// ListPrices invokes listPrices operation.
	//
	// List all prices.
	//
	// GET /Prices
	ListPrices(ctx context.Context) (*Product, error)
	// ListProvisionedPhoneNumbers invokes listProvisionedPhoneNumbers operation.
	//
	// List phone numbers.
	//
	// GET /PhoneNumbers
	ListProvisionedPhoneNumbers(ctx context.Context) (ListProvisionedPhoneNumbersRes, error)
	// ListQueues invokes listQueues operation.
	//
	// Retrieve active queues for an account.
	//
	// GET /Accounts/{AccountSid}/Queues
	ListQueues(ctx context.Context, params ListQueuesParams) ([]ListQueuesOKItem, error)
	// ListRecentCalls invokes listRecentCalls operation.
	//
	// Retrieve recent calls for an account.
	//
	// GET /Accounts/{AccountSid}/RecentCalls
	ListRecentCalls(ctx context.Context, params ListRecentCallsParams) (ListRecentCallsRes, error)
	// ListRecentCallsBySP invokes listRecentCallsBySP operation.
	//
	// Retrieve recent calls for an account.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/RecentCalls
	ListRecentCallsBySP(ctx context.Context, params ListRecentCallsBySPParams) (ListRecentCallsBySPRes, error)
	// ListRegisteredSipUsers invokes listRegisteredSipUsers operation.
	//
	// Retrieve online sip users for an account.
	//
	// GET /Accounts/{AccountSid}/RegisteredSipUsers
	ListRegisteredSipUsers(ctx context.Context, params ListRegisteredSipUsersParams) ([]string, error)
	// ListRegisteredSipUsersByUsername invokes listRegisteredSipUsersByUsername operation.
	//
	// Retrieve online sip users for an account by list of sip username.
	//
	// POST /Accounts/{AccountSid}/RegisteredSipUsers
	ListRegisteredSipUsersByUsername(ctx context.Context, request []string, params ListRegisteredSipUsersByUsernameParams) ([]RegisteredClient, error)
	// ListSbcs invokes listSbcs operation.
	//
	// Retrieve public IP addresses of the jambonz SBCs.
	//
	// GET /Sbcs
	ListSbcs(ctx context.Context, params ListSbcsParams) (ListSbcsRes, error)
	// ListServiceProviders invokes listServiceProviders operation.
	//
	// List service providers.
	//
	// GET /ServiceProviders
	ListServiceProviders(ctx context.Context) (ListServiceProvidersRes, error)
	// ListSipGateways invokes listSipGateways operation.
	//
	// List sip gateways.
	//
	// GET /SipGateways
	ListSipGateways(ctx context.Context, params ListSipGatewaysParams) (ListSipGatewaysRes, error)
	// ListSmppGateways invokes listSmppGateways operation.
	//
	// List smpp gateways.
	//
	// GET /SmppGateways
	ListSmppGateways(ctx context.Context) (ListSmppGatewaysRes, error)
	// ListSmpps invokes listSmpps operation.
	//
	// Retrieve public IP addresses of the jambonz smpp servers.
	//
	// GET /Smpps
	ListSmpps(ctx context.Context, params ListSmppsParams) (ListSmppsRes, error)
	// ListSpeechCredentials invokes listSpeechCredentials operation.
	//
	// Retrieve all speech credentials for an account.
	//
	// GET /Accounts/{AccountSid}/SpeechCredentials
	ListSpeechCredentials(ctx context.Context, params ListSpeechCredentialsParams) (ListSpeechCredentialsRes, error)
	// ListUsers invokes listUsers operation.
	//
	// List all users.
	//
	// GET /Users
	ListUsers(ctx context.Context) (ListUsersRes, error)
	// ListVoipCarriers invokes listVoipCarriers operation.
	//
	// List voip carriers.
	//
	// GET /VoipCarriers
	ListVoipCarriers(ctx context.Context) (ListVoipCarriersRes, error)
	// Login invokes login operation.
	//
	// Login and retrieve a JWT.
	//
	// POST /login
	Login(ctx context.Context, request OptLogin) (LoginRes, error)
	// LoginUser invokes loginUser operation.
	//
	// Sign in using email and password.
	//
	// POST /signin
	LoginUser(ctx context.Context, request OptLoginUserReq) (LoginUserRes, error)
	// LogoutUser invokes logoutUser operation.
	//
	// Log out and deactivate the JWT.
	//
	// POST /logout
	LogoutUser(ctx context.Context) (LogoutUserRes, error)
	// ManageSubscription invokes manageSubscription operation.
	//
	// Create or modify subscriptions in Stripe for a customer.
	//
	// POST /Subscriptions
	ManageSubscription(ctx context.Context, request OptManageSubscriptionReq) (ManageSubscriptionRes, error)
	// ProvisionPhoneNumber invokes provisionPhoneNumber operation.
	//
	// Provision a phone number into inventory from a Voip Carrier.
	//
	// POST /PhoneNumbers
	ProvisionPhoneNumber(ctx context.Context, request OptProvisionPhoneNumberReq) (ProvisionPhoneNumberRes, error)
	// PutTenant invokes putTenant operation.
	//
	// Update an MS Teams tenant.
	//
	// PUT /MicrosoftTeamsTenants/{TenantSid}
	PutTenant(ctx context.Context, request OptMsTeamsTenant, params PutTenantParams) (PutTenantRes, error)
	// RegisterUser invokes registerUser operation.
	//
	// Create a new user and account.
	//
	// POST /register
	RegisterUser(ctx context.Context, request OptRegisterUserReq) (RegisterUserRes, error)
	// RetrieveInvoice invokes retrieveInvoice operation.
	//
	// Retrieve upcoming invoice for customer.
	//
	// GET /Invoices
	RetrieveInvoice(ctx context.Context) (RetrieveInvoiceRes, error)
	// SendActivationCode invokes sendActivationCode operation.
	//
	// Send an activation code to the user.
	//
	// POST /ActivationCode
	SendActivationCode(ctx context.Context, request OptSendActivationCodeReq) (SendActivationCodeRes, error)
	// SupportedLanguagesAndVoices invokes supportedLanguagesAndVoices operation.
	//
	// Get supported languages, voices and models.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/speech/supportedLanguagesAndVoices
	SupportedLanguagesAndVoices(ctx context.Context, params SupportedLanguagesAndVoicesParams) (SupportedLanguagesAndVoicesRes, error)
	// SupportedLanguagesAndVoicesByAccount invokes supportedLanguagesAndVoicesByAccount operation.
	//
	// Get supported languages, voices and models.
	//
	// GET /Accounts/{AccountSid}/SpeechCredentials/speech/supportedLanguagesAndVoices
	SupportedLanguagesAndVoicesByAccount(ctx context.Context, params SupportedLanguagesAndVoicesByAccountParams) (SupportedLanguagesAndVoicesByAccountRes, error)
	// Synthesize invokes Synthesize operation.
	//
	// Get TTS from provider.
	//
	// POST /Accounts/{AccountSid}/TtsCache/Synthesize
	Synthesize(ctx context.Context, request OptSynthesizeReq, params SynthesizeParams) (SynthesizeRes, error)
	// TestSpeechCredential invokes testSpeechCredential operation.
	//
	// Test a speech credential.
	//
	// GET /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}/test
	TestSpeechCredential(ctx context.Context, params TestSpeechCredentialParams) (TestSpeechCredentialRes, error)
	// TestSpeechCredentialByAccount invokes testSpeechCredentialByAccount operation.
	//
	// Test a speech credential.
	//
	// GET /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}/test
	TestSpeechCredentialByAccount(ctx context.Context, params TestSpeechCredentialByAccountParams) (TestSpeechCredentialByAccountRes, error)
	// UpdateAccount invokes updateAccount operation.
	//
	// Update account.
	//
	// PUT /Accounts/{AccountSid}
	UpdateAccount(ctx context.Context, request OptAccount, params UpdateAccountParams) (UpdateAccountRes, error)
	// UpdateApplication invokes updateApplication operation.
	//
	// Update application.
	//
	// PUT /Applications/{ApplicationSid}
	UpdateApplication(ctx context.Context, request OptApplication, params UpdateApplicationParams) (UpdateApplicationRes, error)
	// UpdateCall invokes updateCall operation.
	//
	// Update a call.
	//
	// POST /Accounts/{AccountSid}/Calls/{CallSid}
	UpdateCall(ctx context.Context, request OptUpdateCallReq, params UpdateCallParams) (UpdateCallRes, error)
	// UpdateGoogleCustomVoice invokes updateGoogleCustomVoice operation.
	//
	// Update google custom voice.
	//
	// PUT /GoogleCustomVoices/{GoogleCustomVoiceSid}
	UpdateGoogleCustomVoice(ctx context.Context, request OptGoogleCustomVoice, params UpdateGoogleCustomVoiceParams) (UpdateGoogleCustomVoiceRes, error)
	// UpdateLeastCostRouting invokes updateLeastCostRouting operation.
	//
	// Update least cost routing.
	//
	// PUT /Lcrs/{LcrSid}
	UpdateLeastCostRouting(ctx context.Context, request OptLcr, params UpdateLeastCostRoutingParams) (UpdateLeastCostRoutingRes, error)
	// UpdateLeastCostRoutingCarrierSetEntry invokes updateLeastCostRoutingCarrierSetEntry operation.
	//
	// Update least cost routing carrier set entry.
	//
	// PUT /LcrCarrierSetEntries/{LcrCarrierSetEntrySid}
	UpdateLeastCostRoutingCarrierSetEntry(ctx context.Context, request OptLcrCarrierSetEntry, params UpdateLeastCostRoutingCarrierSetEntryParams) (UpdateLeastCostRoutingCarrierSetEntryRes, error)
	// UpdateLeastCostRoutingRoute invokes updateLeastCostRoutingRoute operation.
	//
	// Update least cost routing route.
	//
	// PUT /LcrRoutes/{LcrRouteSid}
	UpdateLeastCostRoutingRoute(ctx context.Context, request OptLcrRoute, params UpdateLeastCostRoutingRouteParams) (UpdateLeastCostRoutingRouteRes, error)
	// UpdateLeastCostRoutingRoutesAndCarrierEntries invokes updateLeastCostRoutingRoutesAndCarrierEntries operation.
	//
	// Update least cost routing routes and carrier set entries.
	//
	// PUT /Lcrs/{LcrSid}/Routes
	UpdateLeastCostRoutingRoutesAndCarrierEntries(ctx context.Context, request LcrRoutes, params UpdateLeastCostRoutingRoutesAndCarrierEntriesParams) (UpdateLeastCostRoutingRoutesAndCarrierEntriesRes, error)
	// UpdatePhoneNumber invokes updatePhoneNumber operation.
	//
	// Update phone number.
	//
	// PUT /PhoneNumbers/{PhoneNumberSid}
	UpdatePhoneNumber(ctx context.Context, request OptPhoneNumber, params UpdatePhoneNumberParams) (UpdatePhoneNumberRes, error)
	// UpdateServiceProvider invokes updateServiceProvider operation.
	//
	// Update service provider.
	//
	// PUT /ServiceProviders/{ServiceProviderSid}
	UpdateServiceProvider(ctx context.Context, request OptServiceProvider, params UpdateServiceProviderParams) (UpdateServiceProviderRes, error)
	// UpdateSipGateway invokes updateSipGateway operation.
	//
	// Update sip gateway.
	//
	// PUT /SipGateways/{SipGatewaySid}
	UpdateSipGateway(ctx context.Context, request OptSipGateway, params UpdateSipGatewayParams) (UpdateSipGatewayRes, error)
	// UpdateSmppGateway invokes updateSmppGateway operation.
	//
	// Update smpp gateway.
	//
	// PUT /SmppGateways/{SmppGatewaySid}
	UpdateSmppGateway(ctx context.Context, request OptSmppGateway, params UpdateSmppGatewayParams) (UpdateSmppGatewayRes, error)
	// UpdateSpeechCredential invokes updateSpeechCredential operation.
	//
	// Update a speech credential.
	//
	// PUT /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}
	UpdateSpeechCredential(ctx context.Context, request OptSpeechCredentialUpdate, params UpdateSpeechCredentialParams) (UpdateSpeechCredentialRes, error)
	// UpdateSpeechCredentialByAccount invokes updateSpeechCredentialByAccount operation.
	//
	// Update a speech credential.
	//
	// PUT /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}
	UpdateSpeechCredentialByAccount(ctx context.Context, request OptSpeechCredentialUpdate, params UpdateSpeechCredentialByAccountParams) (UpdateSpeechCredentialByAccountRes, error)
	// UpdateUser invokes updateUser operation.
	//
	// Update user information.
	//
	// PUT /Users/{UserSid}
	UpdateUser(ctx context.Context, request OptUpdateUserReq, params UpdateUserParams) (UpdateUserRes, error)
	// UpdateVoipCarrier invokes updateVoipCarrier operation.
	//
	// Update voip carrier.
	//
	// PUT /VoipCarriers/{VoipCarrierSid}
	UpdateVoipCarrier(ctx context.Context, request OptVoipCarrier, params UpdateVoipCarrierParams) (UpdateVoipCarrierRes, error)
	// ValidateActivationCode invokes validateActivationCode operation.
	//
	// Validate an activation code.
	//
	// PUT /ActivationCode/{Code}
	ValidateActivationCode(ctx context.Context, request OptValidateActivationCodeReq, params ValidateActivationCodeParams) (ValidateActivationCodeRes, error)
	// ValidateInviteCode invokes validateInviteCode operation.
	//
	// Validate an invite code.
	//
	// POST /InviteCodes
	ValidateInviteCode(ctx context.Context, request OptValidateInviteCodeReq) (ValidateInviteCodeRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddLimitForAccount invokes addLimitForAccount operation.
//
// Create a limit for an account.
//
// POST /Accounts/{AccountSid}/Limits
func (c *Client) AddLimitForAccount(ctx context.Context, request OptLimits, params AddLimitForAccountParams) (AddLimitForAccountRes, error) {
	res, err := c.sendAddLimitForAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendAddLimitForAccount(ctx context.Context, request OptLimits, params AddLimitForAccountParams) (res AddLimitForAccountRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddLimitForAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, AddLimitForAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddLimitForAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddLimitForServiceProvider invokes addLimitForServiceProvider operation.
//
// Create a limit for a service provider.
//
// POST /ServiceProviders/{ServiceProviderSid}/Limits
func (c *Client) AddLimitForServiceProvider(ctx context.Context, request OptLimits, params AddLimitForServiceProviderParams) (AddLimitForServiceProviderRes, error) {
	res, err := c.sendAddLimitForServiceProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendAddLimitForServiceProvider(ctx context.Context, request OptLimits, params AddLimitForServiceProviderParams) (res AddLimitForServiceProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddLimitForServiceProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, AddLimitForServiceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddLimitForServiceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSpeechCredentialForSeerviceProvider invokes addSpeechCredentialForSeerviceProvider operation.
//
// Create a speech credential for a service provider.
//
// POST /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/
func (c *Client) AddSpeechCredentialForSeerviceProvider(ctx context.Context, request OptSpeechCredential, params AddSpeechCredentialForSeerviceProviderParams) (AddSpeechCredentialForSeerviceProviderRes, error) {
	res, err := c.sendAddSpeechCredentialForSeerviceProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendAddSpeechCredentialForSeerviceProvider(ctx context.Context, request OptSpeechCredential, params AddSpeechCredentialForSeerviceProviderParams) (res AddSpeechCredentialForSeerviceProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSpeechCredentialForSeerviceProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, AddSpeechCredentialForSeerviceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddSpeechCredentialForSeerviceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApplicationsApplicationSidGet invokes GET /Applications/{ApplicationSid} operation.
//
// Retrieve an application.
//
// GET /Applications/{ApplicationSid}
func (c *Client) ApplicationsApplicationSidGet(ctx context.Context, params ApplicationsApplicationSidGetParams) (ApplicationsApplicationSidGetRes, error) {
	res, err := c.sendApplicationsApplicationSidGet(ctx, params)
	return res, err
}

func (c *Client) sendApplicationsApplicationSidGet(ctx context.Context, params ApplicationsApplicationSidGetParams) (res ApplicationsApplicationSidGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Applications/"
	{
		// Encode "ApplicationSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ApplicationSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicationSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ApplicationsApplicationSidGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeApplicationsApplicationSidGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangePassword invokes changePassword operation.
//
// ChangePassword.
//
// POST /change-password
func (c *Client) ChangePassword(ctx context.Context, request OptChangePasswordReq) (ChangePasswordRes, error) {
	res, err := c.sendChangePassword(ctx, request)
	return res, err
}

func (c *Client) sendChangePassword(ctx context.Context, request OptChangePasswordReq) (res ChangePasswordRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/change-password"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangePasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ChangePasswordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangePasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CheckAvailability invokes checkAvailability operation.
//
// Check if a limited-availability entity such as a subdomain, email or phone number is already in use.
//
// GET /Availability
func (c *Client) CheckAvailability(ctx context.Context, params CheckAvailabilityParams) (CheckAvailabilityRes, error) {
	res, err := c.sendCheckAvailability(ctx, params)
	return res, err
}

func (c *Client) sendCheckAvailability(ctx context.Context, params CheckAvailabilityParams) (res CheckAvailabilityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Availability"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Type)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "value" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "value",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Value))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CheckAvailabilityOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCheckAvailabilityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAccount invokes createAccount operation.
//
// Create an account.
//
// POST /Accounts
func (c *Client) CreateAccount(ctx context.Context, request OptCreateAccountReq) (CreateAccountRes, error) {
	res, err := c.sendCreateAccount(ctx, request)
	return res, err
}

func (c *Client) sendCreateAccount(ctx context.Context, request OptCreateAccountReq) (res CreateAccountRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Accounts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateApikey invokes createApikey operation.
//
// Create an api key.
//
// POST /ApiKeys
func (c *Client) CreateApikey(ctx context.Context, request OptCreateApikeyReq) (CreateApikeyRes, error) {
	res, err := c.sendCreateApikey(ctx, request)
	return res, err
}

func (c *Client) sendCreateApikey(ctx context.Context, request OptCreateApikeyReq) (res CreateApikeyRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ApiKeys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateApikeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateApikeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateApikeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateApplication invokes createApplication operation.
//
// Create application.
//
// POST /Applications
func (c *Client) CreateApplication(ctx context.Context, request OptCreateApplicationReq) (CreateApplicationRes, error) {
	res, err := c.sendCreateApplication(ctx, request)
	return res, err
}

func (c *Client) sendCreateApplication(ctx context.Context, request OptCreateApplicationReq) (res CreateApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Applications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateApplicationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCall invokes createCall operation.
//
// Create a call.
//
// POST /Accounts/{AccountSid}/Calls
func (c *Client) CreateCall(ctx context.Context, request OptCreateCallReq, params CreateCallParams) (CreateCallRes, error) {
	res, err := c.sendCreateCall(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateCall(ctx context.Context, request OptCreateCallReq, params CreateCallParams) (res CreateCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateCallOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCarrierForServiceProvider invokes createCarrierForServiceProvider operation.
//
// Create a carrier.
//
// POST /ServiceProviders/{ServiceProviderSid}/VoipCarriers
func (c *Client) CreateCarrierForServiceProvider(ctx context.Context, request OptVoipCarrier, params CreateCarrierForServiceProviderParams) (CreateCarrierForServiceProviderRes, error) {
	res, err := c.sendCreateCarrierForServiceProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateCarrierForServiceProvider(ctx context.Context, request OptVoipCarrier, params CreateCarrierForServiceProviderParams) (res CreateCarrierForServiceProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/VoipCarriers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCarrierForServiceProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateCarrierForServiceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCarrierForServiceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateGoogleCustomVoice invokes createGoogleCustomVoice operation.
//
// Create a Google custom voice.
//
// POST /GoogleCustomVoices
func (c *Client) CreateGoogleCustomVoice(ctx context.Context, request []GoogleCustomVoice) (CreateGoogleCustomVoiceRes, error) {
	res, err := c.sendCreateGoogleCustomVoice(ctx, request)
	return res, err
}

func (c *Client) sendCreateGoogleCustomVoice(ctx context.Context, request []GoogleCustomVoice) (res CreateGoogleCustomVoiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/GoogleCustomVoices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateGoogleCustomVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateGoogleCustomVoiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateGoogleCustomVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLcr invokes createLcr operation.
//
// Create a Least Cost Routing.
//
// POST /Lcrs
func (c *Client) CreateLcr(ctx context.Context, request OptCreateLcrReq) (CreateLcrRes, error) {
	res, err := c.sendCreateLcr(ctx, request)
	return res, err
}

func (c *Client) sendCreateLcr(ctx context.Context, request OptCreateLcrReq) (res CreateLcrRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Lcrs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLcrRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateLcrOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateLcrResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLcrCarrierSetEntry invokes createLcrCarrierSetEntry operation.
//
// Create a Least Cost Routing Carrier Set Entry.
//
// POST /LcrCarrierSetEntries
func (c *Client) CreateLcrCarrierSetEntry(ctx context.Context, request []LcrCarrierSetEntry) (CreateLcrCarrierSetEntryRes, error) {
	res, err := c.sendCreateLcrCarrierSetEntry(ctx, request)
	return res, err
}

func (c *Client) sendCreateLcrCarrierSetEntry(ctx context.Context, request []LcrCarrierSetEntry) (res CreateLcrCarrierSetEntryRes, err error) {
	// Validate request before sending.
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range request {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/LcrCarrierSetEntries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLcrCarrierSetEntryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateLcrCarrierSetEntryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateLcrCarrierSetEntryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLcrForServiceProvider invokes createLcrForServiceProvider operation.
//
// Create a Lest cost routing.
//
// POST /ServiceProviders/{ServiceProviderSid}/Lcrs
func (c *Client) CreateLcrForServiceProvider(ctx context.Context, request OptCreateLcrForServiceProviderReq, params CreateLcrForServiceProviderParams) (CreateLcrForServiceProviderRes, error) {
	res, err := c.sendCreateLcrForServiceProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateLcrForServiceProvider(ctx context.Context, request OptCreateLcrForServiceProviderReq, params CreateLcrForServiceProviderParams) (res CreateLcrForServiceProviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Lcrs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLcrForServiceProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateLcrForServiceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateLcrForServiceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLcrRoutes invokes createLcrRoutes operation.
//
// Create a Least Cost Routing Routes.
//
// POST /LcrRoutes
func (c *Client) CreateLcrRoutes(ctx context.Context, request []LcrRoute) (CreateLcrRoutesRes, error) {
	res, err := c.sendCreateLcrRoutes(ctx, request)
	return res, err
}

func (c *Client) sendCreateLcrRoutes(ctx context.Context, request []LcrRoute) (res CreateLcrRoutesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range request {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/LcrRoutes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLcrRoutesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateLcrRoutesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateLcrRoutesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLeastCostRoutingRoutesAndCarrierEntries invokes createLeastCostRoutingRoutesAndCarrierEntries operation.
//
// Create least cost routing routes and carrier set entries.
//
// POST /Lcrs/{LcrSid}/Routes
func (c *Client) CreateLeastCostRoutingRoutesAndCarrierEntries(ctx context.Context, request LcrRoutes, params CreateLeastCostRoutingRoutesAndCarrierEntriesParams) (CreateLeastCostRoutingRoutesAndCarrierEntriesRes, error) {
	res, err := c.sendCreateLeastCostRoutingRoutesAndCarrierEntries(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateLeastCostRoutingRoutesAndCarrierEntries(ctx context.Context, request LcrRoutes, params CreateLeastCostRoutingRoutesAndCarrierEntriesParams) (res CreateLeastCostRoutingRoutesAndCarrierEntriesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Lcrs/"
	{
		// Encode "LcrSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Routes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLeastCostRoutingRoutesAndCarrierEntriesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateLeastCostRoutingRoutesAndCarrierEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateLeastCostRoutingRoutesAndCarrierEntriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMessage invokes createMessage operation.
//
// Create an outgoing SMS message.
//
// POST /Accounts/{AccountSid}/Messages
func (c *Client) CreateMessage(ctx context.Context, request OptMessage, params CreateMessageParams) (CreateMessageRes, error) {
	res, err := c.sendCreateMessage(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateMessage(ctx context.Context, request OptMessage, params CreateMessageParams) (res CreateMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Messages"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMsTeamsTenant invokes createMsTeamsTenant operation.
//
// Provision a customer tenant for MS Teams.
//
// POST /MicrosoftTeamsTenants
func (c *Client) CreateMsTeamsTenant(ctx context.Context, request OptCreateMsTeamsTenantReq) (CreateMsTeamsTenantRes, error) {
	res, err := c.sendCreateMsTeamsTenant(ctx, request)
	return res, err
}

func (c *Client) sendCreateMsTeamsTenant(ctx context.Context, request OptCreateMsTeamsTenantReq) (res CreateMsTeamsTenantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/MicrosoftTeamsTenants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMsTeamsTenantRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateMsTeamsTenantOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateMsTeamsTenantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSbc invokes createSbc operation.
//
// Add an SBC address.
//
// POST /Sbcs
func (c *Client) CreateSbc(ctx context.Context, request OptCreateSbcReq) (CreateSbcRes, error) {
	res, err := c.sendCreateSbc(ctx, request)
	return res, err
}

func (c *Client) sendCreateSbc(ctx context.Context, request OptCreateSbcReq) (res CreateSbcRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Sbcs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSbcRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateSbcOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateSbcResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateServiceProvider invokes createServiceProvider operation.
//
// Create service provider.
//
// POST /ServiceProviders
func (c *Client) CreateServiceProvider(ctx context.Context, request OptCreateServiceProviderReq) (CreateServiceProviderRes, error) {
	res, err := c.sendCreateServiceProvider(ctx, request)
	return res, err
}

func (c *Client) sendCreateServiceProvider(ctx context.Context, request OptCreateServiceProviderReq) (res CreateServiceProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ServiceProviders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateServiceProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateServiceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateServiceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSipGateway invokes createSipGateway operation.
//
// Create sip gateway.
//
// POST /SipGateways
func (c *Client) CreateSipGateway(ctx context.Context, request OptCreateSipGatewayReq) (CreateSipGatewayRes, error) {
	res, err := c.sendCreateSipGateway(ctx, request)
	return res, err
}

func (c *Client) sendCreateSipGateway(ctx context.Context, request OptCreateSipGatewayReq) (res CreateSipGatewayRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/SipGateways"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSipGatewayRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateSipGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateSipGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSipRealm invokes createSipRealm operation.
//
// Add or change the sip realm.
//
// POST /Accounts/{AccountSid}/SipRealms/{SipRealm}
func (c *Client) CreateSipRealm(ctx context.Context, params CreateSipRealmParams) (CreateSipRealmRes, error) {
	res, err := c.sendCreateSipRealm(ctx, params)
	return res, err
}

func (c *Client) sendCreateSipRealm(ctx context.Context, params CreateSipRealmParams) (res CreateSipRealmRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SipRealms/"
	{
		// Encode "SipRealm" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SipRealm",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SipRealm))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateSipRealmOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateSipRealmResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSmppGateway invokes createSmppGateway operation.
//
// Create smpp gateway.
//
// POST /SmppGateways
func (c *Client) CreateSmppGateway(ctx context.Context, request OptCreateSmppGatewayReq) (CreateSmppGatewayRes, error) {
	res, err := c.sendCreateSmppGateway(ctx, request)
	return res, err
}

func (c *Client) sendCreateSmppGateway(ctx context.Context, request OptCreateSmppGatewayReq) (res CreateSmppGatewayRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/SmppGateways"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSmppGatewayRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateSmppGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateSmppGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSpeechCredential invokes createSpeechCredential operation.
//
// Add a speech credential.
//
// POST /Accounts/{AccountSid}/SpeechCredentials
func (c *Client) CreateSpeechCredential(ctx context.Context, request OptSpeechCredential, params CreateSpeechCredentialParams) (CreateSpeechCredentialRes, error) {
	res, err := c.sendCreateSpeechCredential(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateSpeechCredential(ctx context.Context, request OptSpeechCredential, params CreateSpeechCredentialParams) (res CreateSpeechCredentialRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSpeechCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateSpeechCredentialOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateSpeechCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateUser invokes createUser operation.
//
// Create a new user.
//
// POST /Users/{UserSid}
func (c *Client) CreateUser(ctx context.Context, request OptCreateUserReq, params CreateUserParams) (CreateUserRes, error) {
	res, err := c.sendCreateUser(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateUser(ctx context.Context, request OptCreateUserReq, params CreateUserParams) (res CreateUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Users/"
	{
		// Encode "UserSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "UserSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVoipCarrier invokes createVoipCarrier operation.
//
// Create voip carrier.
//
// POST /VoipCarriers
func (c *Client) CreateVoipCarrier(ctx context.Context, request OptCreateVoipCarrierReq) (CreateVoipCarrierRes, error) {
	res, err := c.sendCreateVoipCarrier(ctx, request)
	return res, err
}

func (c *Client) sendCreateVoipCarrier(ctx context.Context, request OptCreateVoipCarrierReq) (res CreateVoipCarrierRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/VoipCarriers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVoipCarrierRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateVoipCarrierOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVoipCarrierResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVoipCarrierFromTemplate invokes createVoipCarrierFromTemplate operation.
//
// Add a VoiPCarrier to an account based on PredefinedCarrier template.
//
// POST /Accounts/{AccountSid}/PredefinedCarriers/{PredefinedCarrierSid}
func (c *Client) CreateVoipCarrierFromTemplate(ctx context.Context, params CreateVoipCarrierFromTemplateParams) (CreateVoipCarrierFromTemplateRes, error) {
	res, err := c.sendCreateVoipCarrierFromTemplate(ctx, params)
	return res, err
}

func (c *Client) sendCreateVoipCarrierFromTemplate(ctx context.Context, params CreateVoipCarrierFromTemplateParams) (res CreateVoipCarrierFromTemplateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/PredefinedCarriers/"
	{
		// Encode "PredefinedCarrierSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "PredefinedCarrierSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PredefinedCarrierSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateVoipCarrierFromTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVoipCarrierFromTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVoipCarrierFromTemplateBySP invokes createVoipCarrierFromTemplateBySP operation.
//
// Add a VoiPCarrier to a service provider based on PredefinedCarrier template.
//
// POST /ServiceProviders/{ServiceProviderSid}/PredefinedCarriers/{PredefinedCarrierSid}
func (c *Client) CreateVoipCarrierFromTemplateBySP(ctx context.Context, params CreateVoipCarrierFromTemplateBySPParams) (CreateVoipCarrierFromTemplateBySPRes, error) {
	res, err := c.sendCreateVoipCarrierFromTemplateBySP(ctx, params)
	return res, err
}

func (c *Client) sendCreateVoipCarrierFromTemplateBySP(ctx context.Context, params CreateVoipCarrierFromTemplateBySPParams) (res CreateVoipCarrierFromTemplateBySPRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/PredefinedCarriers/"
	{
		// Encode "PredefinedCarrierSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "PredefinedCarrierSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PredefinedCarrierSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, CreateVoipCarrierFromTemplateBySPOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVoipCarrierFromTemplateBySPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAccount invokes deleteAccount operation.
//
// Delete an account.
//
// DELETE /Accounts/{AccountSid}
func (c *Client) DeleteAccount(ctx context.Context, params DeleteAccountParams) (DeleteAccountRes, error) {
	res, err := c.sendDeleteAccount(ctx, params)
	return res, err
}

func (c *Client) sendDeleteAccount(ctx context.Context, params DeleteAccountParams) (res DeleteAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteApiKey invokes deleteApiKey operation.
//
// Delete api key.
//
// DELETE /ApiKeys/{ApiKeySid}
func (c *Client) DeleteApiKey(ctx context.Context, params DeleteApiKeyParams) (DeleteApiKeyRes, error) {
	res, err := c.sendDeleteApiKey(ctx, params)
	return res, err
}

func (c *Client) sendDeleteApiKey(ctx context.Context, params DeleteApiKeyParams) (res DeleteApiKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/ApiKeys/"
	{
		// Encode "ApiKeySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ApiKeySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApiKeySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteApiKeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteApiKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteApplication invokes deleteApplication operation.
//
// Delete an application.
//
// DELETE /Applications/{ApplicationSid}
func (c *Client) DeleteApplication(ctx context.Context, params DeleteApplicationParams) (DeleteApplicationRes, error) {
	res, err := c.sendDeleteApplication(ctx, params)
	return res, err
}

func (c *Client) sendDeleteApplication(ctx context.Context, params DeleteApplicationParams) (res DeleteApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Applications/"
	{
		// Encode "ApplicationSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ApplicationSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicationSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteApplicationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCall invokes deleteCall operation.
//
// Delete a call.
//
// DELETE /Accounts/{AccountSid}/Calls/{CallSid}
func (c *Client) DeleteCall(ctx context.Context, params DeleteCallParams) (DeleteCallRes, error) {
	res, err := c.sendDeleteCall(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCall(ctx context.Context, params DeleteCallParams) (res DeleteCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "CallSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "CallSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteCallOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteGoogleCustomVoice invokes deleteGoogleCustomVoice operation.
//
// Delete a google custom voice.
//
// DELETE /GoogleCustomVoices/{GoogleCustomVoiceSid}
func (c *Client) DeleteGoogleCustomVoice(ctx context.Context, params DeleteGoogleCustomVoiceParams) (DeleteGoogleCustomVoiceRes, error) {
	res, err := c.sendDeleteGoogleCustomVoice(ctx, params)
	return res, err
}

func (c *Client) sendDeleteGoogleCustomVoice(ctx context.Context, params DeleteGoogleCustomVoiceParams) (res DeleteGoogleCustomVoiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/GoogleCustomVoices/"
	{
		// Encode "GoogleCustomVoiceSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "GoogleCustomVoiceSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GoogleCustomVoiceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteGoogleCustomVoiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteGoogleCustomVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteLeastCostRouting invokes deleteLeastCostRouting operation.
//
// Delete a least cost routing.
//
// DELETE /Lcrs/{LcrSid}
func (c *Client) DeleteLeastCostRouting(ctx context.Context, params DeleteLeastCostRoutingParams) (DeleteLeastCostRoutingRes, error) {
	res, err := c.sendDeleteLeastCostRouting(ctx, params)
	return res, err
}

func (c *Client) sendDeleteLeastCostRouting(ctx context.Context, params DeleteLeastCostRoutingParams) (res DeleteLeastCostRoutingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Lcrs/"
	{
		// Encode "LcrSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteLeastCostRoutingOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteLeastCostRoutingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteLeastCostRoutingCarrierSetEntry invokes deleteLeastCostRoutingCarrierSetEntry operation.
//
// Delete a least cost routing carrier set entry.
//
// DELETE /LcrCarrierSetEntries/{LcrCarrierSetEntrySid}
func (c *Client) DeleteLeastCostRoutingCarrierSetEntry(ctx context.Context, params DeleteLeastCostRoutingCarrierSetEntryParams) (DeleteLeastCostRoutingCarrierSetEntryRes, error) {
	res, err := c.sendDeleteLeastCostRoutingCarrierSetEntry(ctx, params)
	return res, err
}

func (c *Client) sendDeleteLeastCostRoutingCarrierSetEntry(ctx context.Context, params DeleteLeastCostRoutingCarrierSetEntryParams) (res DeleteLeastCostRoutingCarrierSetEntryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/LcrCarrierSetEntries/"
	{
		// Encode "LcrCarrierSetEntrySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrCarrierSetEntrySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrCarrierSetEntrySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteLeastCostRoutingCarrierSetEntryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteLeastCostRoutingCarrierSetEntryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteLeastCostRoutingRoute invokes deleteLeastCostRoutingRoute operation.
//
// Delete a least cost routing route.
//
// DELETE /LcrRoutes/{LcrRouteSid}
func (c *Client) DeleteLeastCostRoutingRoute(ctx context.Context, params DeleteLeastCostRoutingRouteParams) (DeleteLeastCostRoutingRouteRes, error) {
	res, err := c.sendDeleteLeastCostRoutingRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteLeastCostRoutingRoute(ctx context.Context, params DeleteLeastCostRoutingRouteParams) (res DeleteLeastCostRoutingRouteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/LcrRoutes/"
	{
		// Encode "LcrRouteSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrRouteSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrRouteSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteLeastCostRoutingRouteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteLeastCostRoutingRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePhoneNumber invokes deletePhoneNumber operation.
//
// Delete a phone number.
//
// DELETE /PhoneNumbers/{PhoneNumberSid}
func (c *Client) DeletePhoneNumber(ctx context.Context, params DeletePhoneNumberParams) (DeletePhoneNumberRes, error) {
	res, err := c.sendDeletePhoneNumber(ctx, params)
	return res, err
}

func (c *Client) sendDeletePhoneNumber(ctx context.Context, params DeletePhoneNumberParams) (res DeletePhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/PhoneNumbers/"
	{
		// Encode "PhoneNumberSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "PhoneNumberSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeletePhoneNumberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeletePhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSbcAddress invokes deleteSbcAddress operation.
//
// Delete SBC address.
//
// DELETE /Sbcs/{SbcSid}
func (c *Client) DeleteSbcAddress(ctx context.Context, params DeleteSbcAddressParams) (DeleteSbcAddressRes, error) {
	res, err := c.sendDeleteSbcAddress(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSbcAddress(ctx context.Context, params DeleteSbcAddressParams) (res DeleteSbcAddressRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Sbcs/"
	{
		// Encode "SbcSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SbcSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SbcSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteSbcAddressOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSbcAddressResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteServiceProvider invokes deleteServiceProvider operation.
//
// Delete a service provider.
//
// DELETE /ServiceProviders/{ServiceProviderSid}
func (c *Client) DeleteServiceProvider(ctx context.Context, params DeleteServiceProviderParams) (DeleteServiceProviderRes, error) {
	res, err := c.sendDeleteServiceProvider(ctx, params)
	return res, err
}

func (c *Client) sendDeleteServiceProvider(ctx context.Context, params DeleteServiceProviderParams) (res DeleteServiceProviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteServiceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteServiceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSipGateway invokes deleteSipGateway operation.
//
// Delete a sip gateway.
//
// DELETE /SipGateways/{SipGatewaySid}
func (c *Client) DeleteSipGateway(ctx context.Context, params DeleteSipGatewayParams) (DeleteSipGatewayRes, error) {
	res, err := c.sendDeleteSipGateway(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSipGateway(ctx context.Context, params DeleteSipGatewayParams) (res DeleteSipGatewayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/SipGateways/"
	{
		// Encode "SipGatewaySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SipGatewaySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SipGatewaySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteSipGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSipGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSmppGateway invokes deleteSmppGateway operation.
//
// Delete a smpp gateway.
//
// DELETE /SmppGateways/{SmppGatewaySid}
func (c *Client) DeleteSmppGateway(ctx context.Context, params DeleteSmppGatewayParams) (DeleteSmppGatewayRes, error) {
	res, err := c.sendDeleteSmppGateway(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSmppGateway(ctx context.Context, params DeleteSmppGatewayParams) (res DeleteSmppGatewayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/SmppGateways/"
	{
		// Encode "SmppGatewaySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SmppGatewaySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SmppGatewaySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteSmppGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSmppGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSpeechCredential invokes deleteSpeechCredential operation.
//
// Delete a speech credential.
//
// DELETE /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}
func (c *Client) DeleteSpeechCredential(ctx context.Context, params DeleteSpeechCredentialParams) (DeleteSpeechCredentialRes, error) {
	res, err := c.sendDeleteSpeechCredential(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSpeechCredential(ctx context.Context, params DeleteSpeechCredentialParams) (res DeleteSpeechCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteSpeechCredentialOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSpeechCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSpeechCredentialByAccount invokes deleteSpeechCredentialByAccount operation.
//
// Delete a speech credential.
//
// DELETE /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}
func (c *Client) DeleteSpeechCredentialByAccount(ctx context.Context, params DeleteSpeechCredentialByAccountParams) (DeleteSpeechCredentialByAccountRes, error) {
	res, err := c.sendDeleteSpeechCredentialByAccount(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSpeechCredentialByAccount(ctx context.Context, params DeleteSpeechCredentialByAccountParams) (res DeleteSpeechCredentialByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteSpeechCredentialByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSpeechCredentialByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTenant invokes deleteTenant operation.
//
// Delete an MS Teams tenant.
//
// DELETE /MicrosoftTeamsTenants/{TenantSid}
func (c *Client) DeleteTenant(ctx context.Context, params DeleteTenantParams) (DeleteTenantRes, error) {
	res, err := c.sendDeleteTenant(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTenant(ctx context.Context, params DeleteTenantParams) (res DeleteTenantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/MicrosoftTeamsTenants/"
	{
		// Encode "TenantSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "TenantSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TenantSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteTenantOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTenantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUser invokes deleteUser operation.
//
// Delete a user.
//
// DELETE /Users/{UserSid}
func (c *Client) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	res, err := c.sendDeleteUser(ctx, params)
	return res, err
}

func (c *Client) sendDeleteUser(ctx context.Context, params DeleteUserParams) (res DeleteUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Users/"
	{
		// Encode "UserSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "UserSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVoipCarrier invokes deleteVoipCarrier operation.
//
// Delete a voip carrier.
//
// DELETE /VoipCarriers/{VoipCarrierSid}
func (c *Client) DeleteVoipCarrier(ctx context.Context, params DeleteVoipCarrierParams) (DeleteVoipCarrierRes, error) {
	res, err := c.sendDeleteVoipCarrier(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVoipCarrier(ctx context.Context, params DeleteVoipCarrierParams) (res DeleteVoipCarrierRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/VoipCarriers/"
	{
		// Encode "VoipCarrierSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "VoipCarrierSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoipCarrierSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteVoipCarrierOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVoipCarrierResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ForgotPassword invokes forgotPassword operation.
//
// Send link to reset password.
//
// POST /forgot-password
func (c *Client) ForgotPassword(ctx context.Context, request OptForgotPasswordReq) (ForgotPasswordRes, error) {
	res, err := c.sendForgotPassword(ctx, request)
	return res, err
}

func (c *Client) sendForgotPassword(ctx context.Context, request OptForgotPasswordReq) (res ForgotPasswordRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/forgot-password"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeForgotPasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ForgotPasswordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeForgotPasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateInviteCode invokes generateInviteCode operation.
//
// Generate one or more beta invite codes.
//
// POST /BetaInviteCodes
func (c *Client) GenerateInviteCode(ctx context.Context, request OptGenerateInviteCodeReq) (GenerateInviteCodeRes, error) {
	res, err := c.sendGenerateInviteCode(ctx, request)
	return res, err
}

func (c *Client) sendGenerateInviteCode(ctx context.Context, request OptGenerateInviteCodeReq) (res GenerateInviteCodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/BetaInviteCodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateInviteCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GenerateInviteCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenerateInviteCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccount invokes getAccount operation.
//
// Retrieve account.
//
// GET /Accounts/{AccountSid}
func (c *Client) GetAccount(ctx context.Context, params GetAccountParams) (GetAccountRes, error) {
	res, err := c.sendGetAccount(ctx, params)
	return res, err
}

func (c *Client) sendGetAccount(ctx context.Context, params GetAccountParams) (res GetAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountApiKeys invokes getAccountApiKeys operation.
//
// Get all api keys for an account.
//
// GET /Accounts/{AccountSid}/ApiKeys
func (c *Client) GetAccountApiKeys(ctx context.Context, params GetAccountApiKeysParams) (GetAccountApiKeysRes, error) {
	res, err := c.sendGetAccountApiKeys(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountApiKeys(ctx context.Context, params GetAccountApiKeysParams) (res GetAccountApiKeysRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ApiKeys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetAccountApiKeysOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccountApiKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountLimits invokes getAccountLimits operation.
//
// Retrieve call capacity and other limits from the account.
//
// GET /Accounts/{AccountSid}/Limits
func (c *Client) GetAccountLimits(ctx context.Context, params GetAccountLimitsParams) (GetAccountLimitsRes, error) {
	res, err := c.sendGetAccountLimits(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountLimits(ctx context.Context, params GetAccountLimitsParams) (res GetAccountLimitsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetAccountLimitsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccountLimitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCall invokes getCall operation.
//
// Retrieve a call.
//
// GET /Accounts/{AccountSid}/Calls/{CallSid}
func (c *Client) GetCall(ctx context.Context, params GetCallParams) (GetCallRes, error) {
	res, err := c.sendGetCall(ctx, params)
	return res, err
}

func (c *Client) sendGetCall(ctx context.Context, params GetCallParams) (res GetCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "CallSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "CallSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetCallOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGoogleCustomVoice invokes getGoogleCustomVoice operation.
//
// Retrieve google custom voice.
//
// GET /GoogleCustomVoices/{GoogleCustomVoiceSid}
func (c *Client) GetGoogleCustomVoice(ctx context.Context, params GetGoogleCustomVoiceParams) (GetGoogleCustomVoiceRes, error) {
	res, err := c.sendGetGoogleCustomVoice(ctx, params)
	return res, err
}

func (c *Client) sendGetGoogleCustomVoice(ctx context.Context, params GetGoogleCustomVoiceParams) (res GetGoogleCustomVoiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/GoogleCustomVoices/"
	{
		// Encode "GoogleCustomVoiceSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "GoogleCustomVoiceSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GoogleCustomVoiceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetGoogleCustomVoiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetGoogleCustomVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLeastCostRouting invokes getLeastCostRouting operation.
//
// Retrieve least cost routing.
//
// GET /Lcrs/{LcrSid}
func (c *Client) GetLeastCostRouting(ctx context.Context, params GetLeastCostRoutingParams) (GetLeastCostRoutingRes, error) {
	res, err := c.sendGetLeastCostRouting(ctx, params)
	return res, err
}

func (c *Client) sendGetLeastCostRouting(ctx context.Context, params GetLeastCostRoutingParams) (res GetLeastCostRoutingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Lcrs/"
	{
		// Encode "LcrSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetLeastCostRoutingOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLeastCostRoutingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLeastCostRoutingCarrierSetEntry invokes getLeastCostRoutingCarrierSetEntry operation.
//
// Retrieve least cost routing carrier set entry.
//
// GET /LcrCarrierSetEntries/{LcrCarrierSetEntrySid}
func (c *Client) GetLeastCostRoutingCarrierSetEntry(ctx context.Context, params GetLeastCostRoutingCarrierSetEntryParams) (GetLeastCostRoutingCarrierSetEntryRes, error) {
	res, err := c.sendGetLeastCostRoutingCarrierSetEntry(ctx, params)
	return res, err
}

func (c *Client) sendGetLeastCostRoutingCarrierSetEntry(ctx context.Context, params GetLeastCostRoutingCarrierSetEntryParams) (res GetLeastCostRoutingCarrierSetEntryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/LcrCarrierSetEntries/"
	{
		// Encode "LcrCarrierSetEntrySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrCarrierSetEntrySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrCarrierSetEntrySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetLeastCostRoutingCarrierSetEntryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLeastCostRoutingCarrierSetEntryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLeastCostRoutingRoute invokes getLeastCostRoutingRoute operation.
//
// Retrieve least cost routing route.
//
// GET /LcrRoutes/{LcrRouteSid}
func (c *Client) GetLeastCostRoutingRoute(ctx context.Context, params GetLeastCostRoutingRouteParams) (GetLeastCostRoutingRouteRes, error) {
	res, err := c.sendGetLeastCostRoutingRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetLeastCostRoutingRoute(ctx context.Context, params GetLeastCostRoutingRouteParams) (res GetLeastCostRoutingRouteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/LcrRoutes/"
	{
		// Encode "LcrRouteSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrRouteSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrRouteSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetLeastCostRoutingRouteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLeastCostRoutingRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyDetails invokes getMyDetails operation.
//
// Retrieve details about logged-in user and associated account.
//
// GET /Users/me
func (c *Client) GetMyDetails(ctx context.Context) (GetMyDetailsRes, error) {
	res, err := c.sendGetMyDetails(ctx)
	return res, err
}

func (c *Client) sendGetMyDetails(ctx context.Context) (res GetMyDetailsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Users/me"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetMyDetailsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyDetailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneNumber invokes getPhoneNumber operation.
//
// Retrieve phone number.
//
// GET /PhoneNumbers/{PhoneNumberSid}
func (c *Client) GetPhoneNumber(ctx context.Context, params GetPhoneNumberParams) (GetPhoneNumberRes, error) {
	res, err := c.sendGetPhoneNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneNumber(ctx context.Context, params GetPhoneNumberParams) (res GetPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/PhoneNumbers/"
	{
		// Encode "PhoneNumberSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "PhoneNumberSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetPhoneNumberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecentCallTrace invokes getRecentCallTrace operation.
//
// Retrieve sip trace detail for a call.
//
// GET /Accounts/{AccountSid}/RecentCalls/{CallId}
func (c *Client) GetRecentCallTrace(ctx context.Context, params GetRecentCallTraceParams) (GetRecentCallTraceRes, error) {
	res, err := c.sendGetRecentCallTrace(ctx, params)
	return res, err
}

func (c *Client) sendGetRecentCallTrace(ctx context.Context, params GetRecentCallTraceParams) (res GetRecentCallTraceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RecentCalls/"
	{
		// Encode "CallId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "CallId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetRecentCallTraceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecentCallTraceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecentCallTraceByAccount invokes getRecentCallTraceByAccount operation.
//
// Retrieve pcap for a call.
//
// GET /Accounts/{AccountSid}/RecentCalls/{CallId}/pcap
func (c *Client) GetRecentCallTraceByAccount(ctx context.Context, params GetRecentCallTraceByAccountParams) (GetRecentCallTraceByAccountRes, error) {
	res, err := c.sendGetRecentCallTraceByAccount(ctx, params)
	return res, err
}

func (c *Client) sendGetRecentCallTraceByAccount(ctx context.Context, params GetRecentCallTraceByAccountParams) (res GetRecentCallTraceByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RecentCalls/"
	{
		// Encode "CallId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "CallId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pcap"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetRecentCallTraceByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecentCallTraceByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecentCallTraceByCallId invokes getRecentCallTraceByCallId operation.
//
// Retrieve sip trace detail for a call.
//
// GET /ServiceProviders/{ServiceProviderSid}/RecentCalls/{CallId}
func (c *Client) GetRecentCallTraceByCallId(ctx context.Context, params GetRecentCallTraceByCallIdParams) (GetRecentCallTraceByCallIdRes, error) {
	res, err := c.sendGetRecentCallTraceByCallId(ctx, params)
	return res, err
}

func (c *Client) sendGetRecentCallTraceByCallId(ctx context.Context, params GetRecentCallTraceByCallIdParams) (res GetRecentCallTraceByCallIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RecentCalls/"
	{
		// Encode "CallId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "CallId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetRecentCallTraceByCallIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecentCallTraceByCallIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecentCallTraceBySP invokes getRecentCallTraceBySP operation.
//
// Retrieve pcap for a call.
//
// GET /ServiceProviders/{ServiceProviderSid}/RecentCalls/{CallId}/pcap
func (c *Client) GetRecentCallTraceBySP(ctx context.Context, params GetRecentCallTraceBySPParams) (GetRecentCallTraceBySPRes, error) {
	res, err := c.sendGetRecentCallTraceBySP(ctx, params)
	return res, err
}

func (c *Client) sendGetRecentCallTraceBySP(ctx context.Context, params GetRecentCallTraceBySPParams) (res GetRecentCallTraceBySPRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RecentCalls/"
	{
		// Encode "CallId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "CallId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pcap"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetRecentCallTraceBySPOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecentCallTraceBySPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRegisteredClient invokes getRegisteredClient operation.
//
// Retrieve registered client registration.
//
// GET /Accounts/{AccountSid}/RegisteredSipUsers/{Client}
func (c *Client) GetRegisteredClient(ctx context.Context, params GetRegisteredClientParams) (*RegisteredClient, error) {
	res, err := c.sendGetRegisteredClient(ctx, params)
	return res, err
}

func (c *Client) sendGetRegisteredClient(ctx context.Context, params GetRegisteredClientParams) (res *RegisteredClient, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RegisteredSipUsers/"
	{
		// Encode "Client" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "Client",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Client))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetRegisteredClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRegisteredClientResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServiceProvider invokes getServiceProvider operation.
//
// Retrieve service provider.
//
// GET /ServiceProviders/{ServiceProviderSid}
func (c *Client) GetServiceProvider(ctx context.Context, params GetServiceProviderParams) (GetServiceProviderRes, error) {
	res, err := c.sendGetServiceProvider(ctx, params)
	return res, err
}

func (c *Client) sendGetServiceProvider(ctx context.Context, params GetServiceProviderParams) (res GetServiceProviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetServiceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServiceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServiceProviderAccounts invokes getServiceProviderAccounts operation.
//
// Get all accounts for a service provider.
//
// GET /ServiceProviders/{ServiceProviderSid}/Accounts
func (c *Client) GetServiceProviderAccounts(ctx context.Context, params GetServiceProviderAccountsParams) (GetServiceProviderAccountsRes, error) {
	res, err := c.sendGetServiceProviderAccounts(ctx, params)
	return res, err
}

func (c *Client) sendGetServiceProviderAccounts(ctx context.Context, params GetServiceProviderAccountsParams) (res GetServiceProviderAccountsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Accounts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetServiceProviderAccountsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServiceProviderAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServiceProviderCarriers invokes getServiceProviderCarriers operation.
//
// Get all carriers for a service provider.
//
// GET /ServiceProviders/{ServiceProviderSid}/VoipCarriers
func (c *Client) GetServiceProviderCarriers(ctx context.Context, params GetServiceProviderCarriersParams) (GetServiceProviderCarriersRes, error) {
	res, err := c.sendGetServiceProviderCarriers(ctx, params)
	return res, err
}

func (c *Client) sendGetServiceProviderCarriers(ctx context.Context, params GetServiceProviderCarriersParams) (res GetServiceProviderCarriersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/VoipCarriers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetServiceProviderCarriersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServiceProviderCarriersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServiceProviderLcrs invokes getServiceProviderLcrs operation.
//
// Get all Least Cost Routings for a service provider.
//
// GET /ServiceProviders/{ServiceProviderSid}/Lcrs
func (c *Client) GetServiceProviderLcrs(ctx context.Context, params GetServiceProviderLcrsParams) (GetServiceProviderLcrsRes, error) {
	res, err := c.sendGetServiceProviderLcrs(ctx, params)
	return res, err
}

func (c *Client) sendGetServiceProviderLcrs(ctx context.Context, params GetServiceProviderLcrsParams) (res GetServiceProviderLcrsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Lcrs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetServiceProviderLcrsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServiceProviderLcrsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServiceProviderLimits invokes getServiceProviderLimits operation.
//
// Retrieve call capacity and other limits from the service provider.
//
// GET /ServiceProviders/{ServiceProviderSid}/Limits
func (c *Client) GetServiceProviderLimits(ctx context.Context, params GetServiceProviderLimitsParams) (GetServiceProviderLimitsRes, error) {
	res, err := c.sendGetServiceProviderLimits(ctx, params)
	return res, err
}

func (c *Client) sendGetServiceProviderLimits(ctx context.Context, params GetServiceProviderLimitsParams) (res GetServiceProviderLimitsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetServiceProviderLimitsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServiceProviderLimitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSipGateway invokes getSipGateway operation.
//
// Retrieve sip gateway.
//
// GET /SipGateways/{SipGatewaySid}
func (c *Client) GetSipGateway(ctx context.Context, params GetSipGatewayParams) (GetSipGatewayRes, error) {
	res, err := c.sendGetSipGateway(ctx, params)
	return res, err
}

func (c *Client) sendGetSipGateway(ctx context.Context, params GetSipGatewayParams) (res GetSipGatewayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/SipGateways/"
	{
		// Encode "SipGatewaySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SipGatewaySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SipGatewaySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetSipGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSipGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSmppGateway invokes getSmppGateway operation.
//
// Retrieve smpp gateway.
//
// GET /SmppGateways/{SmppGatewaySid}
func (c *Client) GetSmppGateway(ctx context.Context, params GetSmppGatewayParams) (GetSmppGatewayRes, error) {
	res, err := c.sendGetSmppGateway(ctx, params)
	return res, err
}

func (c *Client) sendGetSmppGateway(ctx context.Context, params GetSmppGatewayParams) (res GetSmppGatewayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/SmppGateways/"
	{
		// Encode "SmppGatewaySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SmppGatewaySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SmppGatewaySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetSmppGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSmppGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpeechCredential invokes getSpeechCredential operation.
//
// Get a specific speech credential.
//
// GET /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}
func (c *Client) GetSpeechCredential(ctx context.Context, params GetSpeechCredentialParams) (GetSpeechCredentialRes, error) {
	res, err := c.sendGetSpeechCredential(ctx, params)
	return res, err
}

func (c *Client) sendGetSpeechCredential(ctx context.Context, params GetSpeechCredentialParams) (res GetSpeechCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetSpeechCredentialOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSpeechCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpeechCredentialByAccount invokes getSpeechCredentialByAccount operation.
//
// Get a specific speech credential.
//
// GET /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}
func (c *Client) GetSpeechCredentialByAccount(ctx context.Context, params GetSpeechCredentialByAccountParams) (GetSpeechCredentialByAccountRes, error) {
	res, err := c.sendGetSpeechCredentialByAccount(ctx, params)
	return res, err
}

func (c *Client) sendGetSpeechCredentialByAccount(ctx context.Context, params GetSpeechCredentialByAccountParams) (res GetSpeechCredentialByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetSpeechCredentialByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSpeechCredentialByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStripeCustomerId invokes getStripeCustomerId operation.
//
// Retrieve stripe customer id for an account, creating if necessary.
//
// GET /StripeCustomerId
func (c *Client) GetStripeCustomerId(ctx context.Context) (GetStripeCustomerIdRes, error) {
	res, err := c.sendGetStripeCustomerId(ctx)
	return res, err
}

func (c *Client) sendGetStripeCustomerId(ctx context.Context) (res GetStripeCustomerIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/StripeCustomerId"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetStripeCustomerIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStripeCustomerIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSubscription invokes getSubscription operation.
//
// Get subscription details from stripe.
//
// GET /Subscriptions
func (c *Client) GetSubscription(ctx context.Context) error {
	_, err := c.sendGetSubscription(ctx)
	return err
}

func (c *Client) sendGetSubscription(ctx context.Context) (res *GetSubscriptionOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTenant invokes getTenant operation.
//
// Retrieve an MS Teams tenant.
//
// GET /MicrosoftTeamsTenants/{TenantSid}
func (c *Client) GetTenant(ctx context.Context, params GetTenantParams) (GetTenantRes, error) {
	res, err := c.sendGetTenant(ctx, params)
	return res, err
}

func (c *Client) sendGetTenant(ctx context.Context, params GetTenantParams) (res GetTenantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/MicrosoftTeamsTenants/"
	{
		// Encode "TenantSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "TenantSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TenantSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetTenantOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTenantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTestData invokes getTestData operation.
//
// Get test phone numbers and applications.
//
// GET /AccountTest/{ServiceProviderSid}
func (c *Client) GetTestData(ctx context.Context, params GetTestDataParams) (GetTestDataRes, error) {
	res, err := c.sendGetTestData(ctx, params)
	return res, err
}

func (c *Client) sendGetTestData(ctx context.Context, params GetTestDataParams) (res GetTestDataRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/AccountTest/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetTestDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTestDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUser invokes getUser operation.
//
// Retrieve user information.
//
// GET /Users/{UserSid}
func (c *Client) GetUser(ctx context.Context, params GetUserParams) (GetUserRes, error) {
	res, err := c.sendGetUser(ctx, params)
	return res, err
}

func (c *Client) sendGetUser(ctx context.Context, params GetUserParams) (res GetUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Users/"
	{
		// Encode "UserSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "UserSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoipCarrier invokes getVoipCarrier operation.
//
// Retrieve voip carrier.
//
// GET /VoipCarriers/{VoipCarrierSid}
func (c *Client) GetVoipCarrier(ctx context.Context, params GetVoipCarrierParams) (GetVoipCarrierRes, error) {
	res, err := c.sendGetVoipCarrier(ctx, params)
	return res, err
}

func (c *Client) sendGetVoipCarrier(ctx context.Context, params GetVoipCarrierParams) (res GetVoipCarrierRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/VoipCarriers/"
	{
		// Encode "VoipCarrierSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "VoipCarrierSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoipCarrierSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetVoipCarrierOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVoipCarrierResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhook invokes getWebhook operation.
//
// Retrieve webhook.
//
// GET /Webhooks/{WebhookSid}
func (c *Client) GetWebhook(ctx context.Context, params GetWebhookParams) (GetWebhookRes, error) {
	res, err := c.sendGetWebhook(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhook(ctx context.Context, params GetWebhookParams) (res GetWebhookRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Webhooks/"
	{
		// Encode "WebhookSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "WebhookSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WebhookSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookSecret invokes getWebhookSecret operation.
//
// Get webhook signing secret, regenerating if requested.
//
// GET /Accounts/{AccountSid}/WebhookSecret
func (c *Client) GetWebhookSecret(ctx context.Context, params GetWebhookSecretParams) (GetWebhookSecretRes, error) {
	res, err := c.sendGetWebhookSecret(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhookSecret(ctx context.Context, params GetWebhookSecretParams) (res GetWebhookSecretRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/WebhookSecret"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "regenerate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "regenerate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Regenerate.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetWebhookSecretOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAccounts invokes listAccounts operation.
//
// List accounts.
//
// GET /Accounts
func (c *Client) ListAccounts(ctx context.Context) (ListAccountsRes, error) {
	res, err := c.sendListAccounts(ctx)
	return res, err
}

func (c *Client) sendListAccounts(ctx context.Context) (res ListAccountsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Accounts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListAccountsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAlerts invokes listAlerts operation.
//
// Retrieve alerts for a service provider.
//
// GET /ServiceProviders/{ServiceProviderSid}/Alerts
func (c *Client) ListAlerts(ctx context.Context, params ListAlertsParams) (ListAlertsRes, error) {
	res, err := c.sendListAlerts(ctx, params)
	return res, err
}

func (c *Client) sendListAlerts(ctx context.Context, params ListAlertsParams) (res ListAlertsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Alerts"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Page))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Count))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "days" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "days",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Days.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.End.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "alert_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "alert_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AlertType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListAlertsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListAlertsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAlertsByAccount invokes listAlertsByAccount operation.
//
// Retrieve alerts for an account.
//
// GET /Accounts/{AccountSid}/Alerts
func (c *Client) ListAlertsByAccount(ctx context.Context, params ListAlertsByAccountParams) (ListAlertsByAccountRes, error) {
	res, err := c.sendListAlertsByAccount(ctx, params)
	return res, err
}

func (c *Client) sendListAlertsByAccount(ctx context.Context, params ListAlertsByAccountParams) (res ListAlertsByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Alerts"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Page))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Count))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "days" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "days",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Days.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.End.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "alert_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "alert_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AlertType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListAlertsByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListAlertsByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListApplications invokes listApplications operation.
//
// List applications.
//
// GET /Applications
func (c *Client) ListApplications(ctx context.Context) (ListApplicationsRes, error) {
	res, err := c.sendListApplications(ctx)
	return res, err
}

func (c *Client) sendListApplications(ctx context.Context) (res ListApplicationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Applications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListApplicationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListApplicationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCalls invokes listCalls operation.
//
// List calls.
//
// GET /Accounts/{AccountSid}/Calls
func (c *Client) ListCalls(ctx context.Context, params ListCallsParams) (ListCallsRes, error) {
	res, err := c.sendListCalls(ctx, params)
	return res, err
}

func (c *Client) sendListCalls(ctx context.Context, params ListCallsParams) (res ListCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "callStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "callStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListCallsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListConferences invokes listConferences operation.
//
// List conferences.
//
// GET /Accounts/{AccountSid}/Conferences
func (c *Client) ListConferences(ctx context.Context, params ListConferencesParams) (ListConferencesRes, error) {
	res, err := c.sendListConferences(ctx, params)
	return res, err
}

func (c *Client) sendListConferences(ctx context.Context, params ListConferencesParams) (res ListConferencesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListConferencesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListConferencesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListGoogleCustomVoices invokes listGoogleCustomVoices operation.
//
// List google custom voices.
//
// GET /GoogleCustomVoices
func (c *Client) ListGoogleCustomVoices(ctx context.Context, params ListGoogleCustomVoicesParams) (ListGoogleCustomVoicesRes, error) {
	res, err := c.sendListGoogleCustomVoices(ctx, params)
	return res, err
}

func (c *Client) sendListGoogleCustomVoices(ctx context.Context, params ListGoogleCustomVoicesParams) (res ListGoogleCustomVoicesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/GoogleCustomVoices"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "service_provider_sid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "service_provider_sid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ServiceProviderSid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "account_sid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "account_sid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AccountSid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "speech_credential_sid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "speech_credential_sid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SpeechCredentialSid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListGoogleCustomVoicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListGoogleCustomVoicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLeastCostRoutingCarrierSetEntries invokes listLeastCostRoutingCarrierSetEntries operation.
//
// List least cost routings routes.
//
// GET /LcrCarrierSetEntries
func (c *Client) ListLeastCostRoutingCarrierSetEntries(ctx context.Context) (ListLeastCostRoutingCarrierSetEntriesRes, error) {
	res, err := c.sendListLeastCostRoutingCarrierSetEntries(ctx)
	return res, err
}

func (c *Client) sendListLeastCostRoutingCarrierSetEntries(ctx context.Context) (res ListLeastCostRoutingCarrierSetEntriesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/LcrCarrierSetEntries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListLeastCostRoutingCarrierSetEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListLeastCostRoutingCarrierSetEntriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLeastCostRoutingRoutes invokes listLeastCostRoutingRoutes operation.
//
// List least cost routings routes.
//
// GET /LcrRoutes
func (c *Client) ListLeastCostRoutingRoutes(ctx context.Context) (ListLeastCostRoutingRoutesRes, error) {
	res, err := c.sendListLeastCostRoutingRoutes(ctx)
	return res, err
}

func (c *Client) sendListLeastCostRoutingRoutes(ctx context.Context) (res ListLeastCostRoutingRoutesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/LcrRoutes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListLeastCostRoutingRoutesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListLeastCostRoutingRoutesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLeastCostRoutings invokes listLeastCostRoutings operation.
//
// List least cost routings.
//
// GET /Lcrs
func (c *Client) ListLeastCostRoutings(ctx context.Context) (ListLeastCostRoutingsRes, error) {
	res, err := c.sendListLeastCostRoutings(ctx)
	return res, err
}

func (c *Client) sendListLeastCostRoutings(ctx context.Context) (res ListLeastCostRoutingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Lcrs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListLeastCostRoutingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListLeastCostRoutingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMsTeamsTenants invokes listMsTeamsTenants operation.
//
// List MS Teams tenants.
//
// GET /MicrosoftTeamsTenants
func (c *Client) ListMsTeamsTenants(ctx context.Context) (ListMsTeamsTenantsRes, error) {
	res, err := c.sendListMsTeamsTenants(ctx)
	return res, err
}

func (c *Client) sendListMsTeamsTenants(ctx context.Context) (res ListMsTeamsTenantsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/MicrosoftTeamsTenants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListMsTeamsTenantsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListMsTeamsTenantsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPredefinedCarriers invokes listPredefinedCarriers operation.
//
// Get a list of predefined carriers.
//
// GET /PredefinedCarriers
func (c *Client) ListPredefinedCarriers(ctx context.Context) ([]PredefinedCarrier, error) {
	res, err := c.sendListPredefinedCarriers(ctx)
	return res, err
}

func (c *Client) sendListPredefinedCarriers(ctx context.Context) (res []PredefinedCarrier, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/PredefinedCarriers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListPredefinedCarriersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPredefinedCarriersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPrices invokes listPrices operation.
//
// List all prices.
//
// GET /Prices
func (c *Client) ListPrices(ctx context.Context) (*Product, error) {
	res, err := c.sendListPrices(ctx)
	return res, err
}

func (c *Client) sendListPrices(ctx context.Context) (res *Product, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Prices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListPricesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPricesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProvisionedPhoneNumbers invokes listProvisionedPhoneNumbers operation.
//
// List phone numbers.
//
// GET /PhoneNumbers
func (c *Client) ListProvisionedPhoneNumbers(ctx context.Context) (ListProvisionedPhoneNumbersRes, error) {
	res, err := c.sendListProvisionedPhoneNumbers(ctx)
	return res, err
}

func (c *Client) sendListProvisionedPhoneNumbers(ctx context.Context) (res ListProvisionedPhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/PhoneNumbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListProvisionedPhoneNumbersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListProvisionedPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListQueues invokes listQueues operation.
//
// Retrieve active queues for an account.
//
// GET /Accounts/{AccountSid}/Queues
func (c *Client) ListQueues(ctx context.Context, params ListQueuesParams) ([]ListQueuesOKItem, error) {
	res, err := c.sendListQueues(ctx, params)
	return res, err
}

func (c *Client) sendListQueues(ctx context.Context, params ListQueuesParams) (res []ListQueuesOKItem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Queues"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListQueuesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListQueuesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRecentCalls invokes listRecentCalls operation.
//
// Retrieve recent calls for an account.
//
// GET /Accounts/{AccountSid}/RecentCalls
func (c *Client) ListRecentCalls(ctx context.Context, params ListRecentCallsParams) (ListRecentCallsRes, error) {
	res, err := c.sendListRecentCalls(ctx, params)
	return res, err
}

func (c *Client) sendListRecentCalls(ctx context.Context, params ListRecentCallsParams) (res ListRecentCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RecentCalls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Page))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Count))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "days" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "days",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Days.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.End.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "answered" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "answered",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Answered.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListRecentCallsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRecentCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRecentCallsBySP invokes listRecentCallsBySP operation.
//
// Retrieve recent calls for an account.
//
// GET /ServiceProviders/{ServiceProviderSid}/RecentCalls
func (c *Client) ListRecentCallsBySP(ctx context.Context, params ListRecentCallsBySPParams) (ListRecentCallsBySPRes, error) {
	res, err := c.sendListRecentCallsBySP(ctx, params)
	return res, err
}

func (c *Client) sendListRecentCallsBySP(ctx context.Context, params ListRecentCallsBySPParams) (res ListRecentCallsBySPRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RecentCalls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Page))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Float64ToString(params.Count))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "days" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "days",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Days.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.End.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "answered" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "answered",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Answered.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListRecentCallsBySPOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRecentCallsBySPResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRegisteredSipUsers invokes listRegisteredSipUsers operation.
//
// Retrieve online sip users for an account.
//
// GET /Accounts/{AccountSid}/RegisteredSipUsers
func (c *Client) ListRegisteredSipUsers(ctx context.Context, params ListRegisteredSipUsersParams) ([]string, error) {
	res, err := c.sendListRegisteredSipUsers(ctx, params)
	return res, err
}

func (c *Client) sendListRegisteredSipUsers(ctx context.Context, params ListRegisteredSipUsersParams) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RegisteredSipUsers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListRegisteredSipUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRegisteredSipUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRegisteredSipUsersByUsername invokes listRegisteredSipUsersByUsername operation.
//
// Retrieve online sip users for an account by list of sip username.
//
// POST /Accounts/{AccountSid}/RegisteredSipUsers
func (c *Client) ListRegisteredSipUsersByUsername(ctx context.Context, request []string, params ListRegisteredSipUsersByUsernameParams) ([]RegisteredClient, error) {
	res, err := c.sendListRegisteredSipUsersByUsername(ctx, request, params)
	return res, err
}

func (c *Client) sendListRegisteredSipUsersByUsername(ctx context.Context, request []string, params ListRegisteredSipUsersByUsernameParams) (res []RegisteredClient, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/RegisteredSipUsers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeListRegisteredSipUsersByUsernameRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListRegisteredSipUsersByUsernameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRegisteredSipUsersByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSbcs invokes listSbcs operation.
//
// Retrieve public IP addresses of the jambonz SBCs.
//
// GET /Sbcs
func (c *Client) ListSbcs(ctx context.Context, params ListSbcsParams) (ListSbcsRes, error) {
	res, err := c.sendListSbcs(ctx, params)
	return res, err
}

func (c *Client) sendListSbcs(ctx context.Context, params ListSbcsParams) (res ListSbcsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Sbcs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "service_provider_sid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "service_provider_sid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ServiceProviderSid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListSbcsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListSbcsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListServiceProviders invokes listServiceProviders operation.
//
// List service providers.
//
// GET /ServiceProviders
func (c *Client) ListServiceProviders(ctx context.Context) (ListServiceProvidersRes, error) {
	res, err := c.sendListServiceProviders(ctx)
	return res, err
}

func (c *Client) sendListServiceProviders(ctx context.Context) (res ListServiceProvidersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ServiceProviders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListServiceProvidersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListServiceProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSipGateways invokes listSipGateways operation.
//
// List sip gateways.
//
// GET /SipGateways
func (c *Client) ListSipGateways(ctx context.Context, params ListSipGatewaysParams) (ListSipGatewaysRes, error) {
	res, err := c.sendListSipGateways(ctx, params)
	return res, err
}

func (c *Client) sendListSipGateways(ctx context.Context, params ListSipGatewaysParams) (res ListSipGatewaysRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/SipGateways"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "voip_carrier_sid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "voip_carrier_sid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.VoipCarrierSid))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListSipGatewaysOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListSipGatewaysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSmppGateways invokes listSmppGateways operation.
//
// List smpp gateways.
//
// GET /SmppGateways
func (c *Client) ListSmppGateways(ctx context.Context) (ListSmppGatewaysRes, error) {
	res, err := c.sendListSmppGateways(ctx)
	return res, err
}

func (c *Client) sendListSmppGateways(ctx context.Context) (res ListSmppGatewaysRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/SmppGateways"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListSmppGatewaysOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListSmppGatewaysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSmpps invokes listSmpps operation.
//
// Retrieve public IP addresses of the jambonz smpp servers.
//
// GET /Smpps
func (c *Client) ListSmpps(ctx context.Context, params ListSmppsParams) (ListSmppsRes, error) {
	res, err := c.sendListSmpps(ctx, params)
	return res, err
}

func (c *Client) sendListSmpps(ctx context.Context, params ListSmppsParams) (res ListSmppsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Smpps"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "service_provider_sid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "service_provider_sid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ServiceProviderSid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListSmppsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListSmppsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSpeechCredentials invokes listSpeechCredentials operation.
//
// Retrieve all speech credentials for an account.
//
// GET /Accounts/{AccountSid}/SpeechCredentials
func (c *Client) ListSpeechCredentials(ctx context.Context, params ListSpeechCredentialsParams) (ListSpeechCredentialsRes, error) {
	res, err := c.sendListSpeechCredentials(ctx, params)
	return res, err
}

func (c *Client) sendListSpeechCredentials(ctx context.Context, params ListSpeechCredentialsParams) (res ListSpeechCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListSpeechCredentialsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListSpeechCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUsers invokes listUsers operation.
//
// List all users.
//
// GET /Users
func (c *Client) ListUsers(ctx context.Context) (ListUsersRes, error) {
	res, err := c.sendListUsers(ctx)
	return res, err
}

func (c *Client) sendListUsers(ctx context.Context) (res ListUsersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVoipCarriers invokes listVoipCarriers operation.
//
// List voip carriers.
//
// GET /VoipCarriers
func (c *Client) ListVoipCarriers(ctx context.Context) (ListVoipCarriersRes, error) {
	res, err := c.sendListVoipCarriers(ctx)
	return res, err
}

func (c *Client) sendListVoipCarriers(ctx context.Context) (res ListVoipCarriersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/VoipCarriers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ListVoipCarriersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListVoipCarriersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Login invokes login operation.
//
// Login and retrieve a JWT.
//
// POST /login
func (c *Client) Login(ctx context.Context, request OptLogin) (LoginRes, error) {
	res, err := c.sendLogin(ctx, request)
	return res, err
}

func (c *Client) sendLogin(ctx context.Context, request OptLogin) (res LoginRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/login"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, LoginOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LoginUser invokes loginUser operation.
//
// Sign in using email and password.
//
// POST /signin
func (c *Client) LoginUser(ctx context.Context, request OptLoginUserReq) (LoginUserRes, error) {
	res, err := c.sendLoginUser(ctx, request)
	return res, err
}

func (c *Client) sendLoginUser(ctx context.Context, request OptLoginUserReq) (res LoginUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/signin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLoginUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, LoginUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLoginUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LogoutUser invokes logoutUser operation.
//
// Log out and deactivate the JWT.
//
// POST /logout
func (c *Client) LogoutUser(ctx context.Context) (LogoutUserRes, error) {
	res, err := c.sendLogoutUser(ctx)
	return res, err
}

func (c *Client) sendLogoutUser(ctx context.Context) (res LogoutUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/logout"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, LogoutUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLogoutUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ManageSubscription invokes manageSubscription operation.
//
// Create or modify subscriptions in Stripe for a customer.
//
// POST /Subscriptions
func (c *Client) ManageSubscription(ctx context.Context, request OptManageSubscriptionReq) (ManageSubscriptionRes, error) {
	res, err := c.sendManageSubscription(ctx, request)
	return res, err
}

func (c *Client) sendManageSubscription(ctx context.Context, request OptManageSubscriptionReq) (res ManageSubscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeManageSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ManageSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeManageSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProvisionPhoneNumber invokes provisionPhoneNumber operation.
//
// Provision a phone number into inventory from a Voip Carrier.
//
// POST /PhoneNumbers
func (c *Client) ProvisionPhoneNumber(ctx context.Context, request OptProvisionPhoneNumberReq) (ProvisionPhoneNumberRes, error) {
	res, err := c.sendProvisionPhoneNumber(ctx, request)
	return res, err
}

func (c *Client) sendProvisionPhoneNumber(ctx context.Context, request OptProvisionPhoneNumberReq) (res ProvisionPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/PhoneNumbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProvisionPhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ProvisionPhoneNumberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProvisionPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PutTenant invokes putTenant operation.
//
// Update an MS Teams tenant.
//
// PUT /MicrosoftTeamsTenants/{TenantSid}
func (c *Client) PutTenant(ctx context.Context, request OptMsTeamsTenant, params PutTenantParams) (PutTenantRes, error) {
	res, err := c.sendPutTenant(ctx, request, params)
	return res, err
}

func (c *Client) sendPutTenant(ctx context.Context, request OptMsTeamsTenant, params PutTenantParams) (res PutTenantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/MicrosoftTeamsTenants/"
	{
		// Encode "TenantSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "TenantSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TenantSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePutTenantRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, PutTenantOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePutTenantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegisterUser invokes registerUser operation.
//
// Create a new user and account.
//
// POST /register
func (c *Client) RegisterUser(ctx context.Context, request OptRegisterUserReq) (RegisterUserRes, error) {
	res, err := c.sendRegisterUser(ctx, request)
	return res, err
}

func (c *Client) sendRegisterUser(ctx context.Context, request OptRegisterUserReq) (res RegisterUserRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/register"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, RegisterUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRegisterUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveInvoice invokes retrieveInvoice operation.
//
// Retrieve upcoming invoice for customer.
//
// GET /Invoices
func (c *Client) RetrieveInvoice(ctx context.Context) (RetrieveInvoiceRes, error) {
	res, err := c.sendRetrieveInvoice(ctx)
	return res, err
}

func (c *Client) sendRetrieveInvoice(ctx context.Context) (res RetrieveInvoiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/Invoices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, RetrieveInvoiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveInvoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendActivationCode invokes sendActivationCode operation.
//
// Send an activation code to the user.
//
// POST /ActivationCode
func (c *Client) SendActivationCode(ctx context.Context, request OptSendActivationCodeReq) (SendActivationCodeRes, error) {
	res, err := c.sendSendActivationCode(ctx, request)
	return res, err
}

func (c *Client) sendSendActivationCode(ctx context.Context, request OptSendActivationCodeReq) (res SendActivationCodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ActivationCode"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendActivationCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, SendActivationCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendActivationCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SupportedLanguagesAndVoices invokes supportedLanguagesAndVoices operation.
//
// Get supported languages, voices and models.
//
// GET /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/speech/supportedLanguagesAndVoices
func (c *Client) SupportedLanguagesAndVoices(ctx context.Context, params SupportedLanguagesAndVoicesParams) (SupportedLanguagesAndVoicesRes, error) {
	res, err := c.sendSupportedLanguagesAndVoices(ctx, params)
	return res, err
}

func (c *Client) sendSupportedLanguagesAndVoices(ctx context.Context, params SupportedLanguagesAndVoicesParams) (res SupportedLanguagesAndVoicesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/speech/supportedLanguagesAndVoices"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "vendor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vendor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Vendor))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "label" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "label",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Label.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, SupportedLanguagesAndVoicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSupportedLanguagesAndVoicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SupportedLanguagesAndVoicesByAccount invokes supportedLanguagesAndVoicesByAccount operation.
//
// Get supported languages, voices and models.
//
// GET /Accounts/{AccountSid}/SpeechCredentials/speech/supportedLanguagesAndVoices
func (c *Client) SupportedLanguagesAndVoicesByAccount(ctx context.Context, params SupportedLanguagesAndVoicesByAccountParams) (SupportedLanguagesAndVoicesByAccountRes, error) {
	res, err := c.sendSupportedLanguagesAndVoicesByAccount(ctx, params)
	return res, err
}

func (c *Client) sendSupportedLanguagesAndVoicesByAccount(ctx context.Context, params SupportedLanguagesAndVoicesByAccountParams) (res SupportedLanguagesAndVoicesByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/speech/supportedLanguagesAndVoices"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "vendor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vendor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Vendor))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "label" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "label",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Label.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, SupportedLanguagesAndVoicesByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSupportedLanguagesAndVoicesByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Synthesize invokes Synthesize operation.
//
// Get TTS from provider.
//
// POST /Accounts/{AccountSid}/TtsCache/Synthesize
func (c *Client) Synthesize(ctx context.Context, request OptSynthesizeReq, params SynthesizeParams) (SynthesizeRes, error) {
	res, err := c.sendSynthesize(ctx, request, params)
	return res, err
}

func (c *Client) sendSynthesize(ctx context.Context, request OptSynthesizeReq, params SynthesizeParams) (res SynthesizeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/TtsCache/Synthesize"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSynthesizeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, SynthesizeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSynthesizeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestSpeechCredential invokes testSpeechCredential operation.
//
// Test a speech credential.
//
// GET /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}/test
func (c *Client) TestSpeechCredential(ctx context.Context, params TestSpeechCredentialParams) (TestSpeechCredentialRes, error) {
	res, err := c.sendTestSpeechCredential(ctx, params)
	return res, err
}

func (c *Client) sendTestSpeechCredential(ctx context.Context, params TestSpeechCredentialParams) (res TestSpeechCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/test"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TestSpeechCredentialOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestSpeechCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestSpeechCredentialByAccount invokes testSpeechCredentialByAccount operation.
//
// Test a speech credential.
//
// GET /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}/test
func (c *Client) TestSpeechCredentialByAccount(ctx context.Context, params TestSpeechCredentialByAccountParams) (TestSpeechCredentialByAccountRes, error) {
	res, err := c.sendTestSpeechCredentialByAccount(ctx, params)
	return res, err
}

func (c *Client) sendTestSpeechCredentialByAccount(ctx context.Context, params TestSpeechCredentialByAccountParams) (res TestSpeechCredentialByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/test"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TestSpeechCredentialByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTestSpeechCredentialByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccount invokes updateAccount operation.
//
// Update account.
//
// PUT /Accounts/{AccountSid}
func (c *Client) UpdateAccount(ctx context.Context, request OptAccount, params UpdateAccountParams) (UpdateAccountRes, error) {
	res, err := c.sendUpdateAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAccount(ctx context.Context, request OptAccount, params UpdateAccountParams) (res UpdateAccountRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateApplication invokes updateApplication operation.
//
// Update application.
//
// PUT /Applications/{ApplicationSid}
func (c *Client) UpdateApplication(ctx context.Context, request OptApplication, params UpdateApplicationParams) (UpdateApplicationRes, error) {
	res, err := c.sendUpdateApplication(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateApplication(ctx context.Context, request OptApplication, params UpdateApplicationParams) (res UpdateApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Applications/"
	{
		// Encode "ApplicationSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ApplicationSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicationSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateApplicationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCall invokes updateCall operation.
//
// Update a call.
//
// POST /Accounts/{AccountSid}/Calls/{CallSid}
func (c *Client) UpdateCall(ctx context.Context, request OptUpdateCallReq, params UpdateCallParams) (UpdateCallRes, error) {
	res, err := c.sendUpdateCall(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCall(ctx context.Context, request OptUpdateCallReq, params UpdateCallParams) (res UpdateCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "CallSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "CallSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateCallOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGoogleCustomVoice invokes updateGoogleCustomVoice operation.
//
// Update google custom voice.
//
// PUT /GoogleCustomVoices/{GoogleCustomVoiceSid}
func (c *Client) UpdateGoogleCustomVoice(ctx context.Context, request OptGoogleCustomVoice, params UpdateGoogleCustomVoiceParams) (UpdateGoogleCustomVoiceRes, error) {
	res, err := c.sendUpdateGoogleCustomVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateGoogleCustomVoice(ctx context.Context, request OptGoogleCustomVoice, params UpdateGoogleCustomVoiceParams) (res UpdateGoogleCustomVoiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/GoogleCustomVoices/"
	{
		// Encode "GoogleCustomVoiceSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "GoogleCustomVoiceSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GoogleCustomVoiceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateGoogleCustomVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateGoogleCustomVoiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateGoogleCustomVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLeastCostRouting invokes updateLeastCostRouting operation.
//
// Update least cost routing.
//
// PUT /Lcrs/{LcrSid}
func (c *Client) UpdateLeastCostRouting(ctx context.Context, request OptLcr, params UpdateLeastCostRoutingParams) (UpdateLeastCostRoutingRes, error) {
	res, err := c.sendUpdateLeastCostRouting(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateLeastCostRouting(ctx context.Context, request OptLcr, params UpdateLeastCostRoutingParams) (res UpdateLeastCostRoutingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Lcrs/"
	{
		// Encode "LcrSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLeastCostRoutingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateLeastCostRoutingOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateLeastCostRoutingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLeastCostRoutingCarrierSetEntry invokes updateLeastCostRoutingCarrierSetEntry operation.
//
// Update least cost routing carrier set entry.
//
// PUT /LcrCarrierSetEntries/{LcrCarrierSetEntrySid}
func (c *Client) UpdateLeastCostRoutingCarrierSetEntry(ctx context.Context, request OptLcrCarrierSetEntry, params UpdateLeastCostRoutingCarrierSetEntryParams) (UpdateLeastCostRoutingCarrierSetEntryRes, error) {
	res, err := c.sendUpdateLeastCostRoutingCarrierSetEntry(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateLeastCostRoutingCarrierSetEntry(ctx context.Context, request OptLcrCarrierSetEntry, params UpdateLeastCostRoutingCarrierSetEntryParams) (res UpdateLeastCostRoutingCarrierSetEntryRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/LcrCarrierSetEntries/"
	{
		// Encode "LcrCarrierSetEntrySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrCarrierSetEntrySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrCarrierSetEntrySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLeastCostRoutingCarrierSetEntryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateLeastCostRoutingCarrierSetEntryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateLeastCostRoutingCarrierSetEntryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLeastCostRoutingRoute invokes updateLeastCostRoutingRoute operation.
//
// Update least cost routing route.
//
// PUT /LcrRoutes/{LcrRouteSid}
func (c *Client) UpdateLeastCostRoutingRoute(ctx context.Context, request OptLcrRoute, params UpdateLeastCostRoutingRouteParams) (UpdateLeastCostRoutingRouteRes, error) {
	res, err := c.sendUpdateLeastCostRoutingRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateLeastCostRoutingRoute(ctx context.Context, request OptLcrRoute, params UpdateLeastCostRoutingRouteParams) (res UpdateLeastCostRoutingRouteRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/LcrRoutes/"
	{
		// Encode "LcrRouteSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrRouteSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrRouteSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLeastCostRoutingRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateLeastCostRoutingRouteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateLeastCostRoutingRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLeastCostRoutingRoutesAndCarrierEntries invokes updateLeastCostRoutingRoutesAndCarrierEntries operation.
//
// Update least cost routing routes and carrier set entries.
//
// PUT /Lcrs/{LcrSid}/Routes
func (c *Client) UpdateLeastCostRoutingRoutesAndCarrierEntries(ctx context.Context, request LcrRoutes, params UpdateLeastCostRoutingRoutesAndCarrierEntriesParams) (UpdateLeastCostRoutingRoutesAndCarrierEntriesRes, error) {
	res, err := c.sendUpdateLeastCostRoutingRoutesAndCarrierEntries(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateLeastCostRoutingRoutesAndCarrierEntries(ctx context.Context, request LcrRoutes, params UpdateLeastCostRoutingRoutesAndCarrierEntriesParams) (res UpdateLeastCostRoutingRoutesAndCarrierEntriesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/Lcrs/"
	{
		// Encode "LcrSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "LcrSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LcrSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Routes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLeastCostRoutingRoutesAndCarrierEntriesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateLeastCostRoutingRoutesAndCarrierEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateLeastCostRoutingRoutesAndCarrierEntriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneNumber invokes updatePhoneNumber operation.
//
// Update phone number.
//
// PUT /PhoneNumbers/{PhoneNumberSid}
func (c *Client) UpdatePhoneNumber(ctx context.Context, request OptPhoneNumber, params UpdatePhoneNumberParams) (UpdatePhoneNumberRes, error) {
	res, err := c.sendUpdatePhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePhoneNumber(ctx context.Context, request OptPhoneNumber, params UpdatePhoneNumberParams) (res UpdatePhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/PhoneNumbers/"
	{
		// Encode "PhoneNumberSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "PhoneNumberSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdatePhoneNumberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateServiceProvider invokes updateServiceProvider operation.
//
// Update service provider.
//
// PUT /ServiceProviders/{ServiceProviderSid}
func (c *Client) UpdateServiceProvider(ctx context.Context, request OptServiceProvider, params UpdateServiceProviderParams) (UpdateServiceProviderRes, error) {
	res, err := c.sendUpdateServiceProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateServiceProvider(ctx context.Context, request OptServiceProvider, params UpdateServiceProviderParams) (res UpdateServiceProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateServiceProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateServiceProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateServiceProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSipGateway invokes updateSipGateway operation.
//
// Update sip gateway.
//
// PUT /SipGateways/{SipGatewaySid}
func (c *Client) UpdateSipGateway(ctx context.Context, request OptSipGateway, params UpdateSipGatewayParams) (UpdateSipGatewayRes, error) {
	res, err := c.sendUpdateSipGateway(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSipGateway(ctx context.Context, request OptSipGateway, params UpdateSipGatewayParams) (res UpdateSipGatewayRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/SipGateways/"
	{
		// Encode "SipGatewaySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SipGatewaySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SipGatewaySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSipGatewayRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateSipGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateSipGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSmppGateway invokes updateSmppGateway operation.
//
// Update smpp gateway.
//
// PUT /SmppGateways/{SmppGatewaySid}
func (c *Client) UpdateSmppGateway(ctx context.Context, request OptSmppGateway, params UpdateSmppGatewayParams) (UpdateSmppGatewayRes, error) {
	res, err := c.sendUpdateSmppGateway(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSmppGateway(ctx context.Context, request OptSmppGateway, params UpdateSmppGatewayParams) (res UpdateSmppGatewayRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/SmppGateways/"
	{
		// Encode "SmppGatewaySid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SmppGatewaySid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SmppGatewaySid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSmppGatewayRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateSmppGatewayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateSmppGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSpeechCredential invokes updateSpeechCredential operation.
//
// Update a speech credential.
//
// PUT /ServiceProviders/{ServiceProviderSid}/SpeechCredentials/{SpeechCredentialSid}
func (c *Client) UpdateSpeechCredential(ctx context.Context, request OptSpeechCredentialUpdate, params UpdateSpeechCredentialParams) (UpdateSpeechCredentialRes, error) {
	res, err := c.sendUpdateSpeechCredential(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSpeechCredential(ctx context.Context, request OptSpeechCredentialUpdate, params UpdateSpeechCredentialParams) (res UpdateSpeechCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/ServiceProviders/"
	{
		// Encode "ServiceProviderSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ServiceProviderSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceProviderSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSpeechCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateSpeechCredentialOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateSpeechCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSpeechCredentialByAccount invokes updateSpeechCredentialByAccount operation.
//
// Update a speech credential.
//
// PUT /Accounts/{AccountSid}/SpeechCredentials/{SpeechCredentialSid}
func (c *Client) UpdateSpeechCredentialByAccount(ctx context.Context, request OptSpeechCredentialUpdate, params UpdateSpeechCredentialByAccountParams) (UpdateSpeechCredentialByAccountRes, error) {
	res, err := c.sendUpdateSpeechCredentialByAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSpeechCredentialByAccount(ctx context.Context, request OptSpeechCredentialUpdate, params UpdateSpeechCredentialByAccountParams) (res UpdateSpeechCredentialByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/Accounts/"
	{
		// Encode "AccountSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "AccountSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/SpeechCredentials/"
	{
		// Encode "SpeechCredentialSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "SpeechCredentialSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpeechCredentialSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSpeechCredentialByAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateSpeechCredentialByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateSpeechCredentialByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUser invokes updateUser operation.
//
// Update user information.
//
// PUT /Users/{UserSid}
func (c *Client) UpdateUser(ctx context.Context, request OptUpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	res, err := c.sendUpdateUser(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateUser(ctx context.Context, request OptUpdateUserReq, params UpdateUserParams) (res UpdateUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/Users/"
	{
		// Encode "UserSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "UserSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVoipCarrier invokes updateVoipCarrier operation.
//
// Update voip carrier.
//
// PUT /VoipCarriers/{VoipCarrierSid}
func (c *Client) UpdateVoipCarrier(ctx context.Context, request OptVoipCarrier, params UpdateVoipCarrierParams) (UpdateVoipCarrierRes, error) {
	res, err := c.sendUpdateVoipCarrier(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVoipCarrier(ctx context.Context, request OptVoipCarrier, params UpdateVoipCarrierParams) (res UpdateVoipCarrierRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/VoipCarriers/"
	{
		// Encode "VoipCarrierSid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "VoipCarrierSid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoipCarrierSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVoipCarrierRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateVoipCarrierOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVoipCarrierResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateActivationCode invokes validateActivationCode operation.
//
// Validate an activation code.
//
// PUT /ActivationCode/{Code}
func (c *Client) ValidateActivationCode(ctx context.Context, request OptValidateActivationCodeReq, params ValidateActivationCodeParams) (ValidateActivationCodeRes, error) {
	res, err := c.sendValidateActivationCode(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateActivationCode(ctx context.Context, request OptValidateActivationCodeReq, params ValidateActivationCodeParams) (res ValidateActivationCodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/ActivationCode/"
	{
		// Encode "Code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "Code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateActivationCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ValidateActivationCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateActivationCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateInviteCode invokes validateInviteCode operation.
//
// Validate an invite code.
//
// POST /InviteCodes
func (c *Client) ValidateInviteCode(ctx context.Context, request OptValidateInviteCodeReq) (ValidateInviteCodeRes, error) {
	res, err := c.sendValidateInviteCode(ctx, request)
	return res, err
}

func (c *Client) sendValidateInviteCode(ctx context.Context, request OptValidateInviteCodeReq) (res ValidateInviteCodeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/InviteCodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateInviteCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, ValidateInviteCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateInviteCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
